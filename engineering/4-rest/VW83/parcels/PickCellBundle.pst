<?xml version="1.0"?><st-source><!-- Name: PickCellBundleBundleName: PickCellBundleBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any '(none)' '') #(#any 'Base VisualWorks' '') #(#any 'BOSS' '') #(#any 'DistributedModeling' '') #(#any 'DistributedModeling-Mobile' '') #(#any 'DLLCC' '') #(#any 'HTTP' '') #(#any 'ImageReaders' '') #(#any 'JSONReader' '') #(#any 'MIME' '') #(#any 'MobileTrackInterface' '') #(#any 'NetClientBase' '') #(#any 'PostgreSQL3EXDI' '') #(#any 'URISupport' ''))Parcel: nilParcelName: PickCellBundlePrerequisiteDescriptions: #(#(#name '(none)' #componentType #package) #(#name 'Base VisualWorks' #componentType #bundle) #(#name 'BOSS' #componentType #package) #(#name 'DistributedModeling' #componentType #package) #(#name 'DistributedModeling-Mobile' #componentType #package) #(#name 'DLLCC' #componentType #package) #(#name 'HTTP' #componentType #package) #(#name 'ImageReaders' #componentType #package) #(#name 'JSONReader' #componentType #package) #(#name 'MIME' #componentType #package) #(#name 'MobileTrackInterface' #componentType #package) #(#name 'NetClientBase' #componentType #package) #(#name 'PostgreSQL3EXDI' #componentType #package) #(#name 'URISupport' #componentType #package))PrerequisiteParcels: #(#('(none)' '') #('Base VisualWorks' '') #('BOSS' '') #('DistributedModeling' '') #('DistributedModeling-Mobile' '') #('DLLCC' '') #('HTTP' '') #('ImageReaders' '') #('JSONReader' '') #('MIME' '') #('MobileTrackInterface' '') #('NetClientBase' '') #('PostgreSQL3EXDI' '') #('URISupport' '') #('DistributedModeling' '') #('Base VisualWorks' '') #('HTTP' '') #('ImageReaders' '') #('(none)' '') #('JSONReader' '') #('MIME' '') #('NetClientBase' '') #('DLLCC' '') #('URISupport' '') #('BOSS' '') #('MobileTrackInterface' '') #('DistributedModeling-Mobile' '') #('PostgreSQL3EXDI' ''))Version: 1.0.7Date: 9:43:44 PM November 18, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.3 of 28 juillet 2017 on 18 novembre 2018 at 21:43:44</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Smalltalk</name><environment>Root</environment><private>false</private><imports>			Core.*			Kernel.*			OS.*			External.*			Graphics.*			UI.*			Tools.*			CraftedSmalltalk.*			Database.*			Lens.*			private VWHelp.*			private AlgoDis.*			</imports><category>System-Name Spaces</category><attributes><package>PickCell</package></attributes></name-space><class><name>QuickTileProxy</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dicoZoom container client clientArray semaphoreArray semaphoreNext index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileProxyWSN</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileProxyFrance</name><environment>Smalltalk</environment><super>QuickTileProxyWSN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>UIPickCellNodes</name><environment>AlgoDis</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>laVue pickModel percent portee gridAspect leSeuil latitude longitude uiLocation uiCellShow doShowGrid doShowImage doShowGraph doShowCoverCells doShowZones doShowLabel laLat laLon elevation lEchelle guessedName doShowWind knownUrlVH knownUrlWindow storedHistory getData doShowGPS doGetGPS doSaveGPSPoints paraLora num parameters </inst-vars><class-inst-vars>KnownUrls </class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>PickCell</package></attributes></class><class><name>UIMapsv0</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longitude latitude zoom xTile yTile tileView tileImage oldZoom matrixTile clicPointVH lesPointsVH lesPointsGPSVH mercator googleModel drawingParameters doDisplayRange doDisplayNodeName doDisplayNetwork range gpxPickFilename uiState colPickNodes networkColorValue labelPosVH networkList nodePName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>QuickTileProxyOCM</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>ElevationReader</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestBuffer requestTime process processTable </inst-vars><class-inst-vars>Reader </class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>PickCellModel</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellDisplay points filename bounds portee lastGraph pointDictionary zones connectivity colNodes grid geoRef1 geoRef2 cellArray cellClassifier newCellArray mousePoint mouseCell mapOrigin mercator getElevation highLightCells displayModeDictionary guessedName guessedDirectory windArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>PickCellModelFromUrl</name><environment>AlgoDis</environment><super>AlgoDis.PickCellModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>knownUrl </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>QuickTileProxyCentralAmerica</name><environment>Smalltalk</environment><super>QuickTileProxyWSN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTile</name><environment>Smalltalk</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y zoom png image tile retrieving refresh mapClient sema index idx theProxy semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>TraceParserForCSV</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName title lines columns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>BGPickCellData</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xyzRef code nbElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Smalltalk.AlgoDis</category><attributes><package>PickCell</package></attributes></class><comment><class-id>AlgoDis.BGPickCellData</class-id><body>Instances describe employees in terms of the employee's name, age, and salary. Instance Variables	xyzRef	&lt;String&gt;		employee's name	code		&lt;Number&gt;	employee's age	nbElements	&lt;Number&gt;	employee's salary</body></comment><class><name>GlobalMercator</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tileSize initialResolution originShift </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><comment><class-id>GlobalMercator</class-id><body># Project:	GDAL2Tiles, Google Summer of Code 2007 &amp; 2008#           Global Map Tiles Classes# Purpose:	Convert a raster into TMS tiles, create KML SuperOverlay EPSG:4326,#			generate a simple HTML viewers based on Google Maps and OpenLayers# Author:	Klokan Petr Pridal, klokan at klokan dot cz# Web:		http://www.klokan.cz/projects/gdal2tiles/	Pixel and tile coordinates are in TMS notation (origin [0,0] in bottom-left).	What coordinate conversions do we need for TMS Global Mercator tiles::	     LatLon      &lt;-&gt;       Meters      &lt;-&gt;     Pixels    &lt;-&gt;       Tile     	 WGS84 coordinates   Spherical Mercator  Pixels in pyramid  Tiles in pyramid	     lat/lon            XY in metres     XY pixels Z zoom      XYZ from TMS 	    EPSG:4326           EPSG:900913                                         	     .----.              ---------                  --                  TMS      	    /      \     &lt;-&gt;     |       |     &lt;-&gt;       /----/    &lt;-&gt;      Google    	    \      /               |       |              /--------/           QuadTree   	     -----               ---------         /------------/                   	   KML, public   WebMapService         Web Clients      TileMapServiceInstance Variables	initialResolution	&lt;ArithmeticValue | Filename | LogicalFilename | WAFileLibrary&gt;	description of initialResolution	originShift	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of originShift	tileSize	&lt;SmallInteger&gt;	description of tileSize</body></comment><class><name>MapServerConnection</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>MapClient </class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>MapServerConnection</class-id><body>Retrieve data from map server. Two servers are registered : GoogleMap and OpenStreetMap.</body></comment><class><name>QuickTileProxyArcgisWorldHillshade</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>Mapsv0Controller</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>application </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>LightTrap</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name lat lon values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>UIMapTileCacheConfig</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent dicoList dicoBox dicoChoices server </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>UIMapTileCacheConfig</class-id><body>UIMapTileCacheConfig for choosing the map source. Instance Variables	dicoBox	&lt;ValueHolder&gt;	description of dicoBox	dicoChoices	&lt;SelectionInList&gt;	description of dicoChoices	dicoList	&lt;SelectionInList&gt;	description of dicoList	parent	&lt;UIMapAccess&gt;	description of parent	server	&lt;ValueModel&gt;	description of server</body></comment><class><name>TraceParserForCrickets</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>texte dicoState fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><comment><class-id>AlgoDis.TraceParserForCrickets</class-id><body>TraceParserForCrickets is a utility that produces graph based on atrace from simulation.It was developed to help explanation on cricket population evolution.Instance Variables:	dicoState	&lt;(Collection of: (DocumentListItem | GlorpVirtualCollection | SequenceableCollection | ValueWithParametersField)) | GlorpExpression | ReadStream&gt;	description of dicoState	fileName	&lt;CharacterArray&gt;	description of fileName	texte	&lt;Collection&gt;	description of texte</body></comment><class><name>QuickTileController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isMoving previousPoint previousClock currentClock delta forkAnim shifted clicZoneInProgress clicZoneOrigin clicZoneCorner pathInProgress lineInProgress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>CellImage</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellImage signature position geoPosition geoPositionCorner elevation name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>QuickTileProxyOverlay</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dicoZoom container objects compositePart dicoComposite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileProxyMadagascar</name><environment>Smalltalk</environment><super>QuickTileProxyWSN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>GDALReader</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename ncols nrows xllcorner yllcorner cellsize line </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>PickCellDBAccess</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>ShapefileReader</name><environment>Smalltalk</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename handle entitiesPtr shapeTypePtr padfMinBoundPtr padfMaxBoundPtr </inst-vars><class-inst-vars>Shapedir </class-inst-vars><imports>			private ShapefileReaderDictionary.*			</imports><category>ExternalInterface-New</category><attributes><includeFiles><item>lib.h</item></includeFiles><includeDirectories><item>./Source/shapebuild</item></includeDirectories><libraryFiles><item>lib.so</item></libraryFiles><libraryDirectories><item>./Library</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>MapAccess</package></attributes></class><comment><class-id>ShapefileReader</class-id><body>MyShapes provides access to shapefiles through a library. </body></comment><class><name>MapAccess</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xTile yTile zoom originTile mapTileCache component clicPointVH </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>MapAccess</class-id><body>MapAccess is the model for tileView.</body></comment><class><name>QuickTileProxyOSM</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>GPSTrackingInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>usb getData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>Mapsv0Utilities</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>QuickTileProxyQuest1</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileTracker</name><environment>Smalltalk</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastPoint delta previousPoint previousClock currentClock currentPoint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>CovVW</name><environment>Smalltalk</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private CovVWDictionary.*			</imports><category>ExternalInterface-New</category><attributes><includeFiles><item>covVW.h</item></includeFiles><includeDirectories><item>/home/tuyen/VW811/covVWOpt</item></includeDirectories><libraryFiles><item>covVW.so</item></libraryFiles><libraryDirectories><item>/home/tuyen/VW811/covVWOpt</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PickCell</package></attributes></class><class><name>UIQuickMapConfig</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>masterWindow hostSpec useProxy proxyHostname proxyPort tabs isAnimated isPrefetching getUriMethod friendlyName basemapChoices basemap maxSocket maxZoom libraryPath libraryFile libraryDirectories libraryFiles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileProxyVietnam</name><environment>Smalltalk</environment><super>QuickTileProxyWSN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>Mapsv0TileCache</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dicoZoom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>BGPickCell</name><environment>AlgoDis</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uneSerie </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>PickCell</package></attributes></class><comment><class-id>AlgoDis.BGPickCell</class-id><body>Instances are a simple example illustrating the use of data series.It displays the information (salary and age of uneSeries) as a line chart.Instance Variables:	uneSeries &lt;List&gt;	a collection of the company's uneSeries</body></comment><class><name>SystemOrganization</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width height mapOrigin cellSize longitude latitude elevation zoom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>MapTile</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y zoom tile image </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>MapTile</class-id><body>Tile from map server, to be displayed on a GraphicsContext.Instance Variables	image	&lt;Depth8Image&gt;	description of image	tile	&lt;Pixmap&gt;	description of tile	x	&lt;Integer&gt;	description of x	y	&lt;Integer&gt;	description of y	zoom	&lt;Integer&gt;	description of zoom</body></comment><class><name>QuickTileComposite</name><environment>Smalltalk</environment><super>QuickTile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapZoom proxy overlay model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>Mapsv0</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matrixTile nodesPx nodesGPS pickModelTmp pixelPerKm colNodes networkGraph distanceSet dicoNodeDistance dicoReachedNodes colPickedNodesVH range xmlMetadata </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><comment><class-id>Mapsv0</class-id><body>GoogleMap, the model, is displayed by UIGoogleMap. </body></comment><class><name>Batiment</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contour </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>Batiment</class-id><body>Batiment is a geolocalized building. Instance Variables	contour	&lt;(Collection of: GeoPosition) | ExpressionGroup&gt;	description of contour</body></comment><class><name>QuickTileProxyGapiv3</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickConnection</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileProxyGreatBritain</name><environment>Smalltalk</environment><super>QuickTileProxyWSN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>UICellShow</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signaturesToCellMapDictionary classToCells laListe laVue lesPoints laSignature lesCouleurs lesStats leSeuil pointToCells lePerformer leNbDeClasses lIndexClasses lesClasses lastPixel lEditeur targetClass selectedClasses leMaskName positionVH uiLocation uiPickCellNodes showSensors neighborhood theSeaLevel showSea showGround systemOrganization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>NetworkPosition</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longitude latitude altitude metre pixelDico currentZoom currentTile mercator model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>QuickTileProxyGapiv2</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>Mapsv0Proxy</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>HttpConnexion </class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>QuickTileProxyGkhm</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>MyMenu</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>QuickTileModel</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sensorPositions mercator zoom pickModel clicZone clicZoneInProgress clicZoneRectangle clicZoneAllRectangle clicZoneAllRectangleAbsolute sensorsNumber pixelPerKm pickModelRange geoPositionVH textCollector lineArray diviseur highLightCells lastPickCellModel stations stationPositions lightrapData lightrapPositions </inst-vars><class-inst-vars></class-inst-vars><imports>			FranceMeteo.*			</imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>Trevezel</name><environment>Smalltalk</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private TrevezelDictionary.*			</imports><category>ExternalInterface-New</category><attributes><includeFiles><item>trevezel.h</item></includeFiles><includeDirectories><item>/home/serieux/tuyen/VW82/trevezel</item></includeDirectories><libraryFiles><item>trevezel.so</item></libraryFiles><libraryDirectories><item>/home/serieux/tuyen/VW82/trevezel</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PickCell</package></attributes></class><class><name>QuickHttpRequest</name><environment>Smalltalk</environment><super>Net.HttpRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapClients </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>TrackPoint</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id time lon lat alt rssi </inst-vars><class-inst-vars></class-inst-vars><imports>			private TrackPointDictionary.*			</imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>MapAccessController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><class><name>GeoPosition</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longitude latitude elevation toMeter </inst-vars><class-inst-vars>initialResolution originShift </class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>GeoPosition</class-id><body>Geographical position with longitude, latitude and elevation. Instance Variables	elevation	&lt;ArithmeticValue | Duration&gt;	description of elevation	latitude	&lt;AbstractProxy | MessageArchiver | Object | ProtoObject&gt;	description of latitude	longitude	&lt;ArithmeticValue | Vector&gt;	description of longitude	toMeter	&lt;Object | ProtoObject&gt;	description of toMeter</body></comment><class><name>QuickTileMap</name><environment>Smalltalk</environment><super>QuickTileComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller globalMercator dicoProxy satellite path pathInPixel colPathPolyline </inst-vars><class-inst-vars></class-inst-vars><imports>			FranceMeteo.*			</imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>CellView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pixelPoint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>Mapsv0Tile</name><environment>Smalltalk</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xTile yTile zoom image pixmap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>QuickTileProxyThunderforest</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>NetworkDistance</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeA nodeB distance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>QuickTileProxyHillShading</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>PickCellController</name><environment>AlgoDis</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position keyboardProcessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>PseudoTile</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>ImageHistory</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>knownMapUrl imageHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>UIQuickMap</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quickTileMap globalMercator forkMove config configWin currentProxy gpredictReader forkDelay gm newUpdate myModel googleModel gpredictTraceReader satPathDuration laLatTop laLonBottom laLonTop laLatBottom uiLocation mouseLon mouseLat leModeDesPoints leDiviseur lastPickCellModel laSoucheNom </inst-vars><class-inst-vars></class-inst-vars><imports>			Heeg.*			</imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>OpenLayerHtml</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lat lon zoom urlFileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>UIKnownUrls</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>knownUrl laListe lesNoms leUrl leShortName closeVH </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>UIMapAccess</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tileView longitude latitude xTile yTile zoom oldZoom mapAccessVH colBat validComponent echelle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>UIMapAccess</class-id><body>Manage maps: zoom in, zoom out, and travel through the map. </body></comment><class><name>QuickTileProxyIndonesia</name><environment>Smalltalk</environment><super>QuickTileProxyWSN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>CellController</name><environment>AlgoDis</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position optionKey origin dragInProgress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>PickCellView</name><environment>AlgoDis</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>UITextPoints</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leTexte pickModel guessedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>USBSerial</name><environment>Smalltalk</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cportNr bdrate mode </inst-vars><class-inst-vars></class-inst-vars><imports>			private USBSerialDictionary.*			</imports><category>ExternalInterface-New</category><attributes><includeFiles><item>usb.h</item></includeFiles><includeDirectories><item>/Users/monmac/Documents/SerialPort</item></includeDirectories><libraryFiles><item>usb.so</item></libraryFiles><libraryDirectories><item>/Users/monmac/Documents/SerialPort</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PickCell</package></attributes></class><class><name>NetworkOrganisation</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dicoNodesReached </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>Mapsv0View</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>application tileMatrix googleMapTileCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Mapsv0</package></attributes></class><class><name>KnownMapUrl</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url shortName position scale </inst-vars><class-inst-vars>KnownUrls </class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><comment><class-id>AlgoDis.KnownMapUrl</class-id><body>KnownMapUrl represents an Url location having a short name, on which an image is expected to be foundInstance Variables:	position	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of position	scale	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of scale	shortName	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of shortName	url	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of url</body></comment><class><name>MapTileCache</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dicoZoom dicoZoomVH </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>MapTileCache</class-id><body>MapTileCache stores tiles downloaded from remote server, in order to speed up their display. Instance Variables	dicoZoom	&lt;Dictionary&gt;	description of dicoZoom</body></comment><class><name>QuickTileProxyArcgisWorldImagery</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileProxyGapp</name><environment>Smalltalk</environment><super>QuickTileProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>CellClassifier</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary cell cellArray newCellArray pickModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>QuickLayer</name><environment>Smalltalk</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>zoom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>CellSignature</name><environment>AlgoDis</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min max mean seuil mean2 performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><comment><class-id>AlgoDis.CellSignature</class-id><body>CellSignature has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables	max	&lt;ColorValue | ColorValue&gt;	RGB max (max(R), max(G), max(B))	mean	&lt;ColorValue | ColorValue&gt;	description of mean	mean2	&lt;ColorValue&gt;	tableau somme des carres des ecarts Ã  la moyenne , en R, G et B	min	&lt;ColorValue | ColorValue&gt;	description of min	seuil	&lt;ArithmeticValue&gt;	description of seuil</body></comment><class><name>QuickTileProxySenegal</name><environment>Smalltalk</environment><super>QuickTileProxyWSN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>QuickTileOverlay</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y zoom container prx cacheGC </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QuickMap</package></attributes></class><class><name>GPSTrackingStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aGPSTrackingInterface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>UILocation</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mercator leX leY leYGeo leXGeo delayPerCent image coordinateMode corner origine imageName elevation parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PickCell</package></attributes></class><class><name>MapAccessView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MapAccess</package></attributes></class><comment><class-id>MapAccessView</class-id><body>MapAccessView is the view of MapAccess.</body></comment><shared-variable><name>Parameters</name><environment>UILocation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PickCell</package></attributes></shared-variable><shared-variable><name>GMapGettingStarted</name><environment>UIMapsv0</environment><private>false</private><constant>false</constant><category>workspaces</category><initializer></initializer><attributes><package>Mapsv0</package></attributes></shared-variable><shared-variable><name>SatelliteIcon3</name><environment>UIQuickMap</environment><private>false</private><constant>false</constant><category>icons</category><initializer>OpaqueImage 			figure: (Image 		extent: 32@21 		depth: 6 		bitsPerPixel: 8 		palette: (Graphics.MappedPalette 	withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 770 1573)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 3180 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 5300 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2890 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 2890 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4240 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1316 1573)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 256)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2633 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 770 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4240 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 5557 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 6617 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7934 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 4240 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1573 1060 2376)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(513 513 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2890 2376 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 4497 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(513 256 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 3950 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5010 5814 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4497 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(770 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 1830 2890)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 6360 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 5300 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2633 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1573 1060 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 4753 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(256 256 256)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1573 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(513 513 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2376 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6360 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5557 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 2890 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(256 256 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(770 770 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 6070 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6070 5814 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(256 256 513)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 2633 2633)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)]))		usingBits: (ByteArray 	fromPackedString: '@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@F0@B@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@DA@PH@@B@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@DRHPDA@P@@HB@ HB@ HB@ @@@@HB@ HB@ HB@ @@F1@PB!@PDA@S@@HB@ HB@ H@D!HG@@HB@ HB@ @@BA,PDA@DHA@PF0@@@ HB@ HB@ @!@AHR@@HB@ H@F1@ BA@PDA,(F0@@@ HB@ HB@ HB@ @RD!H@@ HB@A8PDA@JDA@PD@@@@ HB@ HB@ HB@ H@@ @@D#P@MPHZBQ,PD@TQD@@@@ HB@ HB@ HB@ HB@ HB@ HOA!T$@@D@CA@PL @@@ HB@ HB@ HB@ HB@ HB@ @@@",3B1PKFB(.L @@@ HB@ HB@ HB@ HB@ HB@ @@DA@@KA0NE@8UI1T@@ HB@ HB@ HB@ HB@ HB@ @@DA@P@CT@E!X@IBP-@ HB@ HB@ HB@ HB@ HB@ @@DA\PDA@W@@4VE!X_F@XB@ HB@ HB@ HB@ HB@!\@DA\PD@(PDA@@MPLVH3@%@@DB@ HB@ HB@ HB@ HBE1@PB!@PDCDP@@@B@ @YD!HRLQ4B@ HB@ HB@ HB@ H@DA@P@A@P@@@B@ HB@!\GD!HRC@HB@ HB@ HB@ HB@ @PDA@&amp;@@@B@ HB@ HBE2&lt;@D!H1@ HB@ HB@ HB@ HB@ @P@@@B@ HB@ HB@ HBB!HRD @B@ HB@ HB@ HB@ HB@ @B@ HB@ HB@ HB@ @WD"&lt;@@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ H@@@HB@ HB@ HB@ HB@ HB')) 			shape: (Image 		extent: 32@21 		depth: 1 		bitsPerPixel: 1 		palette: CoveragePalette monoMaskPalette 	usingBits: #[0 0 0 12 0 0 0 60 0 0 0 254 0 0 3 254 0 224 15 255 1 240 63 255 1 248 127 252 0 248 255 240 1 126 255 192 0 31 255 0 0 223 252 0 3 255 240 0 15 255 192 0 63 255 192 0 255 255 224 0 255 231 240 0 255 131 240 0 254 3 240 0 120 1 240 0 32 3 224 0 0 0 192 0])</initializer><attributes><package>QuickMap</package></attributes></shared-variable><shared-variable><name>SatelliteIcon2</name><environment>UIQuickMap</environment><private>false</private><constant>false</constant><category>icons</category><initializer>OpaqueImage 			figure: (Image 		extent: 32@17 		depth: 4 		bitsPerPixel: 4 		palette: (Graphics.MappedPalette 	withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 4914 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 1638 3276)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 3276 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(546 546 546)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 2730 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 3276 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 4914 3276)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 6552 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 3276 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) 		usingBits: (ByteArray 	fromPackedString: 'L3L3L3L3L3,@L3L3L3L3L3L3L3L3L3@H"KL3L3L4ICL3L3L3L0B8#L2@L3L4H!H$L3L3L3LH"63L2K,4HRH"P3L3L3L3BE.&amp;.&lt;2@H"HRP3L3L3L3L0!ER8"&lt;2@H"P3L3L3L3L3LHTX!X L\BP3L3L3L3L3L3BBTU%U H@3L3L3L3L3L3L2H"IEQXA0L3L3L3L3L3L4H$H"IDV@\CL3L3L3L3L4H$P$H"UE G@3L3L3L3L4H)QBP".HUWA0L3L3L3L4H$QIP$L3B8]0\CL3L3L3H)H"H$L3L3LK\G@3L3L3L"H)H$L3L3L3L0@CL3L3L3L"H"L3L3L3L3L3L3L3L3L3L$P3L3L3L3L3L3L3L3L3Lb')) 			shape: (Image 		extent: 32@17 		depth: 1 		bitsPerPixel: 1 		palette: CoveragePalette monoMaskPalette 	usingBits: #[0 1 192 0 0 7 224 28 0 63 240 127 0 63 253 254 0 63 255 248 0 63 255 224 0 63 255 128 0 63 254 0 0 63 254 0 0 255 254 0 3 255 254 0 15 255 254 0 63 241 254 0 127 192 126 0 255 0 28 0 124 0 0 0 56 0 0 0])</initializer><attributes><package>QuickMap</package></attributes></shared-variable><shared-variable><name>ClosedHandCursor</name><environment>UIQuickMap</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>QuickMap</package></attributes></shared-variable><shared-variable><name>SatelliteIcon4</name><environment>UIQuickMap</environment><private>false</private><constant>false</constant><category>icons</category><initializer></initializer><attributes><package>QuickMap</package></attributes></shared-variable><shared-variable><name>SavedSession</name><environment>UIQuickMap</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>QuickMap</package></attributes></shared-variable><shared-variable><name>SatelliteIcon</name><environment>UIQuickMap</environment><private>false</private><constant>false</constant><category>icons</category><initializer>OpaqueImage 			figure: (Image 		extent: 16@16 		depth: 4 		bitsPerPixel: 4 		palette: (Graphics.MappedPalette 	withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 6552 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6167 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 3822 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1092 1092 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4914 8191)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) 		usingBits: #[102 102 102 136 136 102 6 102 102 102 88 102 102 0 160 102 6 102 134 98 34 32 74 6 96 102 134 34 34 32 164 160 102 6 135 34 34 16 74 6 102 96 134 113 17 32 160 102 102 102 134 34 119 32 6 102 102 102 131 34 119 80 102 102 102 102 6 85 136 32 102 102 102 96 160 34 119 32 102 102 102 10 74 2 119 32 102 102 96 148 164 160 119 32 102 102 9 74 74 7 119 32 102 102 96 164 160 119 119 32 102 102 102 10 0 34 119 1 102 102 102 96 102 0 0 102 102 102]) 			shape: (Image 		extent: 16@16 		depth: 1 		bitsPerPixel: 1 		palette: CoveragePalette 	monoMaskPalette usingBits: #[3 200 0 0 15 252 0 0 143 254 0 0 79 255 0 0 47 254 0 0 31 252 0 0 15 248 0 0 15 240 0 0 15 240 0 0 31 240 0 0 63 240 0 0 127 240 0 0 255 240 0 0 127 240 0 0 63 240 0 0 19 192 0 0])</initializer><attributes><package>QuickMap</package></attributes></shared-variable><shared-variable><name>CovVWDictionary</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PickCell</package></attributes></shared-variable><shared-variable><name>TrackPointDictionary</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PickCell</package></attributes></shared-variable><shared-variable><name>USBSerialDictionary</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PickCell</package></attributes></shared-variable><shared-variable><name>ShapefileReaderDictionary</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MapAccess</package></attributes></shared-variable><shared-variable><name>TrevezelDictionary</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PickCell</package></attributes></shared-variable><shared-variable><name>APoint</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PickCell</package></attributes></shared-variable><shared-variable><name>SelectedServer</name><environment>MapServerConnection</environment><private>false</private><constant>false</constant><category>serverID</category><attributes><package>MapAccess</package></attributes></shared-variable><shared-variable><name>Client</name><environment>Mapsv0Proxy</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Mapsv0</package></attributes></shared-variable><shared-variable><name>Reader</name><environment>AlgoDis.ElevationReader</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PickCell</package></attributes></shared-variable><shared-variable><name>NetworkProxyBackup</name><environment>UIQuickMapConfig</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>QuickMap</package></attributes></shared-variable><methods><class-id>ShapefileReader</class-id> <category>procedures</category><body package="MapAccess">SHPClose: hSHP	&lt;C: void SHPClose(SHPHandle hSHP)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">SHPDestroyObject: psObject	&lt;C: void SHPDestroyObject(SHPObject * psObject)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">SHPGetInfo: hSHP with: pnEntities with: pnShapeType with: padfMinBound with: padfMaxBound	&lt;C: void SHPGetInfo(SHPHandle hSHP, int * pnEntities, int * pnShapeType, double * padfMinBound, double * padfMaxBound)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">SHPOpen: pszShapeFile with: pszAccess	&lt;C: SHPHandle SHPOpen(const char * pszShapeFile, const char * pszAccess)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">SHPReadObject: psSHP with: hEntity	&lt;C: SHPObject *  SHPReadObject(SHPHandle psSHP, int hEntity)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>ShapefileReader</class-id> <category>old procedures</category><body package="MapAccess">DeleteSHP: tabSHP	&lt;C: void DeleteSHP(SHPObject * * tabSHP)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">SHPSize: pszFilename	&lt;C: int SHPSize(char * pszFilename)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">allSHP: pszFilename	&lt;C: SHPObject * *  allSHP(char * pszFilename)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">dumpSHP: pszFilename	&lt;C: SHPObject * *  dumpSHP(char * pszFilename)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">oneSHP: pszFilename with: i	&lt;C: SHPObject *  oneSHP(char * pszFilename, int i)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MapAccess">test: pszFilename	&lt;C: tabSHPObject *  test(char * pszFilename)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>CovVW</class-id> <category>procedures</category><body package="PickCell">covVW: cov with: x with: y with: numTurns	&lt;C: void covVW(covStruct * cov, int x, int y, int numTurns)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Trevezel</class-id> <category>procedures</category><body package="PickCell">covVW: cov with: x with: y with: numTurns	&lt;C: void covVW(covStruct * cov, int x, int y, int numTurns)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>USBSerial</class-id> <category>procedures</category><body package="PickCell">RS232_CloseComport: arg	&lt;C: void RS232_CloseComport(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_GetPortnr: arg	&lt;C: int RS232_GetPortnr(const char * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_IsCTSEnabled: arg	&lt;C: int RS232_IsCTSEnabled(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_IsDCDEnabled: arg	&lt;C: int RS232_IsDCDEnabled(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_IsDSREnabled: arg	&lt;C: int RS232_IsDSREnabled(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_OpenComport: arg1 with: arg2 with: arg3	&lt;C: int RS232_OpenComport(int, int, const char * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_PollComport: arg1 with: arg2 with: arg3	&lt;C: int RS232_PollComport(int, unsigned char * , int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_SendBuf: arg1 with: arg2 with: arg3	&lt;C: int RS232_SendBuf(int, unsigned char * , int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_SendByte: arg1 with: arg2	&lt;C: int RS232_SendByte(int, unsigned char)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_cputs: arg1 with: arg2	&lt;C: void RS232_cputs(int, const char * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_disableDTR: arg	&lt;C: void RS232_disableDTR(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_disableRTS: arg	&lt;C: void RS232_disableRTS(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_enableDTR: arg	&lt;C: void RS232_enableDTR(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_enableRTS: arg	&lt;C: void RS232_enableRTS(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_flushRX: arg	&lt;C: void RS232_flushRX(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_flushRXTX: arg	&lt;C: void RS232_flushRXTX(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">RS232_flushTX: arg	&lt;C: void RS232_flushTX(int)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">flushBuf: buf with: size with: cport_nr with: bdrate	&lt;C: int flushBuf(char * buf, int size, int cport_nr, int bdrate)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">readBuf: buf with: size with: cport_nr with: bdrate	&lt;C: int readBuf(char * buf, int size, int cport_nr, int bdrate)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PickCell">setReadBuf: buf with: size with: cport_nr with: bdrate	&lt;C: int setReadBuf(char * buf, int size, int cport_nr, int bdrate)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>AlgoDis.UIPickCellNodes class</class-id> <category>interface specs</category><body package="PickCell">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'PickCell points' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 338 151 1028 674 ) 			#flags: 4 			#menu: #leMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.508696 0 0.00792079 0 0.982609 0 0.112871 ) 					#name: #GroupBox2 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00434783 0 0.00792079 0 0.505797 0 0.112871 ) 					#name: #GroupBox1 ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0057971 0 0.118812 0 0.981159 0 0.988119 ) 					#name: #ViewHolder1 					#flags: 11 					#component: #laVue ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 0 0.0693069 0 0.281159 0 0.0970297 ) 					#name: #Slider1 					#model: #percent 					#orientation: #horizontal 					#start: 0 					#stop: 100 					#step: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.308696 0 0.0657371 0 0.394203 0 0.103586 ) 					#name: #InputField1 					#model: #portee 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.411594 0 0.063745 0 0.498551 0 0.103586 ) 					#name: #InputField2 					#model: #gridAspect ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0115942 0 0.0415842 0 0.0521739 0 0.0653465 ) 					#name: #Label1 					#label: 'range' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.334783 0 0.0356436 0 0.375362 0 0.0594059 ) 					#name: #Label2 					#label: 'range' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.423188 0 0.0376238 0 0.473913 0 0.0613861 ) 					#name: #Label3 					#label: 'section' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.545568 0 0.0179283 0 0.700375 0 0.061753 ) 					#name: #InputField4 					#model: #laLon ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.54432 0 0.0677291 0 0.700375 0 0.109562 ) 					#name: #InputField5 					#model: #laLat ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.513043 0 0.0199601 0 0.550725 0 0.0518962 ) 					#name: #Label4 					#label: 'Lon' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.513043 0 0.0698603 0 0.546377 0 0.101796 ) 					#name: #Label5 					#label: 'Lat' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.763768 0 0.0199203 0 0.824638 0 0.061753 ) 					#name: #InputField6 					#model: #elevation ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.723188 0 0.0219124 0 0.75942 0 0.0537849 ) 					#name: #Label6 					#label: 'Elev' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.736232 0 0.0677291 0 0.831884 0 0.109562 ) 					#name: #ActionButton1 					#model: #doCoverage 					#label: 'Coverage' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.842029 0 0.0199203 0 0.953623 0 0.061753 ) 					#name: #InputField3 					#model: #lEchelle ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.852174 0 0.0677291 0 0.957971 0 0.109562 ) 					#name: #ActionButton2 					#model: #doPara 					#label: 'Parameters' 					#defaultable: true ) ) ) )</body><body package="PickCell">windowSpecOld	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecOld"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'PickCell points' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 880 455 1681 985 ) 			#flags: 4 			#menu: #leMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 341 0 -4 0 836 0 56 0 ) 					#name: #GroupBox2 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 3 0 341 0 56 0 ) 					#name: #GroupBox1 ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00453858 0 0.117063 0 0.987897 0 0.994048 ) 					#name: #ViewHolder1 					#flags: 11 					#component: #laVue ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 30 0 225 0 53 0 ) 					#name: #Slider1 					#model: #percent 					#orientation: #horizontal 					#start: 0 					#stop: 100 					#step: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 232 0 30 0 337 0 54 0 ) 					#name: #InputField1 					#model: #portee 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 346 0 28 0 398 0 52 0 ) 					#name: #InputField2 					#model: #gridAspect ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 410 0 28 0 455 0 53 0 ) 					#name: #InputField3 					#model: #leSeuil 					#type: #number 					#formatString: '0.00' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 3 0 55 0 30 0 ) 					#name: #Label1 					#label: 'range' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 232 0 3 0 267 0 30 0 ) 					#name: #Label2 					#label: 'range' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 349 0 3 0 401 0 26 0 ) 					#name: #Label3 					#label: 'section' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 486 0 3 0 616 0 20 0 ) 					#name: #Label5 					#label: 'x@y' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 462 0 31 0 504 0 50 0 ) 					#name: #LabelLat 					#label: 'lat:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 597 0 30 0 ) 					#name: #LabelLon 					#label: 'lon:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 484 0 30 0 598 0 52 0 ) 					#name: #InputLatitude 					#model: #latitude 					#isReadOnly: false 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 626 0 29 0 746 0 53 0 ) 					#name: #InputLongitude 					#model: #longitude 					#isReadOnly: false 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 842 0 22 0 886 0 52 0 ) 					#name: #'ActionGo!' 					#model: #doGo 					#label: 'Go!' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 630 0 3 0 760 0 20 0 ) 					#name: #Label4 					#label: 'x@y' ) ) ) )</body></methods><methods><class-id>AlgoDis.UIPickCellNodes class</class-id> <category>resources</category><body package="PickCell">leMenu	"Tools.MenuEditor new openOnClass: self andSelector: #leMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Cell system name' 							#value: #doCellSystemName ) 						#(#{UI.MenuItem} 							#rawLabel: 'load image' 							#value: #loadImage ) 						#(#{UI.MenuItem} 							#rawLabel: 'load Url' 							#value: #loadUrl ) 						#(#{UI.MenuItem} 							#rawLabel: 'buid Url History' 							#value: #loadUrlHistory ) 						#(#{UI.MenuItem} 							#rawLabel: 'save postscript' 							#value: #savePostscript ) 						#(#{UI.MenuItem} 							#rawLabel: 'build net' 							#value: #buildNet ) 						#(#{UI.MenuItem} 							#rawLabel: 'load points' 							#value: #loadPoints ) 						#(#{UI.MenuItem} 							#rawLabel: 'save points' 							#value: #savePoints ) ) #(8 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Tools' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'getGPSData' 							#value: #showTrackPoints ) 						#(#{UI.MenuItem} 							#rawLabel: 'showPointsFromLogFile' 							#value: #showPointsFromLogFile ) 						#(#{UI.MenuItem} 							#rawLabel: 'showVisiblePoints' 							#value: #showVisiblePointsTest ) 						#(#{UI.MenuItem} 							#rawLabel: 'showInvisiblePoints' 							#value: #showInvisiblePoints ) 						#(#{UI.MenuItem} 							#rawLabel: 'showCoverageRSSI' 							#value: #doShowCover ) 						#(#{UI.MenuItem} 							#rawLabel: 'loadPointsDB' 							#value: #doPointsDB ) 						#(#{UI.MenuItem} 							#rawLabel: 'Statistics' 							#value: #statisticsVPoints ) 						#(#{UI.MenuItem} 							#rawLabel: 'Get grid cell' 							#value: #buildCellArray ) 						#(#{UI.MenuItem} 							#rawLabel: 'Reset points' 							#value: #resetPoints ) ) #(9 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'View' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Location window' 							#value: #doAwakeLocation ) 						#(#{UI.MenuItem} 							#rawLabel: 'Sea level' 							#nameKey: #doSeaLevel 							#value: #doSeaLevel ) 						#(#{UI.MenuItem} 							#rawLabel: 'Ground level' 							#nameKey: #doGroundLevel 							#value: #doGroundLevel ) 						#(#{UI.MenuItem} 							#rawLabel: 'Get View' 							#value: #doGetView ) 						#(#{UI.MenuItem} 							#rawLabel: 'inspect' 							#value: #doInspect ) 						#(#{UI.MenuItem} 							#rawLabel: 'Grid' 							#nameKey: #showGridID 							#value: #doShowGridSwitch 							#indication: true 							#indicationSelector: #getShowGridMenu ) 						#(#{UI.MenuItem} 							#rawLabel: 'Image' 							#nameKey: #showImageID 							#value: #doShowImageSwitch 							#indication: true 							#indicationSelector: #getShowImageMenu ) 						#(#{UI.MenuItem} 							#rawLabel: 'Graph' 							#nameKey: #showGraphID 							#value: #doShowGraphSwitch 							#indication: true 							#indicationSelector: #getShowGraphMenu ) 						#(#{UI.MenuItem} 							#rawLabel: 'CoverCells' 							#nameKey: #showCoverCellsID 							#value: #doShowCoverCellsSwitch 							#indication: true 							#indicationSelector: #getShowCoverCellsMenu ) 						#(#{UI.MenuItem} 							#rawLabel: 'Label' 							#nameKey: #showLabelID 							#value: #doShowLabelSwitch 							#indication: true 							#indicationSelector: #getShowLabelMenu ) 						#(#{UI.MenuItem} 							#rawLabel: 'Zones' 							#nameKey: #showZonesID 							#value: #doShowZonesSwitch 							#indication: true 							#indicationSelector: #getShowZonesMenu ) 						#(#{UI.MenuItem} 							#rawLabel: 'Wind' 							#nameKey: #showWindID 							#value: #doShowWindSwitch ) ) #(5 7 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UIMapsv0 class</class-id> <category>interface specs</category><body package="Mapsv0">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Display Google maps' 			#min: #(#{Core.Point} 592 412 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 675 277 1661 1033 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 68 ) 					#name: #Label1 					#label: 'lon' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 42 70 142 91 ) 					#name: #InputField1 					#model: #longitude 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 98 ) 					#name: #Label2 					#label: 'lat' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 42 98 142 119 ) 					#name: #InputField2 					#model: #latitude 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 147 133 176 162 ) 					#name: #ActionButton1 					#model: #doTileToDeg 					#label: '^' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.Rectangle} 3 124 173 128 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 6 138 ) 					#name: #Label3 					#label: 'Xtile' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 40 135 140 156 ) 					#name: #InputField3 					#model: #xTile 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 6 166 ) 					#name: #Label4 					#label: 'Ytile' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 40 166 140 187 ) 					#name: #InputField4 					#model: #yTile 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 164 177 193 ) 					#name: #ActionButton2 					#model: #doDegToTile 					#label: 'v' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 6 196 ) 					#name: #Label5 					#label: 'zoom' ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 205 0 23 0 -24 1 -22 1 ) 					#name: #TileViewHolder 					#component: #tileView ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 35 222 146 250 ) 					#name: #ActionButton3 					#model: #doUpdateTile 					#label: 'Refresh map' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 6 655 117 674 ) 					#name: #ActionButton4 					#model: #inspect 					#label: 'Inspect it!' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 6 677 117 700 ) 					#name: #ActionButton5 					#model: #doQuit 					#label: 'Close window' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 203 0 -3 0 -21 1 26 0 ) 					#name: #ActionButton6 					#model: #doChangeUpTile 					#label: '^' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -27 1 19 0 0 1.00537 -20 1 ) 					#name: #ActionButton7 					#model: #doChangeRightTile 					#label: '&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 205 0 -22 1 -22 1 0 1 ) 					#name: #ActionButton8 					#model: #doChangeDownTile 					#label: 'v' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 20 0 208 0 -19 1 ) 					#name: #ActionButton9 					#model: #doChangeLeftTile 					#label: '&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 177 -3 209 26 ) 					#name: #ActionButton10 					#model: #doChangeUpLeftTile 					#label: '.' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -26 1 -3 0 0 1.00537 26 0 ) 					#name: #ActionButton11 					#model: #doChangeUpRightTile 					#label: '.' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -22 1 -23 1 0 1.00134 0 1.0 ) 					#name: #ActionButton12 					#model: #doChangeDownRightTile 					#label: '.' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 180 0 -22 1 206 0 0 1.0 ) 					#name: #ActionButton13 					#model: #doChangeDownLeftTile 					#label: '.' 					#defaultable: true ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 42 195 142 216 ) 					#name: #SpinButton1 					#model: #zoom 					#isReadOnly: false 					#type: #number 					#low: 0 					#high: 21 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 6 630 117 652 ) 					#name: #ActionButton14 					#model: #doReset 					#label: 'Reset values' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 147 65 176 94 ) 					#name: #ActionButton15 					#model: #doPickPoint 					#label: 'X' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 35 266 146 294 ) 					#name: #ActionButton16 					#model: #doOpenGPX 					#label: 'Load Santander' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 35 288 146 316 ) 					#name: #doBuildNet 					#model: #doBuildNet 					#label: 'Draw net' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 28 403 ) 					#name: #CheckBox1 					#model: #doDisplayRange 					#label: 'Range' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 28 384 ) 					#name: #CheckBox2 					#model: #doDisplayNetwork 					#label: 'Network' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 28 422 ) 					#name: #CheckBox3 					#model: #doDisplayNodeName 					#label: 'Node name' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 17 367 169 447 ) 					#name: #GroupBox1 					#label: 'Display' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 6 340 ) 					#name: #Label8 					#label: 'Range' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 53 340 105 361 ) 					#name: #InputField5 					#model: #range 					#alignment: #right 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 109 340 ) 					#name: #Label9 					#label: 'metre' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 6 603 117 630 ) 					#name: #ActionButton20 					#model: #doExportGpx 					#label: 'Export to file...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 378 165 399 ) 					#name: #ChooseNetworkColor 					#flags: 0 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #doChooseNetworkColor 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 400 165 421 ) 					#name: #ChooseRangeColor 					#flags: 0 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #doChooseRangeColor 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Core.Point} 4 3 ) 					#name: #LabelPosition 					#label: #labelPosition ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 422 165 443 ) 					#name: #ChooseNameColor 					#flags: 0 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 1024 1024 8191 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) 						#setSelectionForegroundColor: #(#{Graphics.ColorValue} 1024 1024 8191 ) ) 					#model: #doChooseNameColor 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 6 453 ) 					#name: #Label11 					#label: 'Networks available' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 475 168 600 ) 					#name: #NetworkList 					#model: #networkList 					#helpText: '' 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.CompositeSpecCollection} 					#collection: #() 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 60 763 126 787 ) 						#name: #theNetworkColor 						#colors: #(#{UI.LookPreferences} ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 35 310 146 338 ) 					#name: #ActionButton18 					#model: #buildNetAndSimulators 					#label: 'Build simulations' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 90 5 178 24 ) 					#name: #InputField6 					#isOpaque: true 					#model: #nodePName 					#tabable: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 27 ) 					#name: #Geometry 					#label: 'Geometry' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 6 703 117 726 ) 					#name: #ActionButton17 					#model: #doOpenPickcell 					#label: 'Send to pickcell' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 6 728 117 751 ) 					#name: #ActionButton19 					#model: #testMoving 					#label: 'Test move' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 35 244 146 272 ) 					#name: #ActionButton21 					#model: #doOpenGPXOnFile 					#label: 'Open GPX file...' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UIMapTileCacheConfig class</class-id> <category>interface specs</category><body package="MapAccess">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Map tile cache configuration' 			#bounds: #(#{Graphics.Rectangle} 928 381 1188 577 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 12 13 249 185 ) 					#name: #GroupBox1 					#label: 'Map server' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 39 ) 					#name: #RadioButton1 					#model: #server 					#label: 'Google Map' 					#select: #googleMap ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 68 ) 					#name: #RadioButton2 					#model: #server 					#label: 'Open Cycle Map' 					#select: #OCM ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 99 ) 					#name: #RadioButton3 					#model: #server 					#label: 'Open Street Map' 					#select: #OSM ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 26 136 148 175 ) 					#name: #EmptyCache 					#model: #doEmptyCache 					#label: 'Empty cache' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 6 448 46 ) 					#name: #ActionButton1 					#label: 'Bouton' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 458 4 558 25 ) 					#name: #InputField1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 458 30 558 51 ) 					#name: #InputField2 ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.Rectangle} 350 126 559 330 ) 					#name: #List1 					#model: #dicoList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 376 85 561 117 ) 					#name: #MenuButton1 ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 379 55 560 81 ) 					#name: #ComboBox1 					#model: #dicoBox 					#type: #string 					#comboList: #dicoChoices ) ) ) )</body></methods><methods><class-id>ShapefileReader</class-id> <category>defines</category><body package="MapAccess">SHPP_FIRSTRING	&lt;C: #define SHPP_FIRSTRING 4	&gt;</body><body package="MapAccess">SHPP_INNERRING	&lt;C: #define SHPP_INNERRING 3	&gt;</body><body package="MapAccess">SHPP_OUTERRING	&lt;C: #define SHPP_OUTERRING 2	&gt;</body><body package="MapAccess">SHPP_RING	&lt;C: #define SHPP_RING 5	&gt;</body><body package="MapAccess">SHPP_TRIFAN	&lt;C: #define SHPP_TRIFAN 1	&gt;</body><body package="MapAccess">SHPP_TRISTRIP	&lt;C: #define SHPP_TRISTRIP 0	&gt;</body><body package="MapAccess">SHPT_ARC	&lt;C: #define SHPT_ARC 3	&gt;</body><body package="MapAccess">SHPT_ARCM	&lt;C: #define SHPT_ARCM 23	&gt;</body><body package="MapAccess">SHPT_ARCZ	&lt;C: #define SHPT_ARCZ 13	&gt;</body><body package="MapAccess">SHPT_MULTIPATCH	&lt;C: #define SHPT_MULTIPATCH 31	&gt;</body><body package="MapAccess">SHPT_MULTIPOINT	&lt;C: #define SHPT_MULTIPOINT 8	&gt;</body><body package="MapAccess">SHPT_MULTIPOINTM	&lt;C: #define SHPT_MULTIPOINTM 28	&gt;</body><body package="MapAccess">SHPT_MULTIPOINTZ	&lt;C: #define SHPT_MULTIPOINTZ 18	&gt;</body><body package="MapAccess">SHPT_NULL	&lt;C: #define SHPT_NULL 0	&gt;</body><body package="MapAccess">SHPT_POINT	&lt;C: #define SHPT_POINT 1	&gt;</body><body package="MapAccess">SHPT_POINTM	&lt;C: #define SHPT_POINTM 21	&gt;</body><body package="MapAccess">SHPT_POINTZ	&lt;C: #define SHPT_POINTZ 11	&gt;</body><body package="MapAccess">SHPT_POLYGON	&lt;C: #define SHPT_POLYGON 5	&gt;</body><body package="MapAccess">SHPT_POLYGONM	&lt;C: #define SHPT_POLYGONM 25	&gt;</body><body package="MapAccess">SHPT_POLYGONZ	&lt;C: #define SHPT_POLYGONZ 15	&gt;</body><body package="MapAccess">__DATE__	&lt;C: #define __DATE__ "21 mars 2013"	&gt;</body><body package="MapAccess">__FILE__	&lt;C: #define __FILE__ /export/users/wsn/Herry/legall/shapebuild/lib.h	&gt;</body><body package="MapAccess">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="MapAccess">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="MapAccess">__TIME__	&lt;C: #define __TIME__ "17:35:19"	&gt;</body></methods><methods><class-id>ShapefileReader</class-id> <category>types</category><body package="MapAccess">SAHooks	&lt;C: typedef struct {			int *  (* FOpen)(const char * filename, const char * access);			unsigned long (* FRead)(void * p, unsigned long size, unsigned long nmemb, int * file);			unsigned long (* FWrite)(void * p, unsigned long size, unsigned long nmemb, int * file);			unsigned long (* FSeek)(int * file, unsigned long offset, int whence);			unsigned long (* FTell)(int * file);			int (* FFlush)(int * file);			int (* FClose)(int * file);			int (* Remove)(const char * filename);			void (* Error)(const char * message);			double (* Atof)(const char * str);		} SAHooks&gt;</body><body package="MapAccess">SHPHandle	&lt;C: typedef SHPInfo * SHPHandle&gt;</body><body package="MapAccess">SHPInfo	&lt;C: typedef struct {			SAHooks sHooks;			int * fpSHP;			int * fpSHX;			int nShapeType;			unsigned int nFileSize;			int nRecords, nMaxRecords;			unsigned int * panRecOffset;			unsigned int * panRecSize;			double adBoundsMin[4];			double adBoundsMax[4];			int bUpdated;			unsigned char * pabyRec;			int nBufSize;		} SHPInfo&gt;</body><body package="MapAccess">SHPObject	&lt;C: typedef struct {			int nSHPType, nShapeId, nParts;			int * panPartStart;			int * panPartType;			int nVertices;			double * padfX;			double * padfY;			double * padfZ;			double * padfM;			double dfXMin, dfYMin, dfZMin, dfMMin, dfXMax, dfYMax, dfZMax, dfMMax;			int bMeasureIsUsed;		} SHPObject&gt;</body><body package="MapAccess">tabSHPObject	&lt;C: typedef struct {			SHPObject * * tab;		} tabSHPObject&gt;</body></methods><methods><class-id>GPSTrackingInterface class</class-id> <category>resources</category><body package="PickCell">myMenu	"Tools.MenuEditor new openOnClass: self andSelector: #myMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Tools' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'uploadData' 							#value: #doUpload ) 						#(#{UI.MenuItem} 							#rawLabel: 'retrieveData' ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>GPSTrackingInterface class</class-id> <category>interface specs</category><body package="PickCell">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'GPS tracking' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 439 335 839 465 ) 			#flags: 4 			#menu: #myMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 52 0 22 0 159 0 44 0 ) 					#name: #startTrackingLog 					#model: #startTrackingLog 					#label: 'StartLog' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 226 0 20 0 333 0 42 0 ) 					#name: #stopTracking 					#model: #stopTracking 					#label: 'Stop' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 52 0 67 0 159 0 89 0 ) 					#name: #startTrackingDB 					#model: #startTrackingDB 					#label: 'StartDB' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>CovVW</class-id> <category>defines</category><body package="PickCell">CUDAVW_H	&lt;C: #define CUDAVW_H 	&gt;</body><body package="PickCell">DOUBLE_PI	&lt;C: #define DOUBLE_PI 3.1415926535898d	&gt;</body><body package="PickCell">DYNAMIC_CHAN	&lt;C: #define DYNAMIC_CHAN 25	&gt;</body><body package="PickCell">FADING_MARGIN	&lt;C: #define FADING_MARGIN -30.0d 	&gt;</body><body package="PickCell">LIMIT_SENSIBILITY_RECEIVER	&lt;C: #define LIMIT_SENSIBILITY_RECEIVER -139	&gt;</body><body package="PickCell">MAX_FANOUT	&lt;C: #define MAX_FANOUT 8	&gt;</body><body package="PickCell">MAX_MOBILE	&lt;C: #define MAX_MOBILE 3	&gt;</body><body package="PickCell">NILL	&lt;C: #define NILL -1	&gt;</body><body package="PickCell">NODE_NUMBER	&lt;C: #define NODE_NUMBER 868	&gt;</body><body package="PickCell">OTHER_LOSS	&lt;C: #define OTHER_LOSS -27.0d	&gt;</body><body package="PickCell">TILE_SIZE	&lt;C: #define TILE_SIZE 256	&gt;</body><body package="PickCell">TRANSMIT_POWER	&lt;C: #define TRANSMIT_POWER 20	&gt;</body><body package="PickCell">WAVE_LENGTH	&lt;C: #define WAVE_LENGTH 0.34562211981567d	&gt;</body><body package="PickCell">__DATE__	&lt;C: #define __DATE__ "July 9, 2017"	&gt;</body><body package="PickCell">__FILE__	&lt;C: #define __FILE__ /home/tuyen/VW811/covVWOpt/covVW.h	&gt;</body><body package="PickCell">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="PickCell">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="PickCell">__TIME__	&lt;C: #define __TIME__ "6:30:10 PM"	&gt;</body><body package="PickCell">forwardedSearch	&lt;C: #define forwardedSearch 3	&gt;</body><body package="PickCell">gotSearch	&lt;C: #define gotSearch 2	&gt;</body><body package="PickCell">waitSearch	&lt;C: #define waitSearch 1	&gt;</body></methods><methods><class-id>CovVW</class-id> <category>structs</category><body package="PickCell">CellPositions	&lt;C: struct CellPositions {			int x, y;			double longitude, latitude, elevation;		}&gt;</body><body package="PickCell">ImageExtent	&lt;C: struct ImageExtent {			int width, height;		}&gt;</body><body package="PickCell">RGBPixel	&lt;C: struct RGBPixel {			unsigned char red, green, blue;		}&gt;</body><body package="PickCell">s_canaux	&lt;C: struct s_canaux {			int nbOut, nbIn, nbDyn;			mapped write[8];			mapped read[8];			mapped writeDyn[25];			mapped readDyn[25];		}&gt;</body><body package="PickCell">s_mapped	&lt;C: struct s_mapped {			int node, canal;			Direction direction;		}&gt;</body></methods><methods><class-id>CovVW</class-id> <category>types</category><body package="PickCell">CellArray	&lt;C: typedef struct {			CellPosition position;			CellImage image;		} CellArray&gt;</body><body package="PickCell">CellImage	&lt;C: typedef struct {			struct ImageExtent extent;			Depth24ByteArray pixelArray;		} CellImage&gt;</body><body package="PickCell">CellPosition	&lt;C: typedef struct CellPositions CellPosition&gt;</body><body package="PickCell">Com	&lt;C: typedef struct {			int BW, CR, SF;		} Com&gt;</body><body package="PickCell">Depth24ByteArray	&lt;C: typedef struct RGBPixel Depth24ByteArray[625]&gt;</body><body package="PickCell">Direction	&lt;C: typedef struct {			int x, y;		} Direction&gt;</body><body package="PickCell">NodeState	&lt;C: typedef struct {			double power, delta;			int visible, visited, wasRoot, NumberNeighbour, NumberVisible;			CellPosition cellPosition;			double slope;			int myRoot;			Com com;		} NodeState&gt;</body><body package="PickCell">canaux	&lt;C: typedef struct s_canaux canaux&gt;</body><body package="PickCell">covStruct	&lt;C: typedef struct {			int x, y;			float longitude, latitude, elevation, power;			int visible, BW, CR, SF;		} covStruct&gt;</body><body package="PickCell">mapped	&lt;C: typedef struct s_mapped mapped&gt;</body><body package="PickCell">node_param	&lt;C: typedef struct {			int x, y, range;		} node_param&gt;</body><body package="PickCell">sfSen	&lt;C: typedef struct {			int SF;			float rSen;		} sfSen&gt;</body></methods><methods><class-id>UIQuickMapConfig class</class-id> <category>interface specs</category><body package="QuickMap">basemapSpec	"Tools.UIPainter new openOnClass: self andSelector: #basemapSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 587 456 992 664 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 6 ) 					#name: #Label1 					#label: 'Base map:' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 84 2 247 27 ) 					#name: #ComboBox1 					#model: #basemap 					#type: #object 					#comboList: #basemapChoices ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 34 ) 					#name: #Label2 					#label: 'Name:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 84 30 247 55 ) 					#name: #InputField1 					#model: #friendlyName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 62 ) 					#name: #Label4 					#label: 'Zoom:' ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 84 58 144 83 ) 					#name: #SpinButton1 					#model: #maxZoom 					#isReadOnly: false 					#type: #number 					#formatString: '0' 					#low: 0 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 163 62 ) 					#name: #Label5 					#label: 'Socket:' ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 222 58 282 83 ) 					#name: #SpinButton2 					#model: #maxSocket 					#isReadOnly: false 					#type: #number 					#formatString: '0' 					#low: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 87 ) 					#name: #Label3 					#label: 'Get method:' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.Rectangle} 84 86 402 183 ) 					#name: #TextEditor1 					#model: #getUriMethod 					#tabRequiresControl: true ) ) ) )</body><body package="QuickMap">colorsSpec	"UIPainter new openOnClass: self andSelector: #appearanceSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 0 0 405 208 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(								#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 68 ) 					#name: #LabelA 					#label: 'Label' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 233 68 ) 					#name: #LabelB					#label: 'Label' )  ) ) )</body><body package="QuickMap">displaySpec	"Tools.UIPainter new openOnClass: self andSelector: #displaySpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 438 408 843 616 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 17 29 ) 					#name: #CheckBox1 					#model: #isAnimated 					#label: 'Animation' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 17 65 ) 					#name: #CheckBox2 					#model: #isPrefetching 					#helpText: '''Reduce screen flicker''' 					#label: 'Prefetching tiles' ) ) ) )</body><body package="QuickMap">librarySpec	"Tools.UIPainter new openOnClass: self andSelector: #librarySpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 450 402 855 610 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 218 ) 					#name: #Label1 					#label: 'Library path:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 94 214 225 237 ) 					#name: #InputField1 					#model: #libraryPath ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 264 ) 					#name: #Label2 					#label: 'Library file:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 94 260 225 283 ) 					#name: #InputField2 					#model: #libraryFile ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 228 214 302 237 ) 					#name: #ActionButton1 					#model: #doOpenLibraryPath 					#label: 'Change...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 228 260 302 283 ) 					#name: #ActionButton2 					#model: #doOpenLibraryFile 					#label: 'Change...' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.Rectangle} 129 14 351 62 ) 					#name: #List1 					#model: #libraryDirectories 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 26 22 ) 					#name: #Label3 					#label: 'Directories:' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.Rectangle} 130 73 355 127 ) 					#name: #List2 					#model: #libraryFiles 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 28 86 ) 					#name: #Label4 					#label: 'Files:' ) ) ) )</body><body package="QuickMap">networkSpec	"Tools.UIPainter new openOnClass: self andSelector: #networkSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 438 408 843 616 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 39 ) 					#name: #CheckBoxUseProxy 					#model: #useProxy 					#label: 'Use proxy' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 68 ) 					#name: #LabelHostname 					#label: 'HTTP proxy:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 86 68 218 90 ) 					#name: #InputHostname 					#model: #proxyHostname ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 228 68 ) 					#name: #LabelPort 					#label: 'port:' ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 263 68 335 90 ) 					#name: #SpinButtonPort 					#model: #proxyPort 					#alignment: #right 					#isReadOnly: false 					#type: #number 					#low: 0 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 343 63 398 93 ) 					#name: #ApplyButton 					#model: #doApply 					#label: 'Apply' 					#defaultable: true ) ) ) )</body><body package="QuickMap">tileCacheSpec	"Tools.UIPainter new openOnClass: self andSelector: #tileCacheSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 440 424 840 601 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 1 89 40 ) 					#name: #ActionEmptyCache 					#model: #doEmptyCache 					#label: 'Empty cache' 					#defaultable: true ) ) ) )</body><body package="QuickMap">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Quick Map Configuration' 			#min: #(#{Core.Point} 412 284 ) 			#max: #(#{Core.Point} 412 588 ) 			#bounds: #(#{Graphics.Rectangle} 434 370 846 654 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 9 303 ) 					#name: #CheckBoxUseProxy 					#model: #useProxy 					#label: 'Use proxy' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 5 285 408 369 ) 					#name: #GroupBoxNetwork 					#label: 'Network' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 332 ) 					#name: #LabelHostname 					#label: 'HTTP proxy:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 91 332 223 354 ) 					#name: #InputHostname 					#model: #proxyHostname ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 233 332 ) 					#name: #LabelPort 					#label: 'port:' ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 268 332 340 354 ) 					#name: #SpinButtonPort 					#model: #proxyPort 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 348 327 403 357 ) 					#name: #ApplyButton 					#model: #doApply 					#label: 'Apply' 					#defaultable: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 8 373 396 519 ) 					#name: #GroupBox1 					#label: 'Tile cache' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.Rectangle} 19 411 157 505 ) 					#name: #List1 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 48 389 ) 					#name: #Label1 					#label: 'Base map' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 208 391 ) 					#name: #Label2 					#label: 'Zoom' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 4 0 408 0 -72 1 ) 					#name: #tabbing 					#model: #tabs 					#labels: #() ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -35 1 -1 1 0 0.994186 ) 					#name: #CloseButton 					#model: #doClose 					#label: 'Close' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -66 1 -1 1 -32 1 ) 					#name: #InspectButton 					#model: #inspect 					#label: 'Inspect...' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UIQuickMapConfig class</class-id> <category>resources</category><body package="QuickMap">colorsImage	"UIMaskEditor new openOnClass: self andSelector: #colorsImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue blue; at: 2 put: Graphics.ColorValue magenta; at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 3693 scaledGreen: 3693 scaledBlue: 3693); at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4240 scaledBlue: 0); yourself)) usingBits: #[51 51 51 51 51 0 0 0 50 35 68 50 35 0 0 0 50 35 68 50 35 0 0 0 51 51 51 51 51 0 0 0 49 19 34 50 35 0 0 0 49 19 34 50 35 0 0 0 51 51 51 51 51 0 0 0 50 35 0 50 35 0 0 0 50 35 0 50 35 0 0 0 51 51 51 51 51 0 0 0])</body><body package="QuickMap">net16x16	"UIMaskEditor new openOnClass: self andSelector: #net16x16"	&lt;resource: #image&gt;	^CachedImage on: (((Image extent: 16@16 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 6841 scaledGreen: 6841 scaledBlue: 6841); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 7387 scaledGreen: 7387 scaledBlue: 7387); at: 5 put: (Graphics.ColorValue scaledRed: 4175 scaledGreen: 4175 scaledBlue: 4175); at: 6 put: Graphics.ColorValue blue; at: 7 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); yourself)) usingBits: #[34 34 34 34 34 34 34 34 34 34 34 68 68 68 68 34 34 34 36 51 51 51 51 2 34 34 36 54 102 102 83 2 34 34 36 54 34 85 83 2 34 68 68 68 68 85 83 2 36 51 51 51 51 5 83 2 36 54 102 102 83 5 83 2 36 54 34 85 83 1 16 34 36 54 85 85 83 4 51 68 36 54 85 85 83 0 0 0 36 53 85 85 83 2 34 34 34 65 17 17 16 34 34 34 68 51 67 52 51 68 34 34 64 0 0 0 0 0 34 34 34 34 34 34 34 34 34 34])) convertForGraphicsDevice: Screen default)</body><body package="QuickMap">net16x16mask	"UIMaskEditor new openOnClass: self andSelector: #net16x16mask"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 3 252 0 0 7 254 0 0 7 254 0 0 7 254 0 0 63 254 0 0 127 254 0 0 127 254 0 0 127 252 0 0 127 255 0 0 127 255 0 0 127 224 0 0 63 192 0 0 255 240 0 0 255 240 0 0 0 0 0 0]))</body><body package="QuickMap">printerImage	"UIMaskEditor new openOnClass: self andSelector: #printerImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 7) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (ColorValue scaledRed: 6077 scaledGreen: 6077 scaledBlue: 6077); at: 4 put: ColorValue white; at: 5 put: ColorValue green; at: 6 put: ColorValue red; at: 7 put: (ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: #[34 34 34 34 38 102 34 34 34 34 34 34 99 51 102 34 34 34 34 38 51 51 51 0 34 34 38 99 51 51 48 34 34 38 99 99 51 51 2 34 38 99 17 22 99 48 32 2 99 17 68 17 22 96 38 96 99 51 17 85 17 22 102 96 99 17 51 17 22 102 102 96 99 17 17 54 102 102 102 96 102 17 17 22 102 102 96 2 38 102 17 22 102 96 6 2 32 17 102 22 96 6 96 2 34 0 17 96 6 96 2 34 34 34 0 22 96 2 34 34 34 34 34 34 34 34 34 34])</body></methods><methods><class-id>AlgoDis.BGPickCell class</class-id> <category>windowSpec</category><body package="PickCell">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #BGPickCellData #defaultString: 'cell data' #catalogID: #PickCell) 			#bounds: #(#Rectangle 306 282 621 533 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ChartViewSpec 					#layout: #(#LayoutFrame 13 0 4 0 -5 1 -6 1 ) 					#model: #uneSerie 					#chartType: #BG_LineChartView 					#orientation: #vertical 					#dataSeries: 					#(#ChartDataSpec 						#series: #(							#(#ChartDataSetSpec 								#aspect: #nbElements 								#name: 'nb elements' 								#look: 								#(#ChartElementLookSpec 									#lineWidth: 3 ) ) 							#(#ChartDataSetSpec 								#aspect: #xyzRef 								#isData: false 								#name: 'x y z' ) 							#(#ChartDataSetSpec 								#aspect: #code								#name: 'Code' 								#look: 								#(#ChartElementLookSpec 									#foregroundColor: #(#ColorValue #blue ) 									#backgroundColor: #(#ColorValue #blue ) 									#lineType: #dashed 									#lineWidth: 3 ) ) ) ) 					#xAxis: 					#(#ChartingAxisSpec 						#sectionMarkAt: #divisionMarks ) 					#yAxis: 					#(#ChartingValueAxisSpec 						#scale: 						#(#ChartingScaleSpec 							#invert: true ) ) 					#legendPosition: 6 ) ) ) )</body></methods><methods><class-id>UICellShow class</class-id> <category>resources</category><body package="PickCell">CellView	"Tools.UIMaskEditor new openOnClass: self andSelector: #CellView"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 12@13 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6295 3212 1316)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 610 610)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(610 610 610)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 7227 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 6038 7452)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 7452 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4143 5814 7452)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 2023 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5332 3918 3661)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 7227 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1766 1316 2248)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 4850 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7934 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7709 7227)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1541 1060 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(835 2248 4143)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 6520 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 6295 7452)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6038 7227 7709)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 5814 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7452 6520 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 6295 3661)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5107 3437 2248)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 5332 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 5107 3661)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5332 2248 835)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1541 3918 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 835 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5107 7002 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 7452)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3212 1060 1316)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7934 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 7227)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 7709)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1316 3212)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 13 23 2 3 8 18 34 34 34 34 34 36 0 16 19 14 12 28 6 34 34 34 34 35 9 29 34 34 32 31 17 34 34 34 34 34 34 34 34 34 22 15 6 34 34 34 34 34 34 34 33 24 11 5 34 34 34 34 34 34 34 34 20 37 4 34 34 34 34 34 34 34 34 33 25 7 34 34 34 34 34 34 34 34 34 34 21 10 34 34 34 34 34 34 34 34 34 30 26 27 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34])</body><body package="PickCell">classMenu	"Tools.MenuEditor new openOnClass: self andSelector: #classMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'define target' 				#value: #doTarget ) 			#(#{UI.MenuItem} 				#rawLabel: 'addSource' 				#value: #doAddSource ) 			#(#{UI.MenuItem} 				#rawLabel: 'fusion' 				#value: #doFusion ) 			#(#{UI.MenuItem} 				#rawLabel: 'inspect class' 				#value: #doInspect ) 			#(#{UI.MenuItem} 				#rawLabel: 'build net' 				#value: #doNetwork ) 			#(#{UI.MenuItem} 				#rawLabel: 'file out' 				#value: #fileOutSelectedClassData ) 			#(#{UI.MenuItem} 				#rawLabel: 'Occam  net with data' 				#value: #doNetworkWithDataForOccam ) 			#(#{UI.MenuItem} 				#rawLabel: 'Cuda  net with data' 				#value: #doNetworkWithDataForCuda ) ) #(3 5 ) nil ) decodeAsLiteralArray</body><body package="PickCell">globalMenu	"Tools.MenuEditor new openOnClass: self andSelector: #globalMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'print view' 							#value: #printView ) 						#(#{UI.MenuItem} 							#rawLabel: 'print all views' 							#value: #printAllView ) 						#(#{UI.MenuItem} 							#rawLabel: 'print latex' 							#value: #printLatexPage ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'View' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'new location window' 							#value: #doAwakeLocation ) 						#(#{UI.MenuItem} 							#rawLabel: 'fetch elevation' 							#value: #doFetchElevation 							#indication: false 							#indicationSelector: #changeIndication ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Tools' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'terminate reader' 							#value: #doTerminateReader ) ) #(1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="PickCell">lEditMenu	"Tools.MenuEditor new openOnClass: self andSelector: #lEditMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #qsqd 					#defaultString: 'accepte' ) 				#nameKey: #acceptId 				#value: #doAccept ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="PickCell">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'inspect' 				#value: #doInspect ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UICellShow class</class-id> <category>interface specs</category><body package="PickCell">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'NetGen image browser' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 762 387 1796 1052 ) 			#flags: 4 			#menu: #globalMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.146583 0 0.772973 0 0.266187 0 0.889189 ) 					#name: #GroupBox2 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.580036 0 0.877027 0 0.983813 0 0.982432 ) 					#name: #GroupBox1 					#label: 'neighborhood' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.588129 0 0.675676 0 0.986511 0 0.872973 ) 					#name: #TextEditor1 					#model: #lesStats 					#tabRequiresControl: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.160971 0 0.00675676 0 0.986511 0 0.659459 ) 					#name: #ViewHolder1 					#flags: 11 					#component: #laVue ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.146583 0 0.697297 0 0.486511 0 0.733784 ) 					#name: #InputField1 					#model: #lesPoints ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.15018 0 0.771622 0 0.194245 0 0.804054 ) 					#name: #RadioButton1 					#model: #laSignature 					#label: 'Min' 					#select: #min ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.15018 0 0.804054 0 0.202338 0 0.836486 ) 					#name: #RadioButton2 					#flags: 32 					#model: #laSignature 					#label: 'Mean' 					#select: #mean ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.204137 0 0.771622 0 0.250899 0 0.804054 ) 					#name: #RadioButton3 					#flags: 32 					#model: #laSignature 					#label: 'Max' 					#select: #max ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.146583 0 0.740541 0 0.48741 0 0.777027 ) 					#name: #InputField2 					#model: #lesCouleurs ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.271583 0 0.793243 0 0.481115 0 0.82973 ) 					#name: #InputField3 					#model: #leSeuil 					#type: #fixedpoint 					#formatString: '0.00' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.15018 0 0.836486 0 0.216727 0 0.868919 ) 					#name: #RadioButton4 					#flags: 32 					#model: #laSignature 					#label: 'Variance' 					#select: #mean2 ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00539568 0 0.00675676 0 0.154676 0 0.658108 ) 					#name: #List1 					#model: #lesClasses 					#menu: #classMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.271583 0 0.837838 0 0.464928 0 0.874324 ) 					#name: #InputField4 					#model: #lePerformer 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.434352 0 0.793243 0 0.600719 0 0.82973 ) 					#name: #InputField5 					#model: #leNbDeClasses 					#type: #number 					#formatString: '0' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.434352 0 0.837838 0 0.600719 0 0.874324 ) 					#name: #InputField6 					#model: #lIndexClasses 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00899281 0 0.678378 0 0.0683453 0 0.697297 ) 					#name: #LabelCode 					#label: 'Label : r g b' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.488309 0 0.689189 0 0.488309 0 0.689189 ) 					#name: #LabelControl ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00539568 0 0.895946 0 0.578237 0 0.993243 ) 					#name: #TextEditor2 					#model: #lEditeur 					#menu: #lEditMenu 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.30036 0 0.87027 0 0.372302 0 0.889189 ) 					#name: #Label1 					#label: 'pos: x@y X@Y' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.43795 0 0.864865 0 0.523381 0 0.889189 ) 					#name: #CheckBox1 					#model: #showSensors 					#label: 'show sensors' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.580935 0 0.909459 0 0.678957 0 0.941892 ) 					#name: #RadioButton5 					#model: #neighborhood 					#label: 'Von Neumann 1' 					#select: #vn1Neighborhood ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.580935 0 0.944595 0 0.680755 0 0.977027 ) 					#name: #RadioButton6 					#model: #neighborhood 					#label: 'Von Neumann 2' 					#select: #vn2Neighborhood ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.698741 0 0.909459 0 0.763489 0 0.941892 ) 					#name: #RadioButton7 					#model: #neighborhood 					#label: 'Moore 1' 					#select: #moore1Neighborhood ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.698741 0 0.943243 0 0.765288 0 0.975676 ) 					#name: #RadioButton8 					#model: #neighborhood 					#label: 'Moore 2' 					#select: #moore2Neighborhood ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutFrame} 0 0.488309 0 0.691892 0 0.499101 0 0.709459 ) 					#name: #CellView 					#label: #CellView 					#hasCharacterOrientedLabel: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00870406 0 0.751553 0 0.0560928 0 0.773292 ) 					#name: #Label2 					#label: 'Sea level' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.773292 0 0.144101 0 0.815217 ) 					#name: #InputField7 					#model: #theSeaLevel 					#type: #number ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00386847 0 0.830745 0 0.0435203 0 0.858696 ) 					#name: #CheckBoxSea 					#model: #showSea 					#label: 'Sea' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0667311 0 0.830745 0 0.124758 0 0.858696 ) 					#name: #CheckBox2 					#model: #showGround 					#label: 'Ground' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -9.67118e-4 0 0.736025 0 0.147002 0 0.874224 ) 					#name: #GroupBox3 ) ) ) )</body></methods><methods><class-id>Trevezel</class-id> <category>defines</category><body package="PickCell">CUDAVW_H	&lt;C: #define CUDAVW_H 	&gt;</body><body package="PickCell">DOUBLE_PI	&lt;C: #define DOUBLE_PI 3.1415926535898d	&gt;</body><body package="PickCell">DYNAMIC_CHAN	&lt;C: #define DYNAMIC_CHAN 25	&gt;</body><body package="PickCell">FADING_MARGIN	&lt;C: #define FADING_MARGIN -30.0d 	&gt;</body><body package="PickCell">LIMIT_SENSIBILITY_RECEIVER	&lt;C: #define LIMIT_SENSIBILITY_RECEIVER -139	&gt;</body><body package="PickCell">MAX_FANOUT	&lt;C: #define MAX_FANOUT 8	&gt;</body><body package="PickCell">MAX_MOBILE	&lt;C: #define MAX_MOBILE 3	&gt;</body><body package="PickCell">NILL	&lt;C: #define NILL -1	&gt;</body><body package="PickCell">NODE_NUMBER	&lt;C: #define NODE_NUMBER 48618	&gt;</body><body package="PickCell">OTHER_LOSS	&lt;C: #define OTHER_LOSS -27.0d	&gt;</body><body package="PickCell">TILE_SIZE	&lt;C: #define TILE_SIZE 256	&gt;</body><body package="PickCell">TRANSMIT_POWER	&lt;C: #define TRANSMIT_POWER 20	&gt;</body><body package="PickCell">WAVE_LENGTH	&lt;C: #define WAVE_LENGTH 0.34562211981567d	&gt;</body><body package="PickCell">__DATE__	&lt;C: #define __DATE__ "June 16, 2017"	&gt;</body><body package="PickCell">__FILE__	&lt;C: #define __FILE__ /home/serieux/tuyen/VW82/trevezel/trevezel.h	&gt;</body><body package="PickCell">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="PickCell">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="PickCell">__TIME__	&lt;C: #define __TIME__ "5:54:26 PM"	&gt;</body><body package="PickCell">forwardedSearch	&lt;C: #define forwardedSearch 3	&gt;</body><body package="PickCell">gotSearch	&lt;C: #define gotSearch 2	&gt;</body><body package="PickCell">waitSearch	&lt;C: #define waitSearch 1	&gt;</body></methods><methods><class-id>Trevezel</class-id> <category>types</category><body package="PickCell">CellArray	&lt;C: typedef struct {			CellPosition position;			CellImage image;		} CellArray&gt;</body><body package="PickCell">CellImage	&lt;C: typedef struct {			struct ImageExtent extent;			Depth24ByteArray pixelArray;		} CellImage&gt;</body><body package="PickCell">CellPosition	&lt;C: typedef struct CellPositions CellPosition&gt;</body><body package="PickCell">Depth24ByteArray	&lt;C: typedef struct RGBPixel Depth24ByteArray[25]&gt;</body><body package="PickCell">Direction	&lt;C: typedef struct {			int x, y;		} Direction&gt;</body><body package="PickCell">NodeState	&lt;C: typedef struct {			double power, delta;			int visible, visited, wasRoot, NumberNeighbour, NumberVisible;			CellPosition cellPosition;			double slope;			int myRoot;		} NodeState&gt;</body><body package="PickCell">canaux	&lt;C: typedef struct s_canaux canaux&gt;</body><body package="PickCell">covStruct	&lt;C: typedef struct {			int x, y;			float longitude, latitude, elevation, power;			int visible;		} covStruct&gt;</body><body package="PickCell">mapped	&lt;C: typedef struct s_mapped mapped&gt;</body><body package="PickCell">node_param	&lt;C: typedef struct {			int x, y, range;		} node_param&gt;</body></methods><methods><class-id>Trevezel</class-id> <category>structs</category><body package="PickCell">CellPositions	&lt;C: struct CellPositions {			int x, y;			double longitude, latitude, elevation;		}&gt;</body><body package="PickCell">ImageExtent	&lt;C: struct ImageExtent {			int width, height;		}&gt;</body><body package="PickCell">RGBPixel	&lt;C: struct RGBPixel {			unsigned char red, green, blue;		}&gt;</body><body package="PickCell">s_canaux	&lt;C: struct s_canaux {			int nbOut, nbIn, nbDyn;			mapped write[8];			mapped read[8];			mapped writeDyn[25];			mapped readDyn[25];		}&gt;</body><body package="PickCell">s_mapped	&lt;C: struct s_mapped {			int node, canal;			Direction direction;		}&gt;</body></methods><methods><class-id>UIQuickMap class</class-id> <category>interface specs</category><body package="QuickMap">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 939 419 1724 1070 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0 1 0 56 0 30 0 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0 28 0 57 0 57 0 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0 55 0 57 0 84 0 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 54 0 0 0 0 1.0 0 1.0 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) ) ) )</body><body package="QuickMap">windowSpecChoose	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecChoose"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 300 212 980 812 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -2 1 56 30 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 28 57 57 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 55 57 84 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 87 53 113 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 54 0 0 0 0 1.0 0 1.0 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) ) ) )</body><body package="QuickMap">windowSpecConfig	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecConfig"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Configuration' 			#bounds: #(#{Graphics.Rectangle} 432 318 848 707 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 24 10 78 40 ) 					#name: #ActionButton1 					#model: #doMove 					#label: 'Move' 					#defaultable: true ) ) ) )</body><body package="QuickMap">windowSpecGpredict	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecGpredict"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 337 275 1017 875 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -2 1 56 30 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 28 57 57 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 55 57 84 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 87 53 113 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 0 0 0 1.00128 0 0.996705 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 119 57 148 ) 					#name: #ActionButton4 					#model: #doOpenGpredict 					#label: 'Gpredict' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 179 63 210 ) 					#name: #ActionButton5 					#model: #doBuildNet 					#label: 'Build net' 					#defaultable: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.Rectangle} 76 0 78 597 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 50 					#minBelowSize: 256 					#aboveWidgets: '#ActionButton1 #ActionButton2 #MenuButton1 #ActionButton3 #ActionButton4 #ActionButton5' 					#belowWidgets: '#ViewHolder1' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -3 208 80 241 ) 					#name: #ActionButton6 					#model: #doBuildGraph 					#label: 'Build graph' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 7 291 38 321 ) 					#name: #ActionButton7 					#model: #doSetSensorZone 					#label: #cursorCrossHair 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 6 261 39 295 ) 					#name: #ActionButton8 					#model: #doMoveMap 					#label: #cursorOpenHand 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 3 340 73 363 ) 					#name: #InputField1 					#model: #sensorsNumber 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 150 69 183 ) 					#name: #ActionButton9 					#model: #doOpenGpredictFileReader 					#label: 'GPredict2' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 410 76 436 ) 					#name: #ActionButton10 					#model: #doSatPathDuration 					#label: 'Satellite path' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 62 389 ) 					#name: #Label1 					#label: 'h' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 5 389 56 410 ) 					#name: #InputField2 					#model: #satPathDuration 					#type: #number 					#formatString: '#,##0.00' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 436 76 462 ) 					#name: #ActionButton11 					#model: #doDeleteNet 					#label: 'Delete net' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 473 71 510 ) 					#name: #ActionButton12 					#model: #doGetPath 					#label: 'Get path' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 2 538 74 562 ) 					#name: #InputField3 					#model: #pickModelRange 					#type: #number 					#formatString: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 517 ) 					#name: #Label2 					#label: 'Range (m):' ) ) ) )</body><body package="QuickMap">windowSpecMove	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecMove"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 669 343 1349 943 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8029 7609 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 14 0 68 0 32 0 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 45 0 69 0 63 0 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 72 0 69 0 90 0 ) 					#name: #ActionButton3 					#model: #doMove 					#label: 'Move' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 101 0 67 0 119 0 ) 					#name: #ActionButton4 					#model: #doStopMove 					#label: 'Stop' 					#defaultable: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 4 0 0 1.04396 0 1.00552 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#component: #quickTileMap ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 135 0 59 0 153 0 ) 					#name: #btnLoadMeteoData 					#model: #doLoadMeteoData 					#label: 'Load data' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 173 0 68 0 191 0 ) 					#name: #btnStation 					#model: #doShowStationsonMap 					#label: 'Load station' 					#defaultable: true ) ) ) )</body><body package="QuickMap">windowSpecPickcell	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecPickcell"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #positionSystemDefault #openType #advanced ) 			#label: 'QuickMap' 			#min: #(#{Core.Point} 953 681 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 180 76 1133 757 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00944386 0 0.352423 0 0.144806 0 0.51395 ) 					#name: #GroupBox1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 7167 ) ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 0 0.610866 0 0.0472193 0 0.632893 ) 					#name: #RadioButton2 					#model: #leModeDesPoints 					#label: 'Line' 					#select: #isLine ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 0 0.707783 0 0.147954 0 0.73862 ) 					#name: #ActionButton1 					#model: #doCopy 					#label: 'copy geopos' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.0346275 0 0.0690161 0 -0.0136411 0 0.0910426 ) 					#name: #ActionButton0 					#flags: 0 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 0 0.745962 0 0.147954 0 0.776799 ) 					#name: #ActionButton6 					#model: #showSerie 					#label: 'Add a shape' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0.10279 0 0.147954 0 0.133627 ) 					#name: #ActionButton2 					#model: #doDisplayCover 					#label: 'Display a cover' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0.155653 0 0.146905 0 0.18649 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config Proxy' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0.208517 0 0.149003 0 0.239354 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0.26138 0 0.149003 0 0.292217 ) 					#name: #ActionButton4 					#model: #doOpenShapefile 					#label: 'Open shape' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0.314244 0 0.1532 0 0.345081 ) 					#name: #ActionButton5 					#model: #doOpenPickcell 					#label: 'PickCell...' 					#defaultable: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.156348 0 0.0 0 0.158447 0 0.998532 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 10 					#minBelowSize: 256 					#aboveWidgets: '#ActionButton0' 					#belowWidgets: '#ViewHolder1' ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.162644 0 0.00293686 0 0.983211 0 0.994126 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0188877 0 0.365639 0 0.0388248 0 0.387665 ) 					#name: #Label1 					#label: 'Lon' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00734523 0 0.405286 0 0.140609 0 0.443465 ) 					#name: #InputField1 					#model: #mouseLon 					#style: #small ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00734523 0 0.475771 0 0.140609 0 0.51395 ) 					#name: #InputField2 					#model: #mouseLat 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0188877 0 0.443465 0 0.0356768 0 0.465492 ) 					#name: #Label2 					#label: 'Lat' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 0 0.574156 0 0.0713536 0 0.594714 ) 					#name: #RadioButton1 					#model: #leModeDesPoints 					#label: 'Polygon' 					#select: #isPath ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 0 0.540382 0 0.0524659 0 0.562408 ) 					#name: #RadioButton3 					#model: #leModeDesPoints 					#label: 'Point' 					#select: #isPoint ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 0 0.837004 0 0.147954 0 0.867841 ) 					#name: #ActionButton7 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 0 0.790015 0 0.147954 0 0.820852 ) 					#name: #ActionButton8 					#model: #doSavePoints 					#label: 'Save points' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 0 0.643172 0 0.0514166 0 0.665198 ) 					#name: #RadioButton4 					#model: #leModeDesPoints 					#label: 'Zone' 					#select: #isZone ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0671563 0 0.602056 0 0.137461 0 0.640235 ) 					#name: #InputField3 					#model: #leDiviseur 					#style: #small 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0.0469897 0 0.147954 0 0.0778267 ) 					#name: #ActionButton9 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 0 0.882526 0 0.147954 0 0.913363 ) 					#name: #ActionButton10 					#model: #showtrap 					#label: 'Show traps' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0682057 0 0.566813 0 0.13851 0 0.604993 ) 					#name: #InputField4 					#model: #laSoucheNom 					#style: #small 					#type: #string ) ) ) )</body><body package="QuickMap">windowSpecShapefile	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecShapefile"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 450 250 1130 850 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 0 50 14 ) 					#name: #ActionButton0 					#flags: 0 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 23 57 52 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 50 57 79 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 77 57 106 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 109 53 135 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 137 57 166 ) 					#name: #ActionButton4 					#model: #doOpenShapefile 					#label: 'Open...' 					#defaultable: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.Rectangle} 51 0 53 599 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 10 					#minBelowSize: 256 					#aboveWidgets: '#ActionButton0' 					#belowWidgets: '#ViewHolder1' ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 54 0 0 0 0 1.0 0 1.0 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) ) ) )</body></methods><methods><class-id>UIQuickMap class</class-id> <category>resources</category><body package="QuickMap">cursorHand	"Tools.UIMaskEditor new openOnClass: self andSelector: #cursorHand"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@14 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 13 176 0 0 18 76 0 0 16 10 0 0 8 2 0 0 24 2 0 0 32 2 0 0 32 4 0 0 16 4 0 0 8 8 0 0 4 8 0 0 4 8 0 0 0 0 0 0])</body><body package="QuickMap">cursorHandMask	"Tools.UIMaskEditor new openOnClass: self andSelector: #cursorHandMask"	&lt;resource: #image&gt;	^(Image extent: 16@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 13 176 0 0 31 252 0 0 31 254 0 0 15 254 0 0 31 254 0 0 63 254 0 0 63 252 0 0 31 252 0 0 15 248 0 0 7 248 0 0 7 248 0 0 0 0 0 0])</body><body package="QuickMap">earth16x16	"Tools.UIMaskEditor new openOnClass: self andSelector: #earth16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 8 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3790 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3597 3918 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3854 4079 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2987 3276 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4882 4946 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 3597 4753)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4850 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 4143 4432)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 4111 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7066 7066 7066)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3854 4079 4657)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2826 3115 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3115 3404 4753)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 2987 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7291 7291 7291)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4625 5171)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5846 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2505 3115 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 6520 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3918 5492)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4561 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 3340 5653)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2569 3244 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6745 6745 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 4111 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 4079 4625)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 3019 4657)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2473 2923 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 6970 6970)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5781 5814 6006)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4593 4689 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2601 3147 5235)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 3372 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2537 3147 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3308 3597 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 4143 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5685 5717 5878)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5685 5749 5846)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3372 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7195 7195 7195)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4432 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4432 4561 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6424 6424 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 3726 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3147 3726 5781)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3854 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5621 5621 5717)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 4207 5524)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2826 3115 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3147 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3180 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3629 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3597 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3693 5267)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3597 3886 4850)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6649 6649 6649)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2473 3212 5653)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 4368 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4561 4657 5107)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3051 3533 5428)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5717 5749 5846)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5685 5717 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2762 3115 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2794 3212 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2890 3244 4561)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2826 3276 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5010 5203 5781)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3790 4368)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3597 3790 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 5653 5685)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7098 7098 7098)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4400 4464 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3083 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6327 6327 6327)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4400 4657)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2762 3115 4175)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7323 7323 7323)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3661 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2890 3437 5717)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5267 5332 5749)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5749 5781 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 3340 4368)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2344 2826 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4818 4946 5267)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6103 6103 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3629 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3854 5364)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7098 7098 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3854 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2794 3147 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2473 2923 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4657 4818 5235)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 7002 7002)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6199 6327)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3115 3437 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 3501 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2858 3437 5781)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 3918 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2569 3372 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6906 6906)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 2858 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 7227 7227)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 3276 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4368 4529 5171)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6456 6456 6456)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2505 3019 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2987 3469 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5203 5235 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 4047 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6681 6681 6681)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4786 4850)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6199 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2890 3340 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3790 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 3469 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6906 6906 6906)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3276 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2826 3308 5653)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3147 3661 5974)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4047 4143 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7130 7130 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 3212 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 3180 5653)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 3437 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 3404 5107)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 3661 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3404 3726 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3983 4207 5267)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2890 3147 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2794 3115 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 3212 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7355 7355 7355)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3147 3469 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6584 6584 6584)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 4400 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5589 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3726 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4175 4272 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6906 6906 6938)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3212 3469 4143)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3212 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3565 3790 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6809 6809)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3983 4111 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3244 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2858 3372 5267)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 3597 4657)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6649 6681 6777)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 4079 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 7034 7066)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 7034 7034)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 2890 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 3180 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3115 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2987 3404 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 3276 5171)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 3693 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 5717 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7259 7259 7259)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 3308 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6809 6841)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3918 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2569 3083 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4882 4946 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6295 6327 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6713 6713)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3790 5364)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3822 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5878 5910 6038)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2537 2987 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6263 6263 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2473 3147 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3180 5364)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 3661 5267)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3854 4143 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 6938 6938)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4593 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2505 3147 5235)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2473 2987 5428)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3212 3469 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 3886 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4207 4561)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4079 4240 4561)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 7163 7163)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2890 3244 4432)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3244 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3661 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6392 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3597 3950 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 3950 4850)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2858 3147 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3051 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7387 7387 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4850 4946)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5428 5717)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4207 4336 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5717 5781 6038)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2794 3180 4946)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3212 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3340 3629 4946)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '.K"8!D6VTF O0;"8^YPI!K"8.IPA^6D?T'']OH5"+*;!9.I9BMD%/+4 &lt;RVA&lt;T[1G.JU6/;FL!"&lt;9.@I"HI6!.K!&gt;%R:RI#X;]WJYZ4Z&gt;@LGE1 &amp;T&amp;8-G2K]GM&lt;BT"22T E&gt;T*ZB8.CV6"3^''DD6-EE^C![5:.K!?FK19H 1Z (:"AIRP&amp;@NAZ$A''LU.5/B";S(*8OSBF/@VG^["()IQY[PZ3IFQ%M9PS1K"K_Z-CX8!GT42Q,%Q0+!$]WATKCZ)9.C([USN9QA&gt;ZQYN4W!Y,.IRTJ&lt;\%(8,-A8.\G''LH.K"K/IP)+AE1U *INBGB.K"8!H-G.IQ8PX42.$.K.D68.@@a'))</body><body package="QuickMap">earth16x16mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #earth16x16mask"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0])</body><body package="QuickMap">proxyCompleteMenu	"Tools.MenuEditor new openOnClass: self andSelector: #proxyMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Google app' 					#catalogID: #QuickTileProxyGapp ) 				#nameKey: #QuickTileProxyGapp 				#value: #QuickTileProxyGapp ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Open Cycle Map' 					#catalogID: #QuickTileProxyOCM ) 				#nameKey: #QuickTileProxyOCM 				#value: #QuickTileProxyOCM ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Google api v2' 					#catalogID: #QuickTileProxyGapiv2 ) 				#nameKey: #QuickTileProxyGapiv2 				#value: #QuickTileProxyGapiv2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Open Street Map' 					#catalogID: #QuickTileProxyOSM ) 				#nameKey: #QuickTileProxyOSM 				#value: #QuickTileProxyOSM ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Map Quest' 					#catalogID: #QuickTileProxyQuest1 ) 				#nameKey: #QuickTileProxyQuest1 				#value: #QuickTileProxyQuest1 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Thunderforest' 					#catalogID: #QuickTileProxyThunderforest ) 				#nameKey: #QuickTileProxyThunderforest 				#value: #QuickTileProxyThunderforest ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Hill Shading' 					#catalogID: #QuickTileProxyHillShading ) 				#nameKey: #QuickTileProxyHillShading 				#value: #QuickTileProxyHillShading ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Google api v3' 					#catalogID: #QuickTileProxyGapiv3 ) 				#nameKey: #QuickTileProxyGapiv3 				#value: #QuickTileProxyGapiv3 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Google sat' 					#catalogID: #QuickTileProxyGkhm ) 				#nameKey: #QuickTileProxyGkhm 				#value: #QuickTileProxyGkhm ) 			#(#{UI.MenuItem} 				#rawLabel: 'ArcGis' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Arcgis World Imagery' 								#catalogID: #QuickTileProxyArcgisWorldImagery ) 							#nameKey: #QuickTileProxyArcgisWorldImagery 							#value: #QuickTileProxyArcgisWorldImagery ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Arcgis World Hillshade' 								#catalogID: #QuickTileProxyArcgisWorldHillshade ) 							#nameKey: #QuickTileProxyArcgisWorldHillshade 							#value: #QuickTileProxyArcgisWorldHillshade ) ) #(2 ) nil ) ) ) #(10 ) nil ) decodeAsLiteralArray</body><body package="QuickMap">proxyMenu	"Tools.MenuEditor new openOnClass: self andSelector: #proxyMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Open Street Map' 					#catalogID: #QuickTileProxyOSM ) 				#nameKey: #QuickTileProxyOSM 				#value: #QuickTileProxyOSM ) 			#(#{UI.MenuItem} 				#rawLabel: 'WSN Maps' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Great Britain' 								#catalogID: #QuickTileProxyGreatBritain ) 							#nameKey: #QuickTileProxyBritain 							#value: #QuickTileProxyBritain ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'France' 								#catalogID: #QuickTileProxyFrance ) 							#nameKey: #QuickTileProxyFrance 							#value: #QuickTileProxyFrance ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Vietnam' 								#catalogID: #QuickTileProxyVietnam ) 							#nameKey: #QuickTileProxyVietnam 							#value: #QuickTileProxyVietnam ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Indonesia' 								#catalogID: #QuickTileProxyIndonesia ) 							#nameKey: #QuickTileProxyIndonesia 							#value: #QuickTileProxyIndonesia 							#indication: false ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Senegal' 								#catalogID: #QuickTileProxySenegal ) 							#nameKey: #QuickTileProxySenegal 							#value: #QuickTileProxySenegal 							#indication: false ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Madagascar' 								#catalogID: #QuickTileProxyMadagascar ) 							#nameKey: #QuickTileProxyMadagascar 							#value: #QuickTileProxyMadagascar ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Central America' 								#catalogID: #QuickTileProxyCentralAmerica ) 							#nameKey: #QuickTileProxyCentralAmerica 							#value: #QuickTileProxyCentralAmerica ) ) #(7 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Google api v3' 					#catalogID: #QuickTileProxyGapiv3 ) 				#nameKey: #QuickTileProxyGapiv3 				#value: #QuickTileProxyGapiv3 ) 			#(#{UI.MenuItem} 				#rawLabel: 'ArcGis' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Arcgis World Imagery' 								#catalogID: #QuickTileProxyArcgisWorldImagery ) 							#nameKey: #QuickTileProxyArcgisWorldImagery 							#value: #QuickTileProxyArcgisWorldImagery ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AMenuItem 								#defaultString: 'Arcgis World Hillshade' 								#catalogID: #QuickTileProxyArcgisWorldHillshade ) 							#nameKey: #QuickTileProxyArcgisWorldHillshade 							#value: #QuickTileProxyArcgisWorldHillshade ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'All these can fail:' ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Map Quest' 					#catalogID: #QuickTileProxyQuest1 ) 				#nameKey: #QuickTileProxyQuest1 				#value: #QuickTileProxyQuest1 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Thunderforest' 					#catalogID: #QuickTileProxyThunderforest ) 				#nameKey: #QuickTileProxyThunderforest 				#value: #QuickTileProxyThunderforest ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AMenuItem 					#defaultString: 'Hill Shading' 					#catalogID: #QuickTileProxyHillShading ) 				#nameKey: #QuickTileProxyHillShading 				#value: #QuickTileProxyHillShading ) ) #(4 4 ) nil ) decodeAsLiteralArray</body><body package="QuickMap">satellite16x16	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 6552 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6167 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 3822 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1092 1092 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4914 8191)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[102 102 102 136 136 102 6 102 102 102 88 102 102 0 160 102 6 102 134 98 34 32 74 6 96 102 134 34 34 32 164 160 102 6 135 34 34 16 74 6 102 96 134 113 17 32 160 102 102 102 134 34 119 32 6 102 102 102 131 34 119 80 102 102 102 102 6 85 136 32 102 102 102 96 160 34 119 32 102 102 102 10 74 2 119 32 102 102 96 148 164 160 119 32 102 102 9 74 74 7 119 32 102 102 96 164 160 119 119 32 102 102 102 10 0 34 119 1 102 102 102 96 102 0 0 102 102 102])</body><body package="QuickMap">satellite16x16mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite16x16mask"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 200 0 0 15 252 0 0 143 254 0 0 79 255 0 0 47 254 0 0 31 252 0 0 15 248 0 0 15 240 0 0 15 240 0 0 31 240 0 0 63 240 0 0 127 240 0 0 255 240 0 0 127 240 0 0 63 240 0 0 19 192 0 0])</body><body package="QuickMap">satellite32x17	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite32x17"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@17 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 4914 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 1638 3276)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 3276 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(546 546 546)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 2730 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 3276 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 4914 3276)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 6552 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 3276 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3,@L3L3L3L3L3L3L3L3L3@H"KL3L3L4ICL3L3L3L0B8#L2@L3L4H!H$L3L3L3LH"63L2K,4HRH"P3L3L3L3BE.&amp;.&lt;2@H"HRP3L3L3L3L0!ER8"&lt;2@H"P3L3L3L3L3LHTX!X L\BP3L3L3L3L3L3BBTU%U H@3L3L3L3L3L3L2H"IEQXA0L3L3L3L3L3L4H$H"IDV@\CL3L3L3L3L4H$P$H"UE G@3L3L3L3L4H)QBP".HUWA0L3L3L3L4H$QIP$L3B8]0\CL3L3L3H)H"H$L3L3LK\G@3L3L3L"H)H$L3L3L3L0@CL3L3L3L"H"L3L3L3L3L3L3L3L3L3L$P3L3L3L3L3L3L3L3L3Lb'))</body><body package="QuickMap">satellite32x17mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite32x17mask"	&lt;resource: #image&gt;	^(Image extent: 32@17 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 1 192 0 0 7 224 28 0 63 240 127 0 63 253 254 0 63 255 248 0 63 255 224 0 63 255 128 0 63 254 0 0 63 254 0 0 255 254 0 3 255 254 0 15 255 254 0 63 241 254 0 127 192 126 0 255 0 28 0 124 0 0 0 56 0 0 0])</body><body package="QuickMap">satellite32x21	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite32x21"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@21 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 770 1573)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 3180 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 5300 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2890 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 2890 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4240 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1316 1573)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 256)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2633 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 770 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4240 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 5557 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 6617 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7934 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 4240 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1573 1060 2376)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(513 513 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2890 2376 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 4497 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(513 256 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 3950 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5010 5814 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4497 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(770 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 1830 2890)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 6360 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 5300 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2633 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1573 1060 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 4753 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(256 256 256)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1573 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(513 513 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2376 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6360 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5557 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 2890 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(256 256 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(770 770 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 6070 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6070 5814 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(256 256 513)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2633 2633 2633)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@F0@B@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@DA@PH@@B@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @@DRHPDA@P@@HB@ HB@ HB@ @@@@HB@ HB@ HB@ @@F1@PB!@PDA@S@@HB@ HB@ H@D!HG@@HB@ HB@ @@BA,PDA@DHA@PF0@@@ HB@ HB@ @!@AHR@@HB@ H@F1@ BA@PDA,(F0@@@ HB@ HB@ HB@ @RD!H@@ HB@A8PDA@JDA@PD@@@@ HB@ HB@ HB@ H@@ @@D#P@MPHZBQ,PD@TQD@@@@ HB@ HB@ HB@ HB@ HB@ HOA!T$@@D@CA@PL @@@ HB@ HB@ HB@ HB@ HB@ @@@",3B1PKFB(.L @@@ HB@ HB@ HB@ HB@ HB@ @@DA@@KA0NE@8UI1T@@ HB@ HB@ HB@ HB@ HB@ @@DA@P@CT@E!X@IBP-@ HB@ HB@ HB@ HB@ HB@ @@DA\PDA@W@@4VE!X_F@XB@ HB@ HB@ HB@ HB@!\@DA\PD@(PDA@@MPLVH3@%@@DB@ HB@ HB@ HB@ HBE1@PB!@PDCDP@@@B@ @YD!HRLQ4B@ HB@ HB@ HB@ H@DA@P@A@P@@@B@ HB@!\GD!HRC@HB@ HB@ HB@ HB@ @PDA@&amp;@@@B@ HB@ HBE2&lt;@D!H1@ HB@ HB@ HB@ HB@ @P@@@B@ HB@ HB@ HBB!HRD @B@ HB@ HB@ HB@ HB@ @B@ HB@ HB@ HB@ @WD"&lt;@@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ H@@@HB@ HB@ HB@ HB@ HB'))</body><body package="QuickMap">satellite32x21mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite32x21mask"	&lt;resource: #image&gt;	^(Image extent: 32@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 12 0 0 0 60 0 0 0 254 0 0 3 254 0 224 15 255 1 240 63 255 1 248 127 252 0 248 255 240 1 126 255 192 0 31 255 0 0 223 252 0 3 255 240 0 15 255 192 0 63 255 192 0 255 255 224 0 255 231 240 0 255 131 240 0 254 3 240 0 120 1 240 0 32 3 224 0 0 0 192 0])</body><body package="QuickMap">satellite32x32	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite32x32"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 9 bitsPerPixel: 16 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(674 674 674)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5332 5075 5749)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5107 4786 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1573 1573 1573)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1349 1349 1349)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1798 1798 1798)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1766 1413 2216)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1734 1477 2184)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2023 2023 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 2184 2794)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 2698 2698)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3147 3147 3147)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3372 3372)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 3822 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 3790 3854)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4047 4047 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4047 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4721 4721 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5171 5171 5171)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5364 5043 5781)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(642 353 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5621 5621 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5621 5557 5685)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5589 5300 5974)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6263 6038 6584)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 6520 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1991 1734 2376)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 1638 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 6970 6970)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7869 7869 7869)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 8094 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 3822 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5364 5075 5781)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5589 5300 6006)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 5814 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6070 6038 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1734 1252 2473)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3790 3501 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 3822 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4079 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 4593 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(706 706 706)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5364 5075 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(931 931 931)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5621 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1349 1092 1702)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1381 1381 1381)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1606 1606 1606)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1830 1830 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2505 2505 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3115 2633 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3404 3404 3404)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3308 2890 4015)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3565 3244 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4079 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 4593 5428)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5428 5428 5428)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1124 867 1509)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5878 5878 5878)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6295 6103 6584)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6327 6295 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 6552 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6777 6777 6777)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1766 1509 2248)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 7002 7002)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1830 1830 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 7195 7259)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7195 7066 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 2858 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7901 7901 7901)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 8126 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3565 3147 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 3629 4625)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4721 4336 5235)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4978 4978 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 4625 5428)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5171 4850 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5878 5846 5942)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6070 5846 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 3854 4850)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(289 289 289)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(738 738 738)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5107 5846)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1413 1413 1413)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1766 1188 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2087 2087 2087)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6777 6584 7034)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 1863 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2987 2987 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3597 3147 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4336 4336 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4529 4111 5043)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5685 5621 5749)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 5364 6038)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5878 5621 6231)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6135 6135 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6327 6103 6649)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6584 6584 6584)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6809 6809)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6360 6360 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 7034 7034)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7259 7259 7259)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7484 7484 7484)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 2794 3244)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 8158 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 2923 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 3404 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 3886 4850)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4529 4143 5043)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5203 4882 5653)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1606 1284 2087)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2312 2152 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 6841 7259)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2248 1863 2890)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 2537 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 7612 7837)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3340 3597)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4400 5267)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4561 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(321 321 321)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(995 995 995)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1124 610 1927)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1445 1445 1445)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1606 1381 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6584 6360 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6617 7066)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2569 2569 2569)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2762 2537 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 3244 3244)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 3469 3469)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3854 3437 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4079 3661 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4143 4143 4143)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4368 4368 4368)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 3918 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5267 5267 5267)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5685 5396 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5942 5942 5942)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5910 5653 6263)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6167 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1830 1252 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6360 6199 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 6841 6841)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6392 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 6874 7291)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7291 7291 7291)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7516 7516 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 7612 7869)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 7741 7741)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2987 2890 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7966 7966 7966)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3404 2955 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 3886 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2698 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4561 4175 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5171 5878)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1220 1092 1413)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6135 6006 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6424 6841)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7066 6874 7291)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7291 7130 7484)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2505 1991 3276)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 2730 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3083 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 3308 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3629 3212 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4432 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5010 4689 5492)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(578 578 578)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1252 1252 1252)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 6649 7098)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2376 2376 2376)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2826 2826 2826)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 2826 3308)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 2666 3469)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3212 2730 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3726 3726 3726)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4175 4175 4175)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3886 3469 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4625 4625)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4561 4207 5107)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(578 513 674)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5524 5524 5524)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5492 5171 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5749 5749 5749)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5075 5075 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5942 5685 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6199 6199 6199)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 1927 2441)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7548 7548 7548)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2826 2666 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7773 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3661 3244 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 3726 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4593 4207 5107)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(160 128 160)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(353 256 513)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(546 385 867)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5717 5460 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 1027 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6424 6424 6456)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1895 1638 2312)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7098 6906 7323)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2569 2441 2858)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2601 2409 2858)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7677 7901)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4143 3726 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(835 835 835)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 674 1991)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1509 1509 1509)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6424 6199 6713)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 1060 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2312 1798 3115)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 2409 2409)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2601 2376 2923)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3083 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7677 7901)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3051 2890 3308)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3533 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 3758 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 3501 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3983 3983 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4143 3758 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4657 4657 4657)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4882 4882 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6231 6199 6263)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6199 5974 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6424 6199 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7130 7130 7130)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7355 7355 7355)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7580 7580 7580)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 8030 8030)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 3019 4143)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4240 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 4497 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5749 5492 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5974 5749 6327)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6231 6199 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7130 6970 7323)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 2794 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 7998 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4175 3758 4753)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4047 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(192 192 192)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 4497 5364)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5075 4753 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1316 1316)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1766 1734 1798)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 2441 2441)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 2666 2666)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3115 3115 3115)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7612 7580 7612)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3340 3340 3340)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 7998 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3404 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3790 3790 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4464 4464)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4689 4689 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(192 128 289)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(385 192 706)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5139 5139 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5589 5589 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1124 1092 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5814 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6006 5749 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6263 6263 6263)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6231 6006 6552)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6713 6713)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 6938 6938)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7387 7387 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 7163 7163)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2858 2698 3147)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7612 7612 7612)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7837 7837 7837)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2601 2087 3340)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 8062 8062)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 7998 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4047 3918 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4432 4015 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 1702 2376)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 6745 7163)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 2248 2698)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2601 2087 3372)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7387 7387 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3340 3180 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3083 4175)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 3918 4175)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4657 4304 5171)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@H(@9PB[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@D @CP@M@D @&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,AE0CZ@D0@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0A%@O8@X B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@AT@5 CA@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@F,@C0@H@D\@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@Q0@1@@,@Q B[@I,@&amp;0B[@I,@Q0DR@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0CA@ET@WPB[@I,@&amp;0B[@I,@&amp;0DN@J&lt;AD B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@C,@T0DL@I,@&amp;0B[@I,@&amp;0C,@M0@8@AF@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@WP@+@C8@&amp;0B[@I,@&amp;0B[@K(@? A"@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@Q B0@MX@:0B[@I,@&amp;0B[@RH@B BC@D\@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0DU@MX@LPDX@I,@&amp;0B[@I,@" B-@AT@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@BL@JP@N@F,@&amp;0B[@I,AEP@1@CDAH B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@:0B7@I,@&amp;0B[@I,@9@CH@C(@P@CN@QX@E AL@G,@/PB[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@0PDA@K@@Y@B[@I,AEPC&gt;@O(@A B3@LX@''0@&lt;@CTAB C''@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@H0@1@K@@$PB[@I,@&amp;0DT@O8ACPBB@I(@1PA[@CP@RPBP@JD@_ AC@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@A8@NPC&gt;@@,@0PB[@I,@&amp;0B[@I,@\ CC@BT@I C0@OD@&gt;0CG@NL@[@@A@B0@0@B[@I,@&amp;0B[@I,@&amp;0B[@DX@DPB-@@0AEPB[@I,@&amp;0B[@I,@&amp;0@"@BP@8PA^@O0@E0B&gt;@P&lt;@20AN@A@@[@AT@GT@W0B[@I,@&amp;0B[@RH@''@@+@M&lt;AE@B[@I,@&amp;0B[@I,@&amp;0B[@I,AH0D$@Q4@?@C2@M\AG0C5@H@@T@AN@ML@L D&amp;@F(@&amp;0B[@LDA@0@@@@4AH B[@I,@&amp;0B[@I,@&amp;0B[@F,@X @^@@$@1 A8@I&lt;ADPA3@MHAA@A6@E @"0B8@OX@!P@G@L4@LPB,@@&lt;@;@B[@I,@&amp;0B[@I,@&amp;0B[@IH@!@C?@P @Q C[@ED@SPA @N$@)@D[@I,@=0B#@FD@R0BZ@A,@2PAS@CX@Q0B[@I,@&amp;0B[@I,@&amp;0BR@PX@? B4@ID@&amp;0B[@I,@,PBI@C @HPA#@L&lt;@7PDD@IX@+ A9@R@@.PDI@J@@GPB[@I,@&amp;0B[@I,@O0B\@G4@V @;@F,@&amp;0B[@I,@&amp;0B[@RT@G0B*@B(@&lt;0A?@IL@Q@B"@Q0@&gt; C:@B4@#0C^@I,@&amp;0B[@LD@C0B-@@ @/PAG@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0@=@J\@[0B+@K,@#PC(@A @&gt;PB\@DT@, CY@MT@S0C*@E4@5 DM@@&lt;AEPB[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0A7@LX@'' @(@G@@H@@S@@H@10A-@Q$@6@CJ@DH@+@@3@FX@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,A@ CP@KX@[ @7@I8@I0C8@J$@)PCL@AP@LPC&amp;@DX@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,AE0BX@GP@) BZ@I4AHPAV@G0@4PD"@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0C4@PT@F A1@Q8@*@@#@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,@&amp;0B[@I,b'))</body><body package="QuickMap">satellite32x32mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #satellite32x32mask"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 12 0 0 0 60 0 0 0 112 0 0 0 224 0 0 1 192 0 0 7 128 0 0 15 6 0 0 28 14 0 0 56 60 0 0 112 112 0 1 225 224 0 3 195 128 0 7 143 0 3 15 252 0 15 63 248 0 60 127 252 1 240 127 252 7 192 255 254 31 0 255 254 124 7 255 255 240 31 255 255 192 248 255 255 7 224 255 254 63 0 255 255 248 0 127 255 192 0 127 255 0 0 63 248 0 0 15 224 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>UIKnownUrls class</class-id> <category>resources</category><body package="PickCell">menuNoms	"Tools.MenuEditor new openOnClass: self andSelector: #menuNoms"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'save file' 							#value: #doSaveFile ) 						#(#{UI.MenuItem} 							#rawLabel: 'load file' 							#value: #doLoadFile ) 						#(#{UI.MenuItem} 							#rawLabel: 'quit' 							#value: #doQuit ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Edit' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'delete' 							#value: #doDelete ) 						#(#{UI.MenuItem} 							#rawLabel: 'add' 							#value: #doAdd ) ) #(2 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UIKnownUrls class</class-id> <category>interface specs</category><body package="PickCell">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Known Urls' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1078 617 1480 822 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.365672 0 0.0243902 0 0.975124 0 0.687805 ) 					#name: #List1 					#flags: 12 					#model: #laListe 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0.0243902 0 0.355721 0 0.687805 ) 					#name: #List2 					#model: #lesNoms 					#menu: #menuNoms 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0124378 0 0.736585 0 0.350746 0 0.829268 ) 					#name: #InputField1 					#model: #leShortName ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.375622 0 0.736585 0 0.965174 0 0.829268 ) 					#name: #InputField2 					#model: #leUrl ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0124378 0 0.858537 0 0.166667 0 0.946341 ) 					#name: #SaveButton 					#model: #doQuit 					#label: 'Ok' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.201493 0 0.809756 0 0.355721 0 0.946341 ) 					#name: #ActionButton2 					#model: #doCancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UIMapAccess class</class-id> <category>interface specs</category><body package="MapAccess">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Display Map Access' 			#min: #(#{Core.Point} 592 412 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 934 415 1920 1201 ) 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 42 ) 					#name: #LabelLongitude 					#label: 'lon' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 50 44 150 65 ) 					#name: #Longitude 					#model: #longitude 					#type: #number 					#formatString: '0.0000000' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 72 ) 					#name: #LabelLatitude 					#label: 'lat' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 50 72 150 93 ) 					#name: #Latitude 					#model: #latitude 					#type: #number 					#formatString: '0.0000000' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.Rectangle} 11 98 154 102 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 14 112 ) 					#name: #LabelXTile 					#label: 'xTile' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 48 109 148 130 ) 					#name: #XTile 					#model: #xTile 					#type: #number 					#formatString: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 14 140 ) 					#name: #LabelYTile 					#label: 'yTile' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 48 140 148 161 ) 					#name: #YTile 					#model: #yTile 					#type: #number 					#formatString: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 14 170 ) 					#name: #LabelZoom 					#label: 'zoom' ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 50 169 150 190 ) 					#name: #Zoom 					#model: #zoom 					#helpText: 'Values are between 0 and 21' 					#isReadOnly: false 					#type: #number 					#formatString: '0' 					#low: 0 					#high: 21 ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 205 0 23 0 -24 1 -22 1 ) 					#name: #TileViewHolder 					#component: #tileView ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 42 196 152 233 ) 					#name: #Refresh 					#model: #doUpdateTile 					#label: 'Refresh map' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 42 235 152 272 ) 					#name: #Reset 					#model: #doReset 					#label: 'Reset values' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 42 274 152 311 ) 					#name: #Inspect 					#model: #inspect 					#helpText: 'Open inpect window' 					#label: 'Inspect it...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 42 313 152 350 ) 					#name: #Close 					#model: #doQuit 					#label: 'Close window' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 203 0 -3 0 -21 1 26 0 ) 					#name: #MoveNorth 					#model: #doMoveNorth 					#label: '^' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -27 1 19 0 0 1.00537 -20 1 ) 					#name: #MoveEast 					#model: #doMoveEast 					#label: '&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 205 0 -22 1 -22 1 0 1 ) 					#name: #MoveSouth 					#model: #doMoveSouth 					#label: 'v' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 20 0 208 0 -19 1 ) 					#name: #MoveWest 					#model: #doMoveWest 					#label: '&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 177 -3 209 26 ) 					#name: #MoveNW 					#model: #doMoveNW 					#label: '.' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -26 1 -3 0 0 1.00537 26 0 ) 					#name: #MoveNE 					#model: #doMoveNE 					#label: '.' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -22 1 -23 1 0 1.00134 0 1.0 ) 					#name: #MoveSE 					#model: #doMoveSE 					#label: '.' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 180 0 -22 1 206 0 0 1.0 ) 					#name: #MoveSW 					#model: #doMoveSW 					#label: '.' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 42 388 152 425 ) 					#name: #ActionButton1 					#model: #doOpenShapefile 					#label: 'Open shapefile...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 42 436 152 473 ) 					#name: #ActionButton2 					#model: #doOpenTileCacheConfig 					#label: 'Cache control...' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 50 7 129 30 ) 					#name: #InputEchelle 					#model: #echelle 					#alignment: #right 					#type: #number 					#formatString: '#,##0.000' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 10 ) 					#name: #Label1 					#label: 'Echelle' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 131 9 ) 					#name: #Label2 					#label: 'm / pixel' ) ) ) )</body></methods><methods><class-id>UITextPoints class</class-id> <category>interface specs</category><body package="PickCell">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Points' 			#bounds: #(#{Graphics.Rectangle} 761 371 1390 991 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 3 0 613 0 588 0 ) 					#name: #TextEditor1 					#model: #leTexte 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>UITextPoints class</class-id> <category>resources</category><body package="PickCell">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Save on File' 							#value: #doSave ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save as shape file' 							#value: #doSaveShapeFile ) 						#(#{UI.MenuItem} 							#rawLabel: 'Process  on URL' 							#value: #doSaveURL ) 						#(#{UI.MenuItem} 							#rawLabel: 'Load file' 							#value: #doLoad ) 						#(#{UI.MenuItem} 							#rawLabel: 'Analyze' 							#value: #doAnalyze ) 						#(#{UI.MenuItem} 							#rawLabel: 'Store in DB' 							#value: #storeInDB ) ) #(6 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>USBSerial</class-id> <category>defines</category><body package="PickCell">B0	&lt;C: #define B0 0	&gt;</body><body package="PickCell">B1000000	&lt;C: #define B1000000 4104	&gt;</body><body package="PickCell">B110	&lt;C: #define B110 3	&gt;</body><body package="PickCell">B115200	&lt;C: #define B115200 4098	&gt;</body><body package="PickCell">B1152000	&lt;C: #define B1152000 4105	&gt;</body><body package="PickCell">B1200	&lt;C: #define B1200 9	&gt;</body><body package="PickCell">B134	&lt;C: #define B134 4	&gt;</body><body package="PickCell">B150	&lt;C: #define B150 5	&gt;</body><body package="PickCell">B1500000	&lt;C: #define B1500000 4106	&gt;</body><body package="PickCell">B1800	&lt;C: #define B1800 10	&gt;</body><body package="PickCell">B19200	&lt;C: #define B19200 14	&gt;</body><body package="PickCell">B200	&lt;C: #define B200 6	&gt;</body><body package="PickCell">B2000000	&lt;C: #define B2000000 4107	&gt;</body><body package="PickCell">B230400	&lt;C: #define B230400 4099	&gt;</body><body package="PickCell">B2400	&lt;C: #define B2400 11	&gt;</body><body package="PickCell">B2500000	&lt;C: #define B2500000 4108	&gt;</body><body package="PickCell">B300	&lt;C: #define B300 7	&gt;</body><body package="PickCell">B3000000	&lt;C: #define B3000000 4109	&gt;</body><body package="PickCell">B3500000	&lt;C: #define B3500000 4110	&gt;</body><body package="PickCell">B38400	&lt;C: #define B38400 15	&gt;</body><body package="PickCell">B4000000	&lt;C: #define B4000000 4111	&gt;</body><body package="PickCell">B460800	&lt;C: #define B460800 4100	&gt;</body><body package="PickCell">B4800	&lt;C: #define B4800 12	&gt;</body><body package="PickCell">B50	&lt;C: #define B50 1	&gt;</body><body package="PickCell">B500000	&lt;C: #define B500000 4101	&gt;</body><body package="PickCell">B57600	&lt;C: #define B57600 4097	&gt;</body><body package="PickCell">B576000	&lt;C: #define B576000 4102	&gt;</body><body package="PickCell">B600	&lt;C: #define B600 8	&gt;</body><body package="PickCell">B75	&lt;C: #define B75 2	&gt;</body><body package="PickCell">B921600	&lt;C: #define B921600 4103	&gt;</body><body package="PickCell">B9600	&lt;C: #define B9600 13	&gt;</body><body package="PickCell">BRKINT	&lt;C: #define BRKINT 2	&gt;</body><body package="PickCell">CLOCAL	&lt;C: #define CLOCAL 2048	&gt;</body><body package="PickCell">CREAD	&lt;C: #define CREAD 128	&gt;</body><body package="PickCell">CS5	&lt;C: #define CS5 0	&gt;</body><body package="PickCell">CS6	&lt;C: #define CS6 16	&gt;</body><body package="PickCell">CS7	&lt;C: #define CS7 32	&gt;</body><body package="PickCell">CS8	&lt;C: #define CS8 48	&gt;</body><body package="PickCell">CSIZE	&lt;C: #define CSIZE 48	&gt;</body><body package="PickCell">CSTOPB	&lt;C: #define CSTOPB 64	&gt;</body><body package="PickCell">ECHO	&lt;C: #define ECHO 8	&gt;</body><body package="PickCell">ECHOE	&lt;C: #define ECHOE 16	&gt;</body><body package="PickCell">ECHOK	&lt;C: #define ECHOK 32	&gt;</body><body package="PickCell">ECHONL	&lt;C: #define ECHONL 64	&gt;</body><body package="PickCell">HUPCL	&lt;C: #define HUPCL 1024	&gt;</body><body package="PickCell">ICANON	&lt;C: #define ICANON 2	&gt;</body><body package="PickCell">ICRNL	&lt;C: #define ICRNL 256	&gt;</body><body package="PickCell">IEXTEN	&lt;C: #define IEXTEN 32768	&gt;</body><body package="PickCell">IGNBRK	&lt;C: #define IGNBRK 1	&gt;</body><body package="PickCell">IGNCR	&lt;C: #define IGNCR 128	&gt;</body><body package="PickCell">IGNPAR	&lt;C: #define IGNPAR 4	&gt;</body><body package="PickCell">IMAXBEL	&lt;C: #define IMAXBEL 8192	&gt;</body><body package="PickCell">INLCR	&lt;C: #define INLCR 64	&gt;</body><body package="PickCell">INPCK	&lt;C: #define INPCK 16	&gt;</body><body package="PickCell">ISIG	&lt;C: #define ISIG 1	&gt;</body><body package="PickCell">ISTRIP	&lt;C: #define ISTRIP 32	&gt;</body><body package="PickCell">IUCLC	&lt;C: #define IUCLC 512	&gt;</body><body package="PickCell">IUTF8	&lt;C: #define IUTF8 16384	&gt;</body><body package="PickCell">IXANY	&lt;C: #define IXANY 2048	&gt;</body><body package="PickCell">IXOFF	&lt;C: #define IXOFF 4096	&gt;</body><body package="PickCell">IXON	&lt;C: #define IXON 1024	&gt;</body><body package="PickCell">NCCS	&lt;C: #define NCCS 32	&gt;</body><body package="PickCell">NOFLSH	&lt;C: #define NOFLSH 128	&gt;</body><body package="PickCell">OCRNL	&lt;C: #define OCRNL 8	&gt;</body><body package="PickCell">OFDEL	&lt;C: #define OFDEL 128	&gt;</body><body package="PickCell">OFILL	&lt;C: #define OFILL 64	&gt;</body><body package="PickCell">OLCUC	&lt;C: #define OLCUC 2	&gt;</body><body package="PickCell">ONLCR	&lt;C: #define ONLCR 4	&gt;</body><body package="PickCell">ONLRET	&lt;C: #define ONLRET 32	&gt;</body><body package="PickCell">ONOCR	&lt;C: #define ONOCR 16	&gt;</body><body package="PickCell">OPOST	&lt;C: #define OPOST 1	&gt;</body><body package="PickCell">PARENB	&lt;C: #define PARENB 256	&gt;</body><body package="PickCell">PARMRK	&lt;C: #define PARMRK 8	&gt;</body><body package="PickCell">PARODD	&lt;C: #define PARODD 512	&gt;</body><body package="PickCell">TCIFLUSH	&lt;C: #define TCIFLUSH 0	&gt;</body><body package="PickCell">TCIOFF	&lt;C: #define TCIOFF 2	&gt;</body><body package="PickCell">TCIOFLUSH	&lt;C: #define TCIOFLUSH 2	&gt;</body><body package="PickCell">TCION	&lt;C: #define TCION 3	&gt;</body><body package="PickCell">TCOFLUSH	&lt;C: #define TCOFLUSH 1	&gt;</body><body package="PickCell">TCOOFF	&lt;C: #define TCOOFF 0	&gt;</body><body package="PickCell">TCOON	&lt;C: #define TCOON 1	&gt;</body><body package="PickCell">TCSADRAIN	&lt;C: #define TCSADRAIN 1	&gt;</body><body package="PickCell">TCSAFLUSH	&lt;C: #define TCSAFLUSH 2	&gt;</body><body package="PickCell">TCSANOW	&lt;C: #define TCSANOW 0	&gt;</body><body package="PickCell">TOSTOP	&lt;C: #define TOSTOP 256	&gt;</body><body package="PickCell">VDISCARD	&lt;C: #define VDISCARD 13	&gt;</body><body package="PickCell">VEOF	&lt;C: #define VEOF 4	&gt;</body><body package="PickCell">VEOL	&lt;C: #define VEOL 11	&gt;</body><body package="PickCell">VEOL2	&lt;C: #define VEOL2 16	&gt;</body><body package="PickCell">VERASE	&lt;C: #define VERASE 2	&gt;</body><body package="PickCell">VINTR	&lt;C: #define VINTR 0	&gt;</body><body package="PickCell">VKILL	&lt;C: #define VKILL 3	&gt;</body><body package="PickCell">VLNEXT	&lt;C: #define VLNEXT 15	&gt;</body><body package="PickCell">VMIN	&lt;C: #define VMIN 6	&gt;</body><body package="PickCell">VQUIT	&lt;C: #define VQUIT 1	&gt;</body><body package="PickCell">VREPRINT	&lt;C: #define VREPRINT 12	&gt;</body><body package="PickCell">VSTART	&lt;C: #define VSTART 8	&gt;</body><body package="PickCell">VSTOP	&lt;C: #define VSTOP 9	&gt;</body><body package="PickCell">VSUSP	&lt;C: #define VSUSP 10	&gt;</body><body package="PickCell">VSWTC	&lt;C: #define VSWTC 7	&gt;</body><body package="PickCell">VT0	&lt;C: #define VT0 0	&gt;</body><body package="PickCell">VT1	&lt;C: #define VT1 16384	&gt;</body><body package="PickCell">VTDLY	&lt;C: #define VTDLY 16384	&gt;</body><body package="PickCell">VTIME	&lt;C: #define VTIME 5	&gt;</body><body package="PickCell">VWERASE	&lt;C: #define VWERASE 14	&gt;</body><body package="PickCell">_HAVE_STRUCT_TERMIOS_C_ISPEED	&lt;C: #define _HAVE_STRUCT_TERMIOS_C_ISPEED 1	&gt;</body><body package="PickCell">_HAVE_STRUCT_TERMIOS_C_OSPEED	&lt;C: #define _HAVE_STRUCT_TERMIOS_C_OSPEED 1	&gt;</body><body package="PickCell">_IOT_termios	&lt;C: #define _IOT_termios _IOT(_IOTS(cflag_t),4,_IOTS(cc_t),NCCS,_IOTS(speed_t),2)	&gt;</body><body package="PickCell">__DATE__	&lt;C: #define __DATE__ "May 12, 2017"	&gt;</body><body package="PickCell">__FILE__	&lt;C: #define __FILE__ /Users/monmac/Documents/SerialPort/usb.h	&gt;</body><body package="PickCell">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="PickCell">__MAX_BAUD	&lt;C: #define __MAX_BAUD B4000000	&gt;</body><body package="PickCell">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="PickCell">__TIME__	&lt;C: #define __TIME__ "11:12:13 AM"	&gt;</body></methods><methods><class-id>USBSerial</class-id> <category>variables</category><body package="PickCell">myMode	&lt;C: char * myMode&gt;</body><body package="PickCell">myMode: aValue	&lt;C: char * myMode&gt;</body></methods><methods><class-id>USBSerial</class-id> <category>structs</category><body package="PickCell">Char	&lt;C: struct Char {			char ch;		}&gt;</body><body package="PickCell">termios	&lt;C: struct termios {			tcflag_t c_iflag, c_oflag, c_cflag, c_lflag;			cc_t c_line;			cc_t c_cc[32];			speed_t c_ispeed, c_ospeed;		}&gt;</body></methods><methods><class-id>USBSerial</class-id> <category>types</category><body package="PickCell">cc_t	&lt;C: typedef unsigned char cc_t&gt;</body><body package="PickCell">speed_t	&lt;C: typedef unsigned int speed_t&gt;</body><body package="PickCell">tcflag_t	&lt;C: typedef unsigned int tcflag_t&gt;</body></methods><methods><class-id>QuickTileProxyArcgisWorldImagery class</class-id> <category>interface specs</category><body package="QuickMap">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 939 419 1724 1070 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0 1 0 56 0 30 0 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0 28 0 57 0 57 0 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0 55 0 57 0 84 0 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 54 0 0 0 0 1.0 0 1.0 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) ) ) )</body><body package="QuickMap">windowSpecChoose	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecChoose"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 300 212 980 812 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -2 1 56 30 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 28 57 57 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 55 57 84 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 87 53 113 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 54 0 0 0 0 1.0 0 1.0 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) ) ) )</body><body package="QuickMap">windowSpecConfig	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecConfig"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Configuration' 			#bounds: #(#{Graphics.Rectangle} 432 318 848 707 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 24 10 78 40 ) 					#name: #ActionButton1 					#model: #doMove 					#label: 'Move' 					#defaultable: true ) ) ) )</body><body package="QuickMap">windowSpecGpredict	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecGpredict"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 337 275 1017 875 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -2 1 56 30 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 28 57 57 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 55 57 84 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 87 53 113 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 0 0 0 1.00128 0 0.996705 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 119 57 148 ) 					#name: #ActionButton4 					#model: #doOpenGpredict 					#label: 'Gpredict' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 179 63 210 ) 					#name: #ActionButton5 					#model: #doBuildNet 					#label: 'Build net' 					#defaultable: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.Rectangle} 76 0 78 597 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 50 					#minBelowSize: 256 					#aboveWidgets: '#ActionButton1 #ActionButton2 #MenuButton1 #ActionButton3 #ActionButton4 #ActionButton5' 					#belowWidgets: '#ViewHolder1' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -3 208 80 241 ) 					#name: #ActionButton6 					#model: #doBuildGraph 					#label: 'Build graph' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 7 291 38 321 ) 					#name: #ActionButton7 					#model: #doSetSensorZone 					#label: #cursorCrossHair 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 6 261 39 295 ) 					#name: #ActionButton8 					#model: #doMoveMap 					#label: #cursorOpenHand 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 3 340 73 363 ) 					#name: #InputField1 					#model: #sensorsNumber 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 150 69 183 ) 					#name: #ActionButton9 					#model: #doOpenGpredictFileReader 					#label: 'GPredict2' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 410 76 436 ) 					#name: #ActionButton10 					#model: #doSatPathDuration 					#label: 'Satellite path' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 62 389 ) 					#name: #Label1 					#label: 'h' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 5 389 56 410 ) 					#name: #InputField2 					#model: #satPathDuration 					#type: #number 					#formatString: '#,##0.00' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 436 76 462 ) 					#name: #ActionButton11 					#model: #doDeleteNet 					#label: 'Delete net' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 473 71 510 ) 					#name: #ActionButton12 					#model: #doGetPath 					#label: 'Get path' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 2 538 74 562 ) 					#name: #InputField3 					#model: #pickModelRange 					#type: #number 					#formatString: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 517 ) 					#name: #Label2 					#label: 'Range (m):' ) ) ) )</body><body package="QuickMap">windowSpecMove	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecMove"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 669 343 1349 943 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8029 7609 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 14 0 68 0 32 0 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 45 0 69 0 63 0 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 72 0 69 0 90 0 ) 					#name: #ActionButton3 					#model: #doMove 					#label: 'Move' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 101 0 67 0 119 0 ) 					#name: #ActionButton4 					#model: #doStopMove 					#label: 'Stop' 					#defaultable: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 4 0 0 1.04396 0 1.00552 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#component: #quickTileMap ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 135 0 59 0 153 0 ) 					#name: #btnLoadMeteoData 					#model: #doLoadMeteoData 					#label: 'Load data' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 173 0 68 0 191 0 ) 					#name: #btnStation 					#model: #doShowStationsonMap 					#label: 'Load station' 					#defaultable: true ) ) ) )</body><body package="QuickMap">windowSpecPickcell	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecPickcell"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #positionSystemDefault #openType #advanced ) 			#label: 'QuickMap' 			#min: #(#{Core.Point} 953 681 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 521 228 1474 909 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00314795 0 0.352423 0 0.13851 0 0.51395 ) 					#name: #GroupBox1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 7167 ) ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00209864 0 0.602056 0 0.0472193 0 0.632893 ) 					#name: #RadioButton2 					#model: #leModeDesPoints 					#label: 'Line' 					#select: #isLine ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00314795 0 0.698972 0 0.141658 0 0.73862 ) 					#name: #ActionButton1 					#model: #doCopy 					#label: 'copy geopos' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.0409234 0 0.0602056 0 -0.0136411 0 0.0910426 ) 					#name: #ActionButton0 					#flags: 0 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00314795 0 0.737151 0 0.141658 0 0.776799 ) 					#name: #ActionButton6 					#model: #showSerie 					#label: 'Show points' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00104932 0 0.0939794 0 0.141658 0 0.133627 ) 					#name: #ActionButton2 					#model: #doDisplayCover 					#label: 'Display a cover' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00104932 0 0.146843 0 0.140609 0 0.18649 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00104932 0 0.199706 0 0.142707 0 0.239354 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00104932 0 0.25257 0 0.142707 0 0.292217 ) 					#name: #ActionButton4 					#model: #doOpenShapefile 					#label: 'Open shape' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00104932 0 0.305433 0 0.146905 0 0.345081 ) 					#name: #ActionButton5 					#model: #doOpenPickcell 					#label: 'PickCell...' 					#defaultable: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.156348 0 0.0 0 0.158447 0 0.998532 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 10 					#minBelowSize: 256 					#aboveWidgets: '#ActionButton0' 					#belowWidgets: '#ViewHolder1' ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.162644 0 0.00293686 0 0.983211 0 0.994126 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0125918 0 0.365639 0 0.0346275 0 0.387665 ) 					#name: #Label1 					#label: 'Lon' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00104932 0 0.403818 0 0.134313 0 0.443465 ) 					#name: #InputField1 					#model: #mouseLon 					#style: #small ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00104932 0 0.474302 0 0.134313 0 0.51395 ) 					#name: #InputField2 					#model: #mouseLat 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0125918 0 0.443465 0 0.0314795 0 0.465492 ) 					#name: #Label2 					#label: 'Lat' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00209864 0 0.565345 0 0.0493179 0 0.596182 ) 					#name: #RadioButton1 					#model: #leModeDesPoints 					#label: 'Path' 					#select: #isPath ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00209864 0 0.531571 0 0.0524659 0 0.562408 ) 					#name: #RadioButton3 					#model: #leModeDesPoints 					#label: 'Point' 					#select: #isPoint ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00314795 0 0.828194 0 0.141658 0 0.867841 ) 					#name: #ActionButton7 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00314795 0 0.781204 0 0.141658 0 0.820852 ) 					#name: #ActionButton8 					#model: #doSavePoints 					#label: 'Save points' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00209864 0 0.634361 0 0.0514166 0 0.665198 ) 					#name: #RadioButton4 					#model: #leModeDesPoints 					#label: 'Zone' 					#select: #isZone ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0524659 0 0.596182 0 0.132214 0 0.63583 ) 					#name: #InputField3 					#model: #leDiviseur 					#style: #small 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00104932 0 0.0381791 0 0.141658 0 0.0778267 ) 					#name: #ActionButton9 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) ) ) )</body><body package="QuickMap">windowSpecShapefile	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecShapefile"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'QuickMap' 			#min: #(#{Core.Point} 314 260 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 450 250 1130 850 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 0 50 14 ) 					#name: #ActionButton0 					#flags: 0 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 23 57 52 ) 					#name: #ActionButton1 					#model: #inspect 					#label: 'inspect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 50 57 79 ) 					#name: #ActionButton2 					#model: #doMoveBrest 					#label: 'Brest' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 77 57 106 ) 					#name: #ActionButton3 					#model: #doConfig 					#label: 'Config...' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 109 53 135 ) 					#name: #MenuButton1 					#model: #currentProxy 					#menu: #proxyMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} -1 137 57 166 ) 					#name: #ActionButton4 					#model: #doOpenShapefile 					#label: 'Open...' 					#defaultable: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.Rectangle} 51 0 53 599 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 10 					#minBelowSize: 256 					#aboveWidgets: '#ActionButton0' 					#belowWidgets: '#ViewHolder1' ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 54 0 0 0 0 1.0 0 1.0 ) 					#name: #ViewHolder1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7709 7613 7356 ) ) 					#component: #quickTileMap ) ) ) )</body></methods><methods><class-id>UILocation class</class-id> <category>resources</category><body package="PickCell">menuSnap	"Tools.MenuEditor new openOnClass: self andSelector: #menuSnap"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Snapshot' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'set delay' 							#value: #setDelay ) 						#(#{UI.MenuItem} 							#rawLabel: 'define origin' 							#value: #defineOrigin ) 						#(#{UI.MenuItem} 							#rawLabel: 'define corner' 							#value: #defineCorner ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Save file' 							#value: #saveFile ) 						#(#{UI.MenuItem} 							#rawLabel: 'send PickCell' 							#value: #sendToPickCell ) ) #(2 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UILocation class</class-id> <category>interface specs</category><body package="PickCell">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Location' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 621 283 1165 514 ) 			#flags: 4 			#menu: #menuSnap ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.659926 0 0.633663 0 0.985294 0 0.826733 ) 					#name: #GroupBox3 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0220588 0 0.346535 0 0.569853 0 0.663366 ) 					#name: #GroupBox2 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0220588 0 0.0247525 0 0.569853 0 0.346535 ) 					#name: #GroupBox1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.0459559 0 0.049505 0 0 ) 					#name: #Label1 					#label: 'x map' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.0459559 0 0.207921 0 0 ) 					#name: #Label2 					#label: 'y map' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.231618 0 0.0445545 0 0.556985 0 0.158416 ) 					#name: #InputField1 					#model: #leX ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.231618 0 0.207921 0 0.556985 0 0.321782 ) 					#name: #InputField2 					#model: #leY ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.0459559 0 0.386139 0 0 ) 					#name: #Label3 					#label: 'x map geo' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.0459559 0 0.509901 0 0 ) 					#name: #Label4 					#label: 'y map geo' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.231618 0 0.381188 0 0.556985 0 0.495049 ) 					#name: #InputField3 					#model: #leXGeo ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.231618 0 0.509901 0 0.556985 0 0.623762 ) 					#name: #InputField4 					#model: #leYGeo ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0275735 0 0.688119 0 0.615809 0 0.79703 ) 					#name: #PercentDoneBar1 					#isOpaque: true 					#model: #delayPerCent 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.597426 0 0.0285714 0 0 ) 					#name: #Label5 					#label: 'origin' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.704044 0 0.0445545 0 0.987132 0 0.158416 ) 					#name: #InputField5 					#model: #origine ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.597426 0 0.190476 0 0 ) 					#name: #Label6 					#label: 'corner' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.704044 0 0.188119 0 0.987132 0 0.30198 ) 					#name: #InputField6 					#model: #corner ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.674632 0 0.678218 0 0 ) 					#name: #RadioButton1 					#model: #coordinateMode 					#label: 'GPS' 					#select: #GPS ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.819853 0 0.673267 0 0 ) 					#name: #RadioButton2 					#model: #coordinateMode 					#label: 'Lambert' 					#select: #lambert ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.597426 0 0.509524 0 0 ) 					#name: #Label7 					#label: 'LoRa para' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.705882 0 0.490099 0 0.988971 0 0.60396 ) 					#name: #InputField7 					#model: #parameters ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.597426 0 0.347619 0 0 ) 					#name: #Label8 					#label: 'elevation' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.704044 0 0.331683 0 0.987132 0 0.445545 ) 					#name: #InputField8 					#model: #elevation ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="PickCell">toolsPickCell	"Open Smalltalk.AlgoDis.UIPickCellNodes."	&lt;	menuItem: 'Pick Cell'	nameKey: nil	menu: #(#menuBar #tools)	position: 12.96999&gt;	Smalltalk.AlgoDis.UIPickCellNodes open</body><body package="Mapsv0">toolsMapsv0	"Old  map display."	&lt;menuItem: 'Old UI Map'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.973&gt;	UIMapsv0 open</body><body package="MapAccess">toolsMapAccess	"Open UIMapAccess."	&lt;menuItem: 'Map Access'		nameKey: nil		menu: #(#menuBar #tools #Brest)		position: 12.975&gt;	UIMapAccess open</body><body package="MapAccess">toolsMapAccessSubmenu	"Define a sub-menu for each of the tools."	&lt;submenu: 'UniversitÃ© de Brest'		nameKey: #Brest		menu: #(#menuBar #tools)		position: 12.976&gt;</body><body package="QuickMap">toolsQuickMap	"Open UIQuickMap."	&lt;menuItem: 'Quick Map'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.9699&gt;	UIQuickMap open</body><body package="QuickMap">toolsQuickMapChoose	"Open UIQuickMap."	&lt;menuItem: 'Quick Map Choose'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.96992&gt;	UIQuickMap openChoose</body><body package="QuickMap">toolsQuickMapMove	"Open UIQuickMap."	&lt;menuItem: 'Quick Map Move'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.96991&gt;	UIQuickMap openMove</body><body package="QuickMap">toolsQuickMapPickcell	"Open UIQuickMap."	&lt;menuItem: 'Quick Map Pickcell'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.96996&gt;	UIQuickMap openWithSpec: #windowSpecPickcell</body><body package="QuickMap">toolsQuickMapReset	"Open UIQuickMap."	&lt;menuItem: 'Quick Map reset'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.96996&gt;	UIQuickMap resetConfig</body><body package="QuickMap">toolsQuickMapSatellite	"Open UIQuickMap."	&lt;menuItem: 'Quick Map Satellite'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.96994&gt;	UIQuickMap openWithSpec: #windowSpecGpredict</body><body package="QuickMap">toolsQuickMapShapefile	"Open UIQuickMap."	&lt;menuItem: 'Quick Map Shapefile'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.96993&gt;	UIQuickMap openWithSpec: #windowSpecShapefile</body></methods><methods><class-id>QuickTileProxy</class-id> <category>accessing</category><body package="QuickMap">client	^client isNil		ifFalse: [client]		ifTrue: 			[client := Net.HttpClient new.			client delaySeconds: self timeout ]</body><body package="QuickMap">container	^container</body><body package="QuickMap">container: anObject	container := anObject</body><body package="QuickMap">dicoZoom	^dicoZoom</body><body package="QuickMap">dicoZoom: anObject	dicoZoom := anObject</body><body package="QuickMap">timeout	^600</body><body package="QuickMap">x: xTile y: yTile zoom: zoom	| modulo x y dico |	modulo := 2 raisedTo: zoom.	x := xTile \\ modulo.	y := yTile \\ modulo.	dico := self dicoZoom at: zoom ifAbsentPut: [Dictionary new: 16].	^dico at: x @ y		ifAbsentPut: 			["| c s idx |"			"idx := self semIndex."			"c := clientArray at: index + 1.			s := semaphoreArray at: index + 1."			"c := clientArray at: idx first."			"s := semaphoreArray at: idx first."			index := (index + 1) \\ 22.			"(semaphoreArray collect: [:se | s excessSignals]) inspect."			(QuickTile x: x y: y zoom: zoom)				container: container;				"mapClient: c;"				"sema: s;"				index: index \\ 4;				"idx: idx;"				prx: self;				yourself]</body></methods><methods><class-id>QuickTileProxy</class-id> <category>private</category><body package="QuickMap">clientAt: anInteger	^clientArray at: anInteger</body><body package="QuickMap">emptyCache	dicoZoom := Dictionary new: self class maxZoom</body><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	^self subclassResponsibility</body><body package="QuickMap">pickCellDir	| homeDir baseDirName baseDir |	homeDir := SystemVariable named: 'HOME'.	baseDirName := homeDir value , '/.pickcell/cache/'.	baseDir := baseDirName asFilename.	baseDir ensureDirectory.	^baseDirName</body><body package="QuickMap">semIndex	"The first index of semaphore where the queue is shorter"	| minIndex minQueue |	minIndex := 1.	minQueue := (semaphoreArray at: minIndex) size.	semaphoreArray keysAndValuesDo: 			[:k :sem |			| s |			s := sem size.			s = 0				ifTrue: [^Array with: k with: 0]				ifFalse: 					[s &lt; minQueue						ifTrue: 							[minIndex := k.							minQueue := s]]].	^Array with: minIndex with: minQueue</body><body package="QuickMap">semIndexClient	"The first index of semaphore where the queue is shorter"	| minIndex minQueue |	minIndex := 1.	minQueue := (semaphoreArray at: minIndex) size.	semaphoreArray keysAndValuesDo: 			[:k :sem |			| s |			s := sem size.			s = 0				ifTrue: [^k]				ifFalse: 					[s &lt; minQueue						ifTrue: 							[minIndex := k.							minQueue := s]]].	^minIndex</body><body package="QuickMap">semaphoreAt: anInteger	^semaphoreArray at: anInteger</body></methods><methods><class-id>QuickTileProxy</class-id> <category>networking</category><body package="QuickMap">close	clientArray do: [:aClient | aClient close]</body><body package="QuickMap">disconnect	clientArray do: [:aClient | aClient disconnect]</body><body package="QuickMap">getPng: anIndex x: x y: y zoom: zoom	| httpResponse imageStream url qhr idxc cli sem |	idxc := self semIndexClient.	cli := self clientAt: idxc.	cli delaySeconds:120.	sem := self semaphoreAt: idxc.	url := self				getUri: anIndex				x: x				y: y				zoom: zoom.	qhr := QuickHttpRequest get: url.	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: cli.	sem critical: [httpResponse := qhr execute].	imageStream := httpResponse value byteSource.	^imageStream</body><body package="QuickMap">reset	clientArray := clientArray collect: 					[:aClient |					aClient close.					aClient disconnect.					Net.HttpClient new]</body></methods><methods><class-id>QuickTileProxy</class-id> <category>deprecated</category><body package="QuickMap">semNext	"semaphoreNext := semaphoreNext + 1 mod: 2.	^semaphoreArray at: (semaphoreNext + 1)"</body></methods><methods><class-id>QuickTileProxy</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	| n |	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	dicoZoom := Dictionary new: self class maxZoom.	n := self class maxSocket.	semaphoreArray := (Array new: n)				collect: [:s | Semaphore forMutualExclusion].	clientArray := (Array new: n) collect: [:c | Net.HttpClient new].	index := 0.	^self</body></methods><methods><class-id>QuickTileProxy class</class-id> <category>instance creation</category><body package="QuickMap">&lt;= aClass	^self name &lt;= aClass name</body><body package="QuickMap">friendlyName	^self subclassResponsibility</body><body package="QuickMap">googleApp	"Answer a newly created and initialized instance."	^super new initialize</body><body package="QuickMap">maxSocket	^self subclassResponsibility</body><body package="QuickMap">maxZoom	^self subclassResponsibility</body><body package="QuickMap">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyWSN</class-id> <category>private</category><body package="QuickMap">baseWsn	^'http://sames.univ-brest.fr'</body><body package="QuickMap">getUri1: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://tile.openstreetmap.org/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri2: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://tile.openstreetmap.fr/osmfr' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string := self baseWsn, '/osm_tiles/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>QuickTileProxyWSN</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyWSN class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	^'Open Street Map'</body><body package="QuickMap">maxSocket	^6</body><body package="QuickMap">maxZoom	^19</body></methods><methods><class-id>QuickTileProxyFrance</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string :=super baseWsn, '/osm_france/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>QuickTileProxyFrance</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>accessing</category><body package="PickCell">convertValue: aString	^aString asNumber</body><body package="PickCell">doGetGPS	^doGetGPS</body><body package="PickCell">doGetGPS: anObject	doGetGPS := anObject</body><body package="PickCell">doSaveGPSPoints	^doSaveGPSPoints</body><body package="PickCell">doSaveGPSPoints: anObject	doSaveGPSPoints := anObject</body><body package="PickCell">doShowCoverCells	doShowCoverCells isNil ifTrue: [doShowCoverCells := true asValue].	^doShowCoverCells</body><body package="PickCell">doShowCoverCells: anObject	doShowCoverCells := anObject</body><body package="PickCell">doShowGPS	^doShowGPS</body><body package="PickCell">doShowGPS: anObject	doShowGPS := anObject</body><body package="PickCell">doShowGraph	doShowGraph isNil ifTrue: [doShowGraph := true asValue].	^doShowGraph</body><body package="PickCell">doShowGraph: anObject	doShowGraph := anObject</body><body package="PickCell">doShowGrid	doShowGrid isNil ifTrue: [doShowGrid := true asValue].	^doShowGrid</body><body package="PickCell">doShowGrid: anObject	doShowGrid := anObject</body><body package="PickCell">doShowImage	doShowImage isNil ifTrue: [doShowImage := true asValue].	^doShowImage</body><body package="PickCell">doShowImage: anObject	doShowImage := anObject</body><body package="PickCell">doShowLabel	doShowLabel isNil ifTrue: [doShowLabel := true asValue].	^doShowLabel</body><body package="PickCell">doShowLabel: anObject	doShowLabel := anObject</body><body package="PickCell">doShowWind	^doShowWind</body><body package="PickCell">doShowWind: anObject	doShowWind := anObject</body><body package="PickCell">doShowZones	doShowZones isNil ifTrue: [doShowZones := true asValue].	^doShowZones</body><body package="PickCell">doShowZones: anObject	doShowZones := anObject</body><body package="PickCell">fromDB: aString	| rs nodeid time latString lat lonString lon alt rssi aPoint |	aPoint := TrackPoint new.	rs := aString readStream.	nodeid := rs upTo: $,.	time := rs upTo: $,.	time := time copyFrom: 1 to: time size - 3.	latString := rs upTo: $,.	latString := latString , 'd'.	lat := self convertValue: latString.	lonString := rs upTo: $,.	lonString := lonString , 'd'.	lon := self convertValue: lonString.	alt := rs upTo: $,.	rssi := rs upTo: Character cr.	aPoint		id: nodeid;		time: time;		lon: lon asDouble;		lat: lat asDouble;		alt: alt;		rssi: rssi.	^aPoint</body><body package="PickCell">getData	^getData</body><body package="PickCell">getData: anObject	getData:= anObject</body><body package="PickCell">getGPSData	| usb bufferPointer numChar ws buffer portOk points trackPoint |	USBSerial unloadLibraries.	usb := USBSerial new.	usb initialize.	points := OrderedCollection new.	usb RS232_CloseComport: 27.	Transcript		show: Time now printString;		cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 38400.	usb		flushBuf: bufferPointer		with: 4095		with: 27		with: 38400.	portOk = 0		ifFalse: 			[Transcript				show: 'open error';				cr]		ifTrue: 			[10 timesRepeat: 					["bufferPointer := CIntegerType char gcMalloc: 4096."					numChar := usb								readBuf: bufferPointer								with: 4095								with: 27								with: 38400.					ws := String new writeStream.					0 to: numChar - 1						do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].					Transcript						show: numChar printString;						tab;						show: ws contents.					trackPoint := TrackPoint from: ws contents.					trackPoint isNil ifFalse: [points add: trackPoint].					(Delay forSeconds: 1) wait].			usb RS232_CloseComport: 27].	^points</body><body package="PickCell">getGPSData1	| usb bufferPointer numChar ws buffer portOk points trackPoint status trackingInterface |	USBSerial unloadLibraries.	usb := USBSerial new.	usb initialize.	points := OrderedCollection new.	usb RS232_CloseComport: 27.	Transcript		show: Time now printString;		cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 38400.	usb		flushBuf: bufferPointer		with: 4095		with: 27		with: 38400.	trackingInterface := GPSTrackingInterface new.	trackingInterface open.	status := trackingInterface getStatus.	[status = 1] whileFalse: 			[(Delay forSeconds: 30) wait.			status := trackingInterface getStatus].	portOk = 0		ifFalse: 			[Transcript				show: 'Open serial interface error';				cr]		ifTrue: 			[[status = 1] whileTrue: 					[numChar := usb								readBuf: bufferPointer								with: 4095								with: 27								with: 38400.					ws := String new writeStream.					0 to: numChar - 1						do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].					Transcript						show: numChar printString;						tab;						show: ws contents.					trackPoint := TrackPoint from: ws contents.					trackPoint isNil ifFalse: [points add: trackPoint].					(Delay forSeconds: 1) wait.					status := trackingInterface getStatus].			usb RS232_CloseComport: 27.			trackingInterface window close].	^points</body><body package="PickCell">guessedName	^guessedName</body><body package="PickCell">guessedName: anObject	guessedName := anObject</body><body package="PickCell">knownUrlVH	^knownUrlVH</body><body package="PickCell">knownUrlVH: anObject	knownUrlVH := anObject</body><body package="PickCell">knownUrlWindow	^knownUrlWindow</body><body package="PickCell">knownUrlWindow: anObject	knownUrlWindow := anObject</body><body package="PickCell">laVue	^laVue</body><body package="PickCell">parseLat: aString	| ls n ch entier decimal number north |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	north := aString last = $N.	north ifFalse: [number := number negated].	^number</body><body package="PickCell">parseLon: aString	| ls n ch entier decimal number west |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := (n / 10000 - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	west := aString last = $W.	west ifTrue: [number := number negated].	^number</body><body package="PickCell">pickModel	^pickModel</body><body package="PickCell">storedHistory	^storedHistory</body><body package="PickCell">storedHistory: anObject	storedHistory := anObject</body><body package="PickCell">testGetStatus	| status trackingInterface |	trackingInterface := GPSTrackingInterface new.	trackingInterface open.	status:= trackingInterface getStatus.	Transcript show: status printString.	self halt.	^self</body><body package="PickCell">uiCellShow	^uiCellShow</body><body package="PickCell">uiCellShow: anObject	uiCellShow := anObject</body><body package="PickCell">uiLocation	^uiLocation</body><body package="PickCell">uiLocation: anObject	uiLocation := anObject</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>menu</category><body package="PickCell">changedDisplayMode	" transfer display status to the pickCellModel "	| modeDico doFlag |	doFlag := self doShowGrid value.	modeDico := self pickModel value displayModeDictionary.	modeDico at: #displayGrid put: doFlag.	doFlag := self doShowZones value.	modeDico at: #displayZones put: doFlag.	doFlag := self doShowImage value.	modeDico at: #displayImage put: doFlag.	doFlag := self doShowGraph value.	modeDico at: #displayGraph put: doFlag.	doFlag := self doShowCoverCells value.	modeDico at: #displayCoverCells put: doFlag.	doFlag := self doShowLabel value.	modeDico at: #displayLabel put: doFlag.	doFlag := self doShowWind value.	modeDico at: #displayWinds   put: doFlag.	self laVue invalidate</body><body package="PickCell">doShowCoverCellsSwitch	| menu submenu subsubmenu |	self doShowCoverCells value: self doShowCoverCells value not.	menu := self builder menuAt: #leMenu.	submenu := (menu menuItemLabeled: 'View') submenu.	subsubmenu := submenu menuItemLabeled: 'CoverCells'.	self doShowCoverCells value		ifTrue: [subsubmenu beOn]		ifFalse: [subsubmenu beOff]</body><body package="PickCell">doShowGraphSwitch	| menu submenu subsubmenu | 	self doShowGraph value: self doShowGraph value not.	menu := self builder menuAt: #leMenu.	submenu := (menu menuItemLabeled: 'View') submenu.	subsubmenu := submenu menuItemLabeled: 'Graph'.	self doShowGraph value ifTrue: [subsubmenu beOn] ifFalse: [subsubmenu beOff]</body><body package="PickCell">doShowGridSwitch	| menu submenu subsubmenu | 	self doShowGrid value: self doShowGrid value not.	menu := self builder menuAt: #leMenu.	submenu := (menu menuItemLabeled: 'View') submenu.	subsubmenu := submenu menuItemLabeled: 'Grid'.	self doShowGrid value ifTrue: [subsubmenu beOn] ifFalse: [subsubmenu beOff]</body><body package="PickCell">doShowImageSwitch	| menu submenu subsubmenu | 	self doShowImage value: self doShowImage value not.	menu := self builder menuAt: #leMenu.	submenu := (menu menuItemLabeled: 'View') submenu.	subsubmenu := submenu menuItemLabeled: 'Image'.	self doShowImage value ifTrue: [subsubmenu beOn] ifFalse: [subsubmenu beOff]</body><body package="PickCell">doShowLabelSwitch	| menu submenu subsubmenu |	self doShowLabel value: self doShowLabel value not.	menu := self builder menuAt: #leMenu.	submenu := (menu menuItemLabeled: 'View') submenu.	subsubmenu := submenu menuItemLabeled: 'Label'.	self doShowLabel value		ifTrue: [subsubmenu beOn]		ifFalse: [subsubmenu beOff]</body><body package="PickCell">doShowWindSwitch	| menu submenu subsubmenu |	self doShowWind value: self doShowWind value not.	menu := self builder menuAt: #leMenu.	submenu := (menu menuItemLabeled: 'View') submenu.	subsubmenu := submenu menuItemLabeled: 'Wind'.	self doShowZones value		ifTrue: [subsubmenu beOn]		ifFalse: [subsubmenu beOff]</body><body package="PickCell">doShowZonesSwitch	| menu submenu subsubmenu |	self doShowZones value: self doShowZones value not.	menu := self builder menuAt: #leMenu.	submenu := (menu menuItemLabeled: 'View') submenu.	subsubmenu := submenu menuItemLabeled: 'Zones'.	self doShowZones value		ifTrue: [subsubmenu beOn]		ifFalse: [subsubmenu beOff]</body><body package="PickCell">getShowCoverCellsMenu	^self doShowCoverCells value</body><body package="PickCell">getShowGraphMenu	^self doShowGraph value</body><body package="PickCell">getShowGridMenu	^self doShowGrid value</body><body package="PickCell">getShowImageMenu	^self doShowImage value</body><body package="PickCell">getShowLabelMenu	^self doShowLabel value</body><body package="PickCell">getShowWindMenu	^self doShowWind value</body><body package="PickCell">getShowZonesMenu	^self doShowZones value</body><body package="PickCell">initializeShowMenu	| dico |	dico := self pickModel value displayModeDictionary.	dico at: #displayGrid put: true.	self doShowGrid: true asValue.	dico at: #displayImage put: true.	self doShowImage: true asValue.	dico at: #displayGraph put: true.	self doShowGraph: true asValue.	dico at: #displayZones put: true.	self doShowZones: true asValue.	self doShowLabel: true asValue.	dico at: #displayLabel put: true.	self doShowWind: false asValue.	dico at: #displayWinds put: false.	self doShowImage onChangeSend: #changedDisplayMode to: self.	self doShowGrid onChangeSend: #changedDisplayMode to: self.	self doShowGraph onChangeSend: #changedDisplayMode to: self.	self doShowCoverCells onChangeSend: #changedDisplayMode to: self.	self doShowZones onChangeSend: #changedDisplayMode to: self.	self doShowLabel onChangeSend: #changedDisplayMode to: self.	self doShowWind onChangeSend: #changedDisplayMode to: self</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>actions</category><body package="PickCell">buildCellArray	| pm name |	pm := self pickModel value. 	name := Dialog request: 'system name ?'				initialAnswer: pm guessedName.	name isEmpty ifFalse: [pm guessedName: name].	pm getElevation: false.	uiCellShow := pm scanCellArray: self leSeuil value.	"uiCellShow uiLocation: self uiLocation."	uiCellShow masterPickCellNodes: self.	"	uiLoc := self uiLocation builder window.	uiLoc isCollapsed ifTrue: [uiLoc expand]. "	Transcript		show: self pickModel value cellClassifier dictionary size printString					, ' pixels differents';		cr</body><body package="PickCell">buildCellArrayWithElevation	| uiLoc pm |	pm := self pickModel value.	pm getElevation: true. 	uiCellShow := pm scanCellArray: self leSeuil value.	uiCellShow uiLocation: self uiLocation.	uiCellShow masterPickCellNodes: self.	uiLoc := self uiLocation builder window.	uiLoc isCollapsed ifTrue: [uiLoc expand].	Transcript		show: self pickModel value cellClassifier dictionary size printString					, ' pixels differents';		cr</body><body package="PickCell">buildNet	| model view gc netAndDicoAndComposite |	model := self pickModel value.	view := self laVue.	gc := view graphicsContext.	netAndDicoAndComposite := model buildNetAndDisplayOn: gc.	self updateGeneratorsWith: netAndDicoAndComposite first.	model lastGraph: netAndDicoAndComposite last.	model pointDictionary: (netAndDicoAndComposite at: 2).	self pickModel value: model</body><body package="PickCell">buildNetDrawingOnView	| net model view gc |	model := self pickModel value.	view := self laVue.	gc := view graphicsContext.	net := model buildNetAndDisplayOn: gc.	self halt.	self updateGeneratorsWith: net.	model lastGraph: net.	self pickModel value: model.	self halt</body><body package="PickCell">buildNetOld	| pm net model |	pm := self pickModel value.	net := pm buildNet.	self updateGeneratorsWith: net.	model := self pickModel value.	model lastGraph: net.	self pickModel value: model.	self halt</body><body package="PickCell">displayOnWindow: box	| pixmap gc topView |	pixmap := Pixmap extent: box extent.	gc := pixmap graphicsContext.	self laVue displayOn: gc.	topView := ScheduledWindow new.	topView topView minimumSize: box extent + (2 @ 2).	topView		component: (BorderDecorator on: pixmap asImage) useHorizontalScrollbar.	topView open</body><body package="PickCell">doAwakeLocation	| locWindows |	locWindows := UILocation allInstances				select: [:uiloc | uiloc = self uiLocation].	locWindows isEmpty		ifFalse: 			[locWindows do: 					[:win |					win						open;						closeRequest]].	self uiLocation: UILocation new.	self uiLocation open</body><body package="PickCell">doCellSystemName	| pm name winTitle currentName |	pm := self pickModel value. 	currentName := pm filename.	name := Dialog request: ' Cell system name ?' initialAnswer: currentName.	name isEmpty		ifFalse: 			[pm guessedName: name.			winTitle := 'Pickcell - ' , pm guessedName.			self builder window label: winTitle]</body><body package="PickCell">doCopy	| selection |	selection := self laLat value  , ' ' , self laLon value.	TextEditorController copySelection: selection</body><body package="PickCell">doCoverage	| mouseCell xValue yValue pm dico nodeNumber test cov testNode covNode posStruct pos visible xLocation yLocation nameNode lon lat elev band cod spr para |	mouseCell := self pickModel value mouseCell.	xValue := mouseCell x.	yValue := mouseCell y.	nodeNumber := 868.	test := CovVW new.	cov := test covStruct gcMalloc: nodeNumber.	num := 0.	1 to: 32		do: 			[:j |			test				covVW: cov				with: xValue				with: yValue				with: j.			testNode := CovVW new.			covNode := testNode covStruct gcMalloc.			posStruct := OrderedCollection new.			paraLora := OrderedCollection new.			1 to: nodeNumber				do: 					[:i |					covNode := cov at: i.					visible := covNode memberAt: #visible.					visible == 1						ifTrue: 							[pos := OrderedCollection new.							para := OrderedCollection new.							lon := covNode memberAt: #longitude.							lat := covNode memberAt: #latitude.							elev := covNode memberAt: #elevation.							xLocation := covNode memberAt: #x.							yLocation := covNode memberAt: #y.							band := covNode memberAt: #BW.							cod := covNode memberAt: #CR.							spr := covNode memberAt: #SF.							nameNode := 'Px' , xLocation asString , 'y' , yLocation asString , '_,'.							pos								add: lat;								add: lon;								add: elev;								add: nameNode.							posStruct add: pos asArray.							para								add: xLocation;								add: yLocation;								add: band;								add: cod;								add: spr.							paraLora add: para asArray]].			pm := pickModel value.			pm isNil				ifFalse: 					[dico := pm positionCoverDictionary: posStruct.					pm highLightCells: dico]			"Dialog warn: 'Turn: ' , j printString"].	1 to: nodeNumber		do: 			[:t |			covNode := cov at: t.			visible := covNode memberAt: #visible.			visible == 1 ifTrue: [num := num + 1]].	^Array with: paraLora with: num</body><body package="PickCell">doCoverageOpt	| mouseCell xValue yValue nodeNumber test cov testNode covNode posStruct pos visible xLocation yLocation nameNode  lon lat elev band cod spr  |	mouseCell := self pickModel value mouseCell.	xValue := mouseCell x.	yValue := mouseCell y.	nodeNumber := 868.	test := CovVW new.	cov := test covStruct gcMalloc: nodeNumber.	1 to: 32		do: 			[:j |			test				covVW: cov				with: xValue				with: yValue				with: j.			testNode := CovVW new.			covNode := testNode covStruct gcMalloc.			posStruct := OrderedCollection new.			paraLora := OrderedCollection new.			num := 0.			1 to: nodeNumber				do: 					[:i |					covNode := cov at: i.					visible := covNode memberAt: #visible.					visible == 1						ifTrue: 							[pos := OrderedCollection new.							para := OrderedCollection new.							num := num + 1.							lon := covNode memberAt: #longitude.							lat := covNode memberAt: #latitude.							elev := covNode memberAt: #elevation.							xLocation := covNode memberAt: #x.							yLocation := covNode memberAt: #y.							band := covNode memberAt: #BW.							cod := covNode memberAt: #CR.							spr := covNode memberAt: #SF.							nameNode := 'Px' , xLocation asString , 'y' , yLocation asString , '_,'.							pos								add: lat;								add: lon;								add: elev;								add: nameNode.							"add: power;"							posStruct add: pos asArray.							para								add: xLocation;								add: yLocation;								add: band;								add: cod;								add: spr.							paraLora add: para asArray]]].	^Array with: paraLora with: num</body><body package="PickCell">doCoverageStatistics	| mouseCell xValue yValue pm dico turns nodeNumber test cov testNode covNode posStruct pos visible xLocation yLocation nameNode xString yString altitude visiblePoints visiblePos |	mouseCell := self pickModel value mouseCell.	xValue := mouseCell x.	yValue := mouseCell y.	"turns = max(xValue, yValue)"	turns := 222.	nodeNumber := 48618.	test := Trevezel new.	cov := test covStruct gcMalloc: nodeNumber.	test		covVW: cov		with: xValue		with: yValue		with: turns.	testNode := Trevezel new.	covNode := testNode covStruct gcMalloc.	posStruct := OrderedCollection new.	visiblePoints := OrderedCollection new.	1 to: nodeNumber		do: 			[:i |			| long lat |			covNode := cov at: i.			visible := covNode memberAt: #visible.			visible == 1				ifTrue: 					[pos := OrderedCollection new.					visiblePos := OrderedCollection new.					long := covNode memberAt: #longitude.					lat := covNode memberAt: #latitude.					altitude := covNode memberAt: #elevation.					xLocation := covNode memberAt: #x.					yLocation := covNode memberAt: #y.					xString := xLocation printString.					yString := yLocation printString.					nameNode := 'Px' , xString , 'y' , yString , '_,'.					pos						add: lat;						add: long;						add: altitude;						add: nameNode.					posStruct add: pos asArray.					visiblePos						add: xLocation;						add: yLocation.					visiblePoints add: visiblePos asArray]].	pm := pickModel value.	pm isNil		ifFalse: 			[dico := pm positionCoverDictionary: posStruct.			pm highLightCells: dico].	^visiblePoints</body><body package="PickCell">doCoverageStatistics2	| mouseCell xValue yValue turns nodeNumber test cov testNode covNode posStruct pos visible xLocation yLocation nameNode xString yString altitude visiblePoints visiblePos latString lonString lon lat |	mouseCell := self pickModel value mouseCell.	xValue := mouseCell x.	yValue := mouseCell y.	xValue := 119.	yValue := 186.	"turns = max(xValue, yValue)"	turns := 222.	nodeNumber := 48618.	test := Trevezel new.	cov := test covStruct gcMalloc: nodeNumber.	test		covVW: cov		with: xValue		with: yValue		with: turns.	testNode := Trevezel new.	covNode := testNode covStruct gcMalloc.	posStruct := OrderedCollection new.	visiblePoints := OrderedCollection new.	1 to: nodeNumber		do: 			[:i |			covNode := cov at: i.			visible := covNode memberAt: #visible.			visible == 1				ifTrue: 					[pos := OrderedCollection new.					visiblePos := OrderedCollection new.					lon := covNode memberAt: #longitude.					lat := covNode memberAt: #latitude.					altitude := covNode memberAt: #elevation.					xLocation := covNode memberAt: #x.					yLocation := covNode memberAt: #y.					xString := xLocation printString.					yString := yLocation printString.					nameNode := 'Px' , xString , 'y' , yString , '_,'.					pos						add: lat;						add: lon;						add: altitude;						add: nameNode.					posStruct add: pos asArray.					latString := lat printString , 'd'.					lonString := lon printString , 'd'.					visiblePos						add: latString asNumber;						add: lonString asNumber.					visiblePoints add: visiblePos asArray]]."	pm := pickModel value.	pm isNil		ifFalse: 			[dico := pm positionCoverDictionary: posStruct.			pm highLightCells: dico]."	^visiblePoints</body><body package="PickCell">doDisplayCover	| uit cellPosArray pm dico |	uit := UITextPoints new. 	uit pickModel: (self pickModel value).	uit doLoad.	cellPosArray := uit doAnalyzeCover.	pm := pickModel value.	pm isNil		ifFalse: 			[dico := pm positionCoverDictionary: cellPosArray.			pm highLightCells: dico]</body><body package="PickCell">doDisplayCoverFile: traceFile	| uit cellPosArray pm dico |	uit := UITextPoints new. 	uit pickModel: (self pickModel value).	uit doLoadFile: traceFile.	cellPosArray := uit doAnalyzeCover.	pm := pickModel value.	pm isNil		ifFalse: 			[dico := pm positionCoverDictionary: cellPosArray.			pm highLightCells: dico.				self laVue invalidate.]</body><body package="PickCell">doGetView	"open a pick cell window"	| box origin boxView pixmap gc topView names fileNames directory minus tail fnSort q1 q2 m1 m2 min1 min2 png |	boxView := self builder componentAt: #ViewHolder1.	origin := self builder window displayBox origin.	box := boxView bounds translatedBy: origin.	pixmap := Pixmap extent: box extent.	gc := pixmap graphicsContext.	self laVue displayOn: gc.	topView := ScheduledWindow new.	topView topView minimumSize: box extent + (2 @ 2).	topView		component: (BorderDecorator on: pixmap asImage) useHorizontalScrollbar.	topView open.	names := Dialog requestFileName: 'basic name ?'.	directory := names asFilename directory.	tail := names asFilename tail.	tail := tail reverse.	minus := tail indexOf: $-.	names := (tail copyFrom: minus to: tail size) reverse.	names := names , '*.txt'.	fileNames := directory filenamesMatching: names.	fnSort := SortedCollection sortBlock: 					[:n1 :n2 |					m1 := n1 tail asString.					m2 := n2 tail asString.					min1 := m1 indexOf: $-.					min2 := m2 indexOf: $-.					q1 := m1 copyFrom: min1 + 1 to: m1 size.					q2 := m2 copyFrom: min2 + 1 to: m2 size.					q1 asNumber &lt; q2 asNumber].	fnSort addAll: fileNames.	fnSort do: 			[:fn |			| stream |			self doDisplayCoverFile: fn asString.			pixmap := Pixmap extent: box extent.			gc := pixmap graphicsContext.			self laVue displayOn: gc.			self displayOnWindow: box.			png := fn asString , '.png'.			stream := png asFilename writeStream.						[stream binary.			Refactory.PNG.PNGImageWriter writeImage: pixmap asImage on: stream]					ensure: [stream close]]</body><body package="PickCell">doGo	| lon lat mo originPixel zoom pm m mapPixel pixel |	lon := self longitude value.	lat := self latitude value.	mo := self pickModel value mapOrigin.	originPixel := mo at: 1.	zoom := mo at: 2.	pm := self pickModel value mercator.	m := pm latLonToMeter: lat lon: lon.	mapPixel := pm meterToPixelNew: m zoom: zoom.	pixel := mapPixel - originPixel.	self laVue controller activate.	self laVue controller sensor cursorPoint: pixel rounded.</body><body package="PickCell">doInspect	self inspect</body><body package="PickCell">doLoadWind	| uit cellPosArray pm fn rs dico |	uit := UITextPoints new.	fn := Dialog requestFileName: 'windFile ?'.	fn isEmpty		ifFalse: 			[fn := fn asFilename.			rs := fn readStream.			uit leTexte value: rs contents.			rs close.			uit pickModel: self pickModel value.			self halt.			cellPosArray := uit doAnalyzeWind.			pm := pickModel value.			pm isNil ifFalse: [dico := pm positionWindDictionary: cellPosArray]]</body><body package="PickCell">doPara	"parameterLora := OrderedCollection new.	self halt.	optArray := self doCoverageOpt.	parameterLora := optArray at: 1.	numTurn := optArray at: 2."	| mouseCell xValue yValue lora xLora yLora bwLora crLora sfLora |	paraLora isNil		ifFalse: 			[mouseCell := self pickModel value mouseCell.			xValue := mouseCell x.			yValue := mouseCell y.			bwLora := -1.			crLora := -1.			sfLora := -1.			1 to: num				do: 					[:k |					lora := paraLora at: k.					xLora := lora at: 1.					yLora := lora at: 2.					xValue == xLora						ifTrue: 							[yValue == yLora								ifTrue: 									[bwLora := lora at: 3.									crLora := lora at: 4.									sfLora := lora at: 5]]].			bwLora == -1				ifFalse: 					[Dialog						warn: 'Suggest paramters: BW=' , bwLora printString , 'Hz, CR='								, crLora printString , ', SF='								, sfLora printString]				ifTrue: [Dialog warn: 'This place cannot recceive the signal.']]		ifTrue: [Dialog warn: 'Must perform estimate coverage (Cov) first']</body><body package="PickCell">doPointsDB	| collection connection session answer row rs aPoint |	aPoint := TrackPoint new.	collection := OrderedCollection new.	connection := PostgresSocketConnection new.	connection		username: 'osm';		password: 'fare&amp;bali';		environment: '172.12.18.159:5432_france'.	connection connect.	session := connection getSession.	session		prepare: 'select * from recoco_june92017';		execute.	answer := session answer.	[answer atEnd] whileFalse: 			[row := answer next.			collection add: row.			rs := (row at: 1) , ',' , (row at: 2) printString , ',' , (row at: 3)						, ',' , (row at: 4)						, ',' , (row at: 5)						, ',' , (row at: 6).			"self halt."			aPoint := self fromDB: rs.			self laVue controller addAGPSPoint: aPoint].	^nil</body><body package="PickCell">doShowCover	| uit cellPosArray pm dico |	uit := UITextPoints new. 	uit pickModel: (self pickModel value).	"uit doLoad."	cellPosArray := uit doParseCoverage.	pm := pickModel value.	pm isNil		ifFalse: 			[dico := pm positionCoverDictionary: cellPosArray.			pm highLightCells: dico]</body><body package="PickCell">loadImage	| filename reader image pm bounds button | 	filename := Dialog requestFileName: 'Name a file' default: '.png .jpg .tiff .gif'.	filename isEmpty		ifFalse: 			[reader := ImageReader fromFile: filename.			image := reader image.			bounds := image bounds.			pm := self pickModel value.			pm filename: filename.			pm points: OrderedCollection new.			pm bounds: bounds.			self pickModel value: pm.			self laVue image: image.			button := self builder componentAt: #Slider1.			button enable.			button widget invalidate.			button := self builder componentAt: #InputField1.			button enable.			button widget invalidate]</body><body package="PickCell">loadPoints	| filename pm dico stream line ls pointX pointY point name points |	dico := Dictionary new.	points := OrderedCollection new.	filename := Dialog requestFileName: 'Name a point system  file' default: '*.txt'.	filename isEmpty		ifFalse: 			[stream := filename asFilename readStream.			[stream atEnd] whileFalse: 					[line := stream upTo: Character cr.					line isEmpty						ifFalse: 							[ls := line readStream.							pointX := ls upTo: $@.							pointY := ls upTo: $'.							point := pointX asNumber @ pointY asNumber.							name := ls upTo: $'.							points add: point.							dico at: point put: name]].			pm := self pickModel value.			pm pointDictionary: dico.			pm points: points.			self pickModel value: pm]</body><body package="PickCell">loadRectangles	| filename rs scanner eachLine line rect model |	filename := Dialog requestFileName: 'Name a file' default: '.rect'.	filename isEmpty		ifFalse: 			[rs := filename asFilename readStream.			scanner := Scanner new.			rect := Set new.			[rs atEnd] whileFalse: 					[eachLine := rs upTo: Character cr.					line := scanner scanTokens: eachLine.					rect add: (Rectangle origin: (line at: 1) @ (line at: 2) corner: (line at: 3) @ (line at: 4))].			model := self pickModel value.			model zones: rect.			self pickModel value: model]</body><body package="PickCell">loadUrl	| uiku uikuWin |	self class knownUrls.	uiku := UIKnownUrls new.	uikuWin := uiku open.	self knownUrlWindow: uikuWin window.	self knownUrlVH: uiku knownUrl.	uiku knownUrl onChangeSend: #changeUrl to: self.	uiku closeVH onChangeSend: #changeForCloseKnownUrl to: self</body><body package="PickCell">loadUrlHistory	| uiku uikuWin |	self class knownUrls.	uiku := UIKnownUrls new.	uikuWin := uiku open.	self knownUrlWindow: uikuWin window.	self knownUrlVH: uiku knownUrl.	uiku knownUrl onChangeSend: #changeUrlHistory to: self.	uiku closeVH onChangeSend: #changeForCloseKnownUrl to: self.</body><body package="PickCell">postscript	| printer boxView origin box pixmap image filename drawingBounds file gc |	printer := Printer startPrintJobNamed: 'aString'.	boxView := self builder componentAt: #ViewHolder1.	origin := self builder window displayBox origin.	box := boxView bounds translatedBy: origin.	pixmap := Pixmap extent: box extent.	self laVue displayOn: pixmap graphicsContext.	image := pixmap asImage.	filename := Dialog requestNewFileName: 'Enter filename for output:'				default: 'drawing.ps'.	filename isEmpty ifTrue: [^self].	drawingBounds := image bounds.	file := printer.	file setLandscape: drawingBounds extent x &gt; drawingBounds extent y.	gc := file graphicsContext.	"gc palette: self laVue image palette."	gc scaleBy: 1.	"(scale min: 1)"	image displayOn: gc.	file close</body><body package="PickCell">resetPoints	| pm model |	pm := self pickModel value.	model := self pickModel value.	pm points isNil ifFalse: [pm points: OrderedCollection new].	self pickModel value: pm.	model lastGraph: nil</body><body package="PickCell">saveImage	| box image filename drawingBounds file gc boxView origin pixmap | 	boxView := self builder componentAt: #ViewHolder1.	origin := self builder window displayBox origin.	box := boxView bounds translatedBy: origin.	pixmap := Pixmap extent: box extent.	self laVue  displayOn: pixmap graphicsContext.  	image:= pixmap asImage.  	filename := Dialog requestNewFileName: 'Enter filename for output:'				default: 'drawing.ps'.	filename isEmpty ifTrue: [^self].	drawingBounds := image bounds.	file := PostScriptFile named: filename.	file setLandscape: drawingBounds extent x &gt; drawingBounds extent y.	gc := file graphicsContext.	gc palette: self laVue palette.	gc scaleBy: 1.	"(scale min: 1)"	image displayOn: gc.	file close</body><body package="PickCell">savePoints	| filename pm dico stream name points |	pm := self pickModel value.	pm buildNet.	dico := pm pointDictionary.	points := pm points.	filename := Dialog requestNewFileName: 'Name a point system  file'				default: '*.txt'.	filename isEmpty		ifFalse: 			[stream := filename asFilename writeStream.			points do: 					[:eachPoint |					eachPoint printOn: stream.					stream space.					name := dico at: eachPoint.					name printOn: stream.					stream cr].			stream close]</body><body package="PickCell">savePostscript	| box image filename drawingBounds file gc boxView origin pixmap | 	boxView := self builder componentAt: #ViewHolder1.	origin := self builder window displayBox origin.	box := boxView bounds translatedBy: origin.	pixmap := Pixmap extent: box extent.	self laVue  displayOn: pixmap graphicsContext.  	image:= pixmap asImage.  	filename := Dialog requestNewFileName: 'Enter filename for output:'				default: 'drawing.ps'.	filename isEmpty ifTrue: [^self].	drawingBounds := image bounds.	file := PostScriptFile named: filename.	file setLandscape: drawingBounds extent x &gt; drawingBounds extent y.	gc := file graphicsContext.	"gc palette: self laVue image palette."	gc scaleBy: 1.	"(scale min: 1)"	image displayOn: gc.	file close</body><body package="PickCell">showActivePoints	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint receivedPoints receivedPos |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	receivedPoints := OrderedCollection new.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[receivedPos := OrderedCollection new.							nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPoint: aPoint.							receivedPos add: laVue position.							receivedPoints add: receivedPos asArray]].			rs close].	self halt.	^receivedPoints</body><body package="PickCell">showInactivePoints	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPointInactive: aPoint]].			rs close].	^nil</body><body package="PickCell">showInvisiblePoints	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPointInactive: aPoint]].			rs close].	^nil</body><body package="PickCell">showMobilePoints	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPointInactive: aPoint]].			rs close].	^nil</body><body package="PickCell">showPointsFromLogFile	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPoint: aPoint]].			rs close].	^nil</body><body package="PickCell">showTrackPoints	| aGPSTracking |	self		doGetGPS: 			[aGPSTracking := GPSTrackingInterface new.			aGPSTracking open] fork.	self		doShowGPS: 			[[true] whileTrue: 					[self laVue controller addAGPSPoint: APoint.					APoint := nil.					(Delay forMilliseconds: 1) wait]]					fork</body><body package="PickCell">showTrackPointsBK	"text input for testing"	| trackPoints |	"trackPoints := TrackPoint				from: '51 ID2, 14:38:37, 4824.0176N, 00430.0715W, 62.4, -73'."	"get data from RECoco"	trackPoints := TrackPoint  new.	trackPoints := self getGPSData. 	self laVue controller addGPSPoints: trackPoints</body><body package="PickCell">showTrackPointsDB	| aGPSTracking |	self		doGetGPS: 			[aGPSTracking := GPSTrackingInterface new.			aGPSTracking open] fork.	self		doShowGPS: 			[[true] whileTrue: 					[self laVue controller addAGPSPoint: APoint.					APoint := nil.					(Delay forMilliseconds: 1) wait]]					fork</body><body package="PickCell">showVisiblePoints	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPoint: aPoint]].			rs close].	^nil</body><body package="PickCell">showVisiblePointsTest	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint receivedPoints receivedPos pickcellLoc |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	receivedPoints := OrderedCollection new.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[receivedPos := OrderedCollection new.							nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPoint: aPoint.							pickcellLoc := self laVue controller getPoint.							receivedPos								add: pickcellLoc x;								add: pickcellLoc y.							receivedPoints add: receivedPos asArray]].			rs close].	^receivedPoints</body><body package="PickCell">updateGeneratorsWith: net	| uiGenerators connectivity uiLoc | 	uiGenerators := UINetworkGeometry allInstances. 	uiGenerators isEmpty		ifTrue: 			[UINetworkGeometry open.			uiGenerators := UINetworkGeometry allInstances].	uiGenerators do: 			[:aGenerator |			connectivity := net buildNetworkLocalized.			connectivity name: self pickModel value filename.			aGenerator leStyle value: nil.			aGenerator theNbSystems value: net points size.			aGenerator theRadius value: self portee value.			aGenerator theSize value: self pickModel value bounds width.			aGenerator doGraphic value: false.			aGenerator leCode value: connectivity printString.			uiLoc := aGenerator builder window.			uiLoc isCollapsed ifTrue: [uiLoc expand]]</body><body package="PickCell">updateGeneratorsWithCellNet: net	| uiGenerators uiLoc projectDir |	uiGenerators := UINetworkGeometry allInstances.	uiGenerators isEmpty		ifTrue: 			[UINetworkGeometry open.			uiGenerators := UINetworkGeometry allInstances].	uiGenerators do: 			[:aGenerator |			aGenerator leStyle value: nil.			aGenerator theNbSystems value: net nodeDictionary keys size.			aGenerator theRadius value: self portee value.			aGenerator theSize value: self pickModel value bounds width.			aGenerator doGraphic value: false.			aGenerator includeData: nil.			aGenerator sourceUpdated.			aGenerator leCode value: net printString.			projectDir := self pickModel value guessedDirectory.			projectDir := projectDir , '/'.			projectDir asFilename ensureDirectory.			aGenerator generateDir: projectDir.			aGenerator doGenerate.			uiLoc := aGenerator builder window.			uiLoc isCollapsed ifTrue: [uiLoc expand].			uiLoc display.			uiLoc display]</body><body package="PickCell">updateGeneratorsWithCellNet: net withDataFile: dataFileName	| uiGenerators uiLoc projectDir |	uiGenerators := UINetworkGeometry allInstances.	uiGenerators isEmpty		ifTrue: 			[UINetworkGeometry open.			uiGenerators := UINetworkGeometry allInstances].	uiGenerators do: 			[:aGenerator |			aGenerator leStyle value: nil.			aGenerator theNbSystems value: net nodeDictionary keys size.			aGenerator theRadius value: self portee value.			aGenerator theSize value: self pickModel value bounds width.			aGenerator doGraphic value: false.			aGenerator includeData: dataFileName.			aGenerator sourceUpdated.			aGenerator leCode value: net printString.  			projectDir := self  pickModel value guessedDirectory.			projectDir := (projectDir , '/') .			projectDir asFilename ensureDirectory. 						aGenerator generateDir: projectDir. 			aGenerator doGenerate: true. 			uiLoc := aGenerator builder window.			uiLoc isCollapsed ifTrue: [uiLoc expand].			uiLoc display.			uiLoc display]</body><body package="PickCell">visiblePointsStatistics	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint receivedPoints receivedPos pickcellLoc |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	receivedPoints := OrderedCollection new.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[receivedPos := OrderedCollection new.							nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								time: time;								lon: lon;								lat: lat;								alt: alt;								rssi: rssi.							self laVue controller addAGPSPoint: aPoint.							pickcellLoc := self laVue controller getReveivedPoints: aPoint.							receivedPos								add: pickcellLoc x ceiling;								add: pickcellLoc y ceiling.							receivedPoints add: receivedPos asArray]].			rs close].	^receivedPoints</body><body package="PickCell">visiblePointsStatistics2	| aName filename rs nodeid time lat lon rssi alt latString lonString receivedPoints receivedPos |	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackMobilePoints.txt'				for: nil.	receivedPoints := OrderedCollection new.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[receivedPos := OrderedCollection new.							nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.										receivedPos								add: lat;								add: lon.							receivedPoints add: receivedPos asArray]].			rs close].	^receivedPoints</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>fileIn/Out</category><body package="PickCell">processReply: replyTo	| source imageStream readerClass reader |	source := replyTo value byteSource.	imageStream := source .		[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream]			ensure: [imageStream ifNotNil: [:stream | stream close]].	^reader image</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>changing</category><body package="PickCell">getCell: point in: cellArray	| y cellLine x cell |	y := point y + 1.	y &lt;= cellArray size		ifTrue: 			[cellLine := cellArray at:   y.			x := point x + 1.			x &lt;= cellLine size				ifTrue: 					[cell := cellLine at:  x.					^cell]].	^nil</body><body package="PickCell">removeD: double	| str |	str := double printString.	^str copyFrom: 1 to: str size - 1</body><body package="PickCell">updateElevationCell: mapOrigin cellPoint: cellPoint mercator: gm	| pm cellArray cell cellImage elevationValue |	pm := self pickModel value.	cellArray := pm newCellArray.	cellArray isNil		ifFalse: 			[cell := self getCell: cellPoint in: cellArray.							cell isNil				ifFalse: [					cellImage := cell at:3.					elevationValue := cellImage elevation.					self elevation value:  elevationValue printString					]]</body><body package="PickCell">updateGeoUILocation: lonLatMap	uiLocation := self uiLocation.	uiLocation isNil		ifFalse: 			[self uiLocation leXGeo value: lonLatMap x printString.			self uiLocation leYGeo value: lonLatMap y printString]</body><body package="PickCell">updateLocForCell: mapOrigin cellPoint: cellPoint mercator: gm	| origin zoom cp m lonLatOrigin lonLatCorner |	origin := mapOrigin at: 1.	zoom := mapOrigin at: 2.	cp := origin + (cellPoint * self gridAspectPoint).	m := gm pixelToMeterNew: cp zoom: zoom.	lonLatOrigin := gm meterToLonLat: m.	cp := origin + self gridAspectPoint + (cellPoint * self gridAspectPoint).	m := gm pixelToMeterNew: cp zoom: zoom.	lonLatCorner := gm meterToLonLat: m.	self uiLocation isNil		ifFalse: [self uiLocation updateOrigin: lonLatOrigin corner: lonLatCorner]</body><body package="PickCell">updateLocFromMouse: mapOrigin mousePoint: mousePoint mercator: gm	| origin zoom cp m lonLatMap cell |	origin := mapOrigin at: 1.	zoom := mapOrigin at: 2.	cp := origin + mousePoint.	m := gm pixelToMeterNew: cp zoom: zoom.	lonLatMap := gm meterToLonLat: m.	self updateGeoUILocation: lonLatMap.	cell := self getCellAtMousePoint.	cell isNil		ifFalse: 			[cell elevation isNil 				ifFalse: [self uiLocation isNil ifFalse: [ self uiLocation elevation value: cell elevation printString]]].	self laLon value: (self removeD: lonLatMap x).	self laLat value: (self removeD: lonLatMap y)</body><body package="PickCell">updateUILocation: mouseCell	uiLocation := self uiLocation.	uiLocation isNil		ifFalse: 			[self uiLocation leX value: mouseCell x printString.			self uiLocation leY value: mouseCell y printString]</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>changes</category><body package="PickCell">changeForCloseKnownUrl	self knownUrlWindow isNil		ifFalse: 			[self knownUrlWindow closeRequest.			self knownUrlWindow: nil]</body><body package="PickCell">changeGrid	| point mercator mapOrigin |	point := self gridAspectPoint.	self pickModel value grid: point.	self pickModel value highLightCells: nil.	mercator := self pickModel value mercator.	mapOrigin := self pickModel value mapOrigin.	mapOrigin isNil		ifFalse: 			[self updateScaleFrom: mapOrigin mercator: mercator.			self laVue invalidate]</body><body package="PickCell">changePercent		| boundWidth percentage laPortee |	self pickModel value bounds isNil ifTrue: [^nil].	percentage := self percent value.	boundWidth := self pickModel value bounds width.	laPortee := (percentage * boundWidth / 100) asInteger.	self pickModel value portee: laPortee.	self portee retractInterestsFor: self.	self portee value: laPortee.	self portee onChangeSend: #changePortee to: self.	self updateGraph</body><body package="PickCell">changePortee	| boundWidth laPortee |	self pickModel value bounds isNil ifTrue: [^nil].	laPortee := self portee value.	self pickModel value portee: laPortee.	self percent value.	boundWidth := self pickModel value bounds width.	laPortee := (laPortee / boundWidth * 100) asInteger.	self percent retractInterestsFor: self.	self percent value: laPortee.	self percent onChangeSend: #changePercent to: self.	self updateGraph.	self uiCellShow isNil ifFalse: [self uiCellShow laVue invalidate]</body><body package="PickCell">changeUrl	| httpRequest replyTo image bounds pm button anUrl |	self knownUrlVH isNil		ifFalse: 			[anUrl := self knownUrlVH value.			anUrl isNil				ifFalse: 					[Cursor wait showWhile: 							[httpRequest := Net.HttpRequest get: anUrl url.							[replyTo := httpRequest execute] on: Net.HttpException								do: [:ex | replyTo := ex parameter].							image := self processReply: replyTo.							bounds := image bounds.							pm := self pickModel value.							pm filename: url.							pm points: OrderedCollection new.							pm bounds: bounds.							self pickModel value: pm.							self laVue image: image.							button := self builder componentAt: #Slider1.							button enable.							button widget invalidate.							button := self builder componentAt: #InputField1.							button enable.							button widget invalidate]]]</body><body package="PickCell">changeUrlHistory	| httpRequest replyTo image bounds pm button anUrl imageHistory nbLoop delai |	self knownUrlVH isNil		ifFalse: 			[anUrl := self knownUrlVH value.			anUrl isNil				ifFalse: 					[						nbLoop := 3.						delai := 100.						imageHistory := ImageHistory knownMapUrl: anUrl.						self storedHistory: imageHistory.						Cursor wait showWhile: 							[1 to: nbLoop								do: 									[:i |									httpRequest := Net.HttpRequest get: anUrl url.									[replyTo := httpRequest execute] on: Net.HttpException										do: [:ex | replyTo := ex parameter].									image := self processReply: replyTo.									bounds := image bounds.									imageHistory add: (Time now) -&gt; image.									pm := self pickModel value.									pm filename: url.									pm points: OrderedCollection new.									pm bounds: bounds.									self pickModel value: pm.									self laVue image: image.									button := self builder componentAt: #Slider1.									button enable.									button widget invalidate.									button := self builder componentAt: #InputField1.									button enable.									button widget invalidate.									(Delay forSeconds: delai) wait.]]]]</body><body package="PickCell">changedMousePoint	| mousePoint mouseCell mapOrigin gm |	gm := self pickModel value mercator.	mapOrigin := self pickModel value mapOrigin.	mousePoint := self pickModel value mousePoint value.	self pickModel value computeMouseCell.	mouseCell := self pickModel value mouseCell.	self updateUILocation: mouseCell.	mapOrigin isNil 		ifFalse: 			[self updateLocFromMouse: mapOrigin mousePoint: mousePoint mercator: gm.			self updateLocForCell: mapOrigin cellPoint: mouseCell mercator: gm.			self updateElevationCell: mapOrigin cellPoint: mouseCell mercator: gm]</body><body package="PickCell">computeLocationAtPoint: aPoint	| mapOrigin gm m cp zoom origin |	gm := self pickModel value mercator.	mapOrigin := self pickModel value mapOrigin.	mapOrigin isNil		ifFalse: 			[origin := mapOrigin at: 1.			zoom := mapOrigin at: 2.			cp := origin + aPoint.			m := gm pixelToMeterNew: cp zoom: zoom.			^gm meterToLonLat: m]</body><body package="PickCell">getCellAtMousePoint	| mouseCell cells line cell |	cells := self pickModel value newCellArray.	self pickModel value mousePoint value.	self pickModel value computeMouseCell.	mouseCell := self pickModel value mouseCell.	(mouseCell y &lt;= cells size and: [mouseCell y &gt; 0])		ifTrue: 			[line := cells at: mouseCell y.			(mouseCell x &lt;= line size and: [mouseCell x &gt; 0])				ifTrue: 					[cell := line at: mouseCell x.					^cell at: 3]].	^nil</body><body package="PickCell">gridAspectPoint	| text xText yText x y point |	text := self gridAspect value readStream.	xText := text upTo: $@.	yText := text upToEnd.	x := xText asNumber.	y := yText asNumber.	point := x @ y.	^point</body><body package="PickCell">updateGraph	| gc |	gc := self laVue graphicsContext.	self pickModel value buildGraph: gc.	self laVue invalidate.</body><body package="PickCell">updateScaleFrom: mapOrigin   mercator: mercator	| origin zoom cp meters op corner extent |	origin := mapOrigin at: 1.	zoom := mapOrigin at: 2.	cp := origin. 	meters := mercator pixelToMeterNew: cp zoom: zoom.	op := cp + self gridAspectPoint.	corner :=  mercator pixelToMeterNew: op zoom: zoom.	extent := corner - meters.	extent := extent x rounded abs @ extent y rounded abs.	self lEchelle value: extent printString.</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>aspects</category><body package="PickCell">elevation	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^elevation isNil		ifTrue:			[elevation := String new asValue]		ifFalse:			[elevation]</body><body package="PickCell">gridAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^gridAspect isNil		ifTrue:			[gridAspect := self pickModel value grid printString asValue]		ifFalse:			[gridAspect]</body><body package="PickCell">lEchelle	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lEchelle isNil		ifTrue:			[lEchelle := String new asValue]		ifFalse:			[lEchelle]</body><body package="PickCell">laLat	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laLat isNil		ifTrue:			[laLat := String new asValue]		ifFalse:			[laLat]</body><body package="PickCell">laLon	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laLon isNil		ifTrue:			[laLon := String new asValue]		ifFalse:			[laLon]</body><body package="PickCell">latitude	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^latitude isNil		ifTrue:			[latitude := 0 asValue]		ifFalse:			[latitude]</body><body package="PickCell">leSeuil	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leSeuil isNil ifTrue: [leSeuil := 0.1 asValue] ifFalse: [leSeuil]</body><body package="PickCell">longitude	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^longitude isNil		ifTrue:			[longitude := 0 asValue]		ifFalse:			[longitude]</body><body package="PickCell">parameters	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parameters isNil		ifTrue:			[parameters := String new asValue]		ifFalse:			[parameters]</body><body package="PickCell">percent	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^percent isNil		ifTrue:			[percent := 0 asValue]		ifFalse:			[percent]</body><body package="PickCell">portee	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^portee isNil		ifTrue:			[portee :=0 asValue]		ifFalse:			[portee]</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>initialize-release</category><body package="PickCell">initCellArray: aGrid	| lines |	lines := Array new: 100.	lines := lines collect: [:a | Array new: 100].	self pickModel value cellArray: lines.	^ lines</body><body package="PickCell">initialize	super initialize.	laVue := PickCellView new.	pickModel := PickCellModel new asValue.	self laVue model: self pickModel.	pickModel value cellDisplay: laVue.		self initializeShowMenu.	self portee onChangeSend: #changePortee to: self.	self percent onChangeSend: #changePercent to: self.	self portee value: 20.	self percent value: (20 / 398 * 100) asInteger.	self pickModel value portee: 20.	self pickModel value grid: 25 @ 25.	self initCellArray: self pickModel value grid.	self gridAspect onChangeSend: #changeGrid to: self.	self pickModel value mousePoint onChangeSend: #changedMousePoint to: self.</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>interface opening</category><body package="PickCell">postOpenWith: spec	"	uiLocation := UILocation new.	uiLocation open."	| pm name winTitle |	pm := self pickModel value.	pm grid: 25 @ 25.	self pickModel value: pm.	self changeGrid.	name := pm guessedName.	name isNil		ifTrue: [winTitle := 'Pickcell - ' , 'no name']		ifFalse: [winTitle := 'Pickcell - ' , name].	self builder window label: winTitle</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>database</category><body package="PickCell">appendData: user password: pass environment: env strSql: sql	| connection session answer |	connection := PostgresSocketConnection new.	connection		username: user;		password: pass;		environment: env.	connection connect.	session := connection getSession.	session		prepare: sql;		execute.	answer := session answer.	connection disconnect.	^answer</body><body package="PickCell">retrieveData1: user password: pass environment: env strSql: sql	| connection session answer row trackPoints aPoint |	connection := PostgresSocketConnection new.	connection		username: user;		password: pass;		environment: env.	connection connect.	session := connection getSession.	session		prepare: sql;		execute.	trackPoints := OrderedCollection new.	answer := session answer.	[answer atEnd] whileFalse: 			[row := answer next.			aPoint := Array with: (row at: 1) with: (row at: 2).			trackPoints add: aPoint].	connection disconnect.	^trackPoints</body><body package="PickCell">retrieveData: user password: pass environment: env strSql: sql	| connection session answer row trackPoints aPoint |	connection := PostgresSocketConnection new.	connection		username: user;		password: pass;		environment: env.	connection connect.	session := connection getSession.	session		prepare: sql;		execute.	trackPoints := OrderedCollection new.	answer := session answer.	[answer atEnd] whileFalse: 			[row := answer next.			aPoint := Array new: 5.			aPoint at: 1 put: (row at: 1).			aPoint at: 2 put: (row at: 2).			aPoint at: 3 put: (row at: 3).			aPoint at: 4 put: (row at: 4).			aPoint at: 5 put: (row at: 5).			trackPoints add: aPoint].	connection disconnect.	^trackPoints	"trackPoints := TrackPoint new.	answer := session answer.	[answer atEnd] whileFalse: 			[row := answer next.			trackPoints from: row].	connection disconnect.	^trackPoints"</body><body package="PickCell">retrieveOsmData: user password: pass environment: env strSql: sql	| connection session answer row values osmData |	connection := PostgresSocketConnection new.	connection		username: user;		password: pass;		environment: env.	connection connect.	session := connection getSession.	session		prepare: sql;		execute.	osmData := OrderedCollection new.	answer := session answer.	[answer atEnd] whileFalse: 			[row := answer next.			values := Array with: (row at: 1) with: (row at: 2).			osmData add: values].	connection disconnect.	^osmData</body><body package="PickCell">testAppend	| sqlCmd pm |	pm := UIPickCellNodes new.	"sqlCmd := 'Select osm_id, way from planet_osm_vn_polygonwater where osm_id=''143516289'''."	sqlCmd := 'INSERT INTO RECOCO(ID, NODEID, TIME, LAT, LON, ALT, RSSI) VALUES( 10, ''ID3'', ''01:02:03'', 8.123456789, -4.598765432, 70.1, -91)'.	pm		appendData: 'osm'		password: 'fare&amp;bali'		environment: '172.12.18.159:5432_vietnamTuyen'		strSql: sqlCmd.	"environment: '172.12.18.159:5432_vietnambao2'"	^pm</body><body package="PickCell">testAppend1	| sqlCmd pm |	pm := UIPickCellNodes new.	"sqlCmd := 'Select osm_id, way from planet_osm_vn_polygonwater where osm_id=''143516289'''."	"sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES( ''ID3, 01:02:03, 48.1234N, 004.5987W, 70.1, -91'')'."	sqlCmd :='INSERT INTO recoco6(nodeid, time, lat, lon, alt, rssi) VALUES(''ID1'', '' 14:08:52'', ''48.383598333333'', ''-4.3960966666667'', '' 32.8'', '' -52'')'.	 "'INSERT INTO recoco6(nodeid, time, lat, lon, alt, rssi) VALUES(''ID1'', '' 14:09:16'', ''48.383598333333'', ''-4.3960966666667'', '' 32.8'', '' -46'')'."	pm		appendData: 'osm'		password: 'fare&amp;bali'		environment: '172.12.18.159:5432_vietnamTuyen'		strSql: sqlCmd.	"environment: '172.12.18.159:5432_vietnambao2'"	^pm</body><body package="PickCell">testAppend2	| sqlCmd pm |	pm := UIPickCellNodes new.	"sqlCmd := 'Select osm_id, way from planet_osm_vn_polygonwater where osm_id=''143516289'''."	sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES( ''ID3, 01:02:03, 48.1234N, 004.5987W, 70.1, -91'')'.	pm		appendData: 'osm'		password: 'fare&amp;bali'		environment: 'wsn.univ-brest.fr:8080_vietnamTuyen'		strSql: sqlCmd.	"environment: '172.12.18.159:5432_vietnambao2'"	^pm</body><body package="PickCell">testDBConnection	| sqlCmd pm |	pm := UIPickCellNodes new.	"sqlCmd := 'Select osm_id, way from planet_osm_vn_polygonwater where osm_id=''143516289'''."	sqlCmd := 'SELECT NODEID, TIME, LAT, LON, ALT, RSSI FROM RECOCO'.	pm		retrieveData: 'osm'		password: 'fare&amp;bali'		environment: '172.12.18.159:5432_vietnamTuyen'		strSql: sqlCmd.	"environment: '172.12.18.159:5432_vietnambao2'"	^pm</body><body package="PickCell">testDBConnection1	| string pm |	pm := UIPickCellNodes new.	string := 'Select osm_id, way from planet_osm_vn_polygonwater where osm_id=''143516289'''.	pm		retrieveData1: 'osm'		password: 'fare&amp;bali'		environment: '172.12.18.159:5432_vietnambao2'		strSql: string.	^pm</body><body package="PickCell">testGetData	| usb bufferPointer numChar ws buffer portOk points trackPoint trackingInterface |		trackingInterface := GPSTrackingInterface new.	trackingInterface open.		self		getData: 			[USBSerial unloadLibraries.			usb := USBSerial new.			usb initialize.			points := OrderedCollection new.			usb RS232_CloseComport: 27.			Transcript				show: Time now printString;				cr.			buffer := String new: 4096.			bufferPointer := buffer gcCopyToHeap.			portOk := usb						setReadBuf: bufferPointer						with: 4095						with: 27						with: 38400.			usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 38400.		"	trackingInterface := GPSTrackingInterface new.			trackingInterface open.			status := trackingInterface getStatus.			[status = 1] whileFalse: 					[(Delay forSeconds: 30) wait.					status := trackingInterface getStatus]."			portOk = 0				ifFalse: 					[Transcript						show: 'Open serial interface error';						cr]				ifTrue: 					[[true] whileTrue: 							[numChar := usb										readBuf: bufferPointer										with: 4095										with: 27										with: 38400.							ws := String new writeStream.							0 to: numChar - 1								do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].							Transcript								show: numChar printString;								tab;								show: ws contents.							trackPoint := TrackPoint from: ws contents.							trackPoint isNil ifFalse: [points add: trackPoint].							(Delay forSeconds: 1) wait.							"status := trackingInterface getStatus"].					usb RS232_CloseComport: 27.					"trackingInterface window close"].			^points]					fork</body><body package="PickCell">testOsmRetrieve	| sqlCmd pm |	pm := UIPickCellNodes new.	sqlCmd := 'SELECT osm_id, landuse FROM planet_osm_polygon'.	pm		retrieveOsmData: 'osm'		password: 'fare&amp;bali'		environment: '172.12.18.159:5432_vietnamTuyen'		strSql: sqlCmd.	^pm</body><body package="PickCell">testRetrieve	| sqlCmd pm |	pm := UIPickCellNodes new.	sqlCmd := 'SELECT NODEID, TIME, LAT, LON, ALT, RSSI FROM RECOCO'.	pm		retrieveOsmData: 'osm'		password: 'fare&amp;bali'		environment: '172.12.18.159:5432_vietnamTuyen'		strSql: sqlCmd.	^pm</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>statistics</category><body package="PickCell">statisticsVPoints	| simulationPoints actualPoints sPointX sPointY aPointX aPointY offset vNumPoint allNumPoint |	simulationPoints := OrderedCollection new.	"handle := UIPickCellNodes new."	simulationPoints := self doCoverageStatistics2.	actualPoints := OrderedCollection new.	actualPoints := self visiblePointsStatistics2.	self halt.	vNumPoint := 0.	allNumPoint := actualPoints size.	1 to: actualPoints size		do: 			[:i |			| aPoint check |			aPoint := actualPoints at: i.			check := 0.			1 to: actualPoints size				do: 					[:j |					| sPoint |					sPoint := simulationPoints at: j.					sPointX := sPoint at: 1.					sPointY := sPoint at: 2.					aPointX := aPoint at: 1.					aPointY := aPoint at: 2.					offset := ((aPointX - sPointX) squared + (aPointY - sPointY) squared) sqrt.					offset &lt; (1 / 5) ifTrue: [check := check + 1]].			check &gt; 0 ifTrue: [vNumPoint := vNumPoint + 1]].	percent := vNumPoint / allNumPoint.	Dialog warn: 'Statistic result: ' , percent printString.	^percent asDouble</body><body package="PickCell">statisticsVPointsBK	| simulationPoints actualPoints correct textSPoint textAPoint |	simulationPoints := OrderedCollection new.	"handle := UIPickCellNodes new."	simulationPoints := self doCoverageStatistics.	actualPoints := OrderedCollection new.	actualPoints := self visiblePointsStatistics.	correct := 0.	1 to: actualPoints size		do: 			[:i |			| aPoint |			aPoint := actualPoints at: i.			1 to: actualPoints size				do: 					[:j |					| sPoint |					sPoint := simulationPoints at: j.					textSPoint := sPoint printString.					textAPoint := aPoint printString.					(textAPoint sameAs: textSPoint) ifTrue: [correct := correct + 1]]].	"percent := actualPoints / simulationPoints."	Dialog warn: 'Statistic result: ' , percent printString.	^percent</body></methods><methods><class-id>AlgoDis.UIPickCellNodes</class-id> <category>interface closing</category><body package="PickCell">closeRequest	self doGetGPS terminate.	self doGetGPS: nil.	self laVue controller addAGPSPoint: nil.	self laVue controller terminate.	self doShowGPS terminate.	self doShowGPS: nil.	self uiLocation closeRequest</body></methods><methods><class-id>AlgoDis.UIPickCellNodes class</class-id> <category>Urls</category><body package="PickCell">knownUrls	KnownUrls isNil ifTrue: [KnownUrls := OrderedCollection with: 'http://dataweb.bmkg.go.id/MEWS/Radar/Citra_Radar_TANG.png'].	^KnownUrls</body></methods><methods><class-id>AlgoDis.UIPickCellNodes class</class-id> <category>Tools</category><body package="PickCell">convertDouble: aString	^aString asNumber</body><body package="PickCell">convertValue: aString	^aString asNumber</body><body package="PickCell">doShowCoverage	| aName filename rs nodeid time lat lon rssi alt latString lonString rName wFile ws cellPos values |	cellPos := OrderedCollection new.	rName := 'pointsDisplay.txt'.	wFile := rName asFilename.	ws := wFile writeStream.	aName := 'trackGPSPoints.txt'.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							values := Array								with: lat								with: lon								with: alt								with: rssi.								cellPos add: values 							]].			rs close].		self pickModel isNil		ifFalse: 			[self pickModel processElevations: cellPos.			self pickModel guessedName: self guessedName].	^cellPos</body><body package="PickCell">doUploadBSTrack	| aName filename rs pm sqlCmd nodeid time lat lon rssi alt latString lonString |	pm := UIPickCellNodes new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							sqlCmd := 'INSERT INTO recoco_may182017(nodeid, time, lat, lon, alt, rssi) VALUES('''										, nodeid , ''','''										, time , ''','''										, lat , ''','''										, lon , ''','''										, alt , ''','''										, rssi , ''')'.							pm								appendData: 'osm'								password: 'fare&amp;bali'								environment: '172.12.18.159:5432_france'								strSql: sqlCmd]].			rs close].	^nil</body><body package="PickCell">doUploadFields	| aName filename rs pm sqlCmd nodeid time lat lon rssi alt latString lonString |	pm := UIPickCellNodes new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							sqlCmd := 'INSERT INTO recoco_may182017(nodeid, time, lat, lon, alt, rssi) VALUES('''										, nodeid , ''','''										, time , ''','''										, lat , ''','''										, lon , ''','''										, alt , ''','''										, rssi , ''')'.							pm								appendData: 'osm'								password: 'fare&amp;bali'								environment: '172.12.18.159:5432_france'								strSql: sqlCmd]].			rs close].	^nil</body><body package="PickCell">doUploadMobileTrack	| aName filename rs pm sqlCmd nodeid time lat lon alt latString lonString |	pm := UIPickCellNodes new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: Character cr.							sqlCmd := 'INSERT INTO mobile_june92017(nodeid, time, lat, lon, alt) VALUES('''										, nodeid , ''','''										, time , ''','''										, lat , ''','''										, lon , ''','''										, alt , ''')'.							pm								appendData: 'osm'								password: 'fare&amp;bali'								environment: '172.12.18.159:5432_france'								strSql: sqlCmd]].			rs close].	^nil</body><body package="PickCell">parseLat: aString	| ls n ch entier decimal number numberString north |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	north := aString last = $N.	north ifFalse: [number := number negated].	numberString:= number printString.	number:= numberString copyFrom: 1 to: numberString size - 1.	^number</body><body package="PickCell">parseLon: aString	| ls n ch entier decimal number numberString west |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	west := aString last = $W.	west ifTrue: [number := number negated].	numberString:= number printString.	number:= numberString copyFrom: 1 to: numberString size - 1.	^number</body><body package="PickCell">showPointsFromLogFile	| aName filename rs nodeid time lat lon rssi alt latString lonString aPoint map |	aPoint := TrackPoint new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := rs upTo: $,.							rssi := rs upTo: Character cr.							aPoint								id: nodeid;								lon: lon;								lat: lat;								rssi: rssi.							map := self laVue new.							map controller addAGPSPoint: aPoint]].			rs close].	^nil</body></methods><methods><class-id>AlgoDis.UIPickCellNodes class</class-id> <category>testing</category><body package="PickCell">test1self convertValue: '12.125633d'.</body></methods><methods><class-id>UIMapsv0</class-id> <category>aspects</category><body package="Mapsv0">doDisplayNetwork	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^doDisplayNetwork isNil		ifTrue:			[doDisplayNetwork := true asValue]		ifFalse:			[doDisplayNetwork]</body><body package="Mapsv0">doDisplayNodeName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^doDisplayNodeName isNil		ifTrue:			[doDisplayNodeName := false asValue]		ifFalse:			[doDisplayNodeName]</body><body package="Mapsv0">doDisplayRange	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^doDisplayRange isNil		ifTrue:			[doDisplayRange := true asValue]		ifFalse:			[doDisplayRange]</body><body package="Mapsv0">labelPosition	^'0@0'</body><body package="Mapsv0">latitude	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^latitude isNil		ifTrue:			[latitude := 0 asValue]		ifFalse:			[latitude]</body><body package="Mapsv0">longitude	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^longitude isNil		ifTrue:			[longitude := 0 asValue]		ifFalse:			[longitude]</body><body package="Mapsv0">networkList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^networkList isNil		ifTrue:			[networkList := MultiSelectionInList new]		ifFalse:			[networkList]</body><body package="Mapsv0">nodePName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nodePName isNil		ifTrue:			[nodePName := String new asValue]		ifFalse:			[nodePName]</body><body package="Mapsv0">range	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^range isNil		ifTrue:			[range := 100 asValue]		ifFalse:			[range]</body><body package="Mapsv0">xTile	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^xTile isNil		ifTrue:			[xTile := 0 asValue]		ifFalse:			[xTile]</body><body package="Mapsv0">yTile	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^yTile isNil		ifTrue:			[yTile := 0 asValue]		ifFalse:			[yTile]</body><body package="Mapsv0">zoom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^zoom isNil		ifTrue:			[zoom := 0 asValue]		ifFalse:			[zoom]</body></methods><methods><class-id>UIMapsv0</class-id> <category>initialize-release</category><body package="Mapsv0">changeDrawingParameters	(self drawingParameters)		drawCircle: self doDisplayRange value;		drawNetwork: self doDisplayNetwork value;		drawName: self doDisplayNodeName value</body><body package="Mapsv0">initialize"	googleModel := GoogleMap new.	googleModel matrixTile: Dictionary new."	googleModel := Mapsv0 new.	googleModel matrixTile: (Dictionary withKeysAndValues: #(#x 0 #y 0 #zoom 0)).	googleModel := googleModel asValue.	tileView := Mapsv0View new.	tileView application: self.	self tileImage: nil asValue.	tileView model: googleModel.	tileView controller: Mapsv0Controller new.	tileView controller application: self.	self xTile value: 16035.	"998."	self yTile value: 11982.	"708."	self zoom value: 15.	"11."	oldZoom := self zoom value.	self zoom onChangeSend: #changeZoom to: self.	clicPointVH := (0 @ 0) asValue.	lesPointsVH := OrderedCollection new asValue.	lesPointsGPSVH := OrderedCollection new asValue.	self clicPointVH onChangeSend: #mapClic to: self.	googleModel onChangeSend: #GPSColToPixelCol to: self.	mercator := GlobalMercator new.	self initializeDrawingParameters.	googleModel value range: self range value.	labelPosVH := '0@0' asValue.	self labelPosVH onChangeSend: #changeLabelPos to: self.	self nodePName onChangeSend: #changeMousePositionFromName to: self</body><body package="Mapsv0">initializeDrawingParameters	drawingParameters := DrawingParameters new.	self doDisplayRange onChangeSend: #changeDrawingParameters to: self.	self doDisplayNetwork onChangeSend: #changeDrawingParameters to: self.	self doDisplayNodeName onChangeSend: #changeDrawingParameters to: self.	self range onChangeSend: #changeRange to: self</body></methods><methods><class-id>UIMapsv0</class-id> <category>constant</category><body package="Mapsv0">displaySize	^2 @ 2</body><body package="Mapsv0">maxZoom	^21</body><body package="Mapsv0">minZoom	^0</body></methods><methods><class-id>UIMapsv0</class-id> <category>converting</category><body package="Mapsv0">absolutePointFor: aPoint	^aPoint translatedBy: googleModel value originOffset</body><body package="Mapsv0">absolutePointForName: aName	| pickModel pointDictionary uneAssoc |	pickModel := self googleModel value pickModelTmp.	pointDictionary := pickModel pointDictionary.	pointDictionary isNil ifTrue: [^nil].	uneAssoc := pointDictionary associations				detect: [:asso | asso value = aName].	uneAssoc isNil ifFalse: [^uneAssoc key]</body><body package="Mapsv0">nameForAbsolutePoint: aPoint	| pickModel pointDictionary aProcessName |	pickModel := self googleModel value pickModelTmp.	pointDictionary := pickModel pointDictionary.	pointDictionary isNil ifTrue: [^nil].	aProcessName := pointDictionary at: aPoint ifAbsent: [^nil].	^aProcessName</body><body package="Mapsv0">nameForRelativePoint: aPoint	| pickModel pointDictionary aProcessName absolutePoint |	absolutePoint := self relativePointFor: aPoint.	pickModel := self googleModel value pickModelTmp.	pointDictionary := pickModel pointDictionary.	pointDictionary isNil ifTrue: [^nil].	aProcessName := pointDictionary at: absolutePoint ifAbsent: [^nil].	^aProcessName</body><body package="Mapsv0">relativePointFor: aPoint	^aPoint translatedBy: googleModel value originOffset negated</body><body package="Mapsv0">relativePointForName: aName	^self relativePointFor: (self absolutePointForName: aName)</body></methods><methods><class-id>UIMapsv0</class-id> <category>actions</category><body package="Mapsv0">buildNet	| view gc netAndDicoAndComposite gp pickModel |	"self halt."	self updatePickModel.	pickModel := googleModel value pickModelTmp.	pickModel colNodes: googleModel value colNodes.	pickModel filename: 'santander.net'.	view := self tileView.	gc := view graphicsContext.	gp := self drawingParameters.	IncrementNotification raiseSignal.	netAndDicoAndComposite := pickModel buildNetAndDisplayOn: gc graphicParameters: gp.	IncrementNotification raiseSignal.	self updateGeneratorsWith: netAndDicoAndComposite first.	IncrementNotification raiseSignal.	pickModel lastGraph: netAndDicoAndComposite last.	pickModel pointDictionary: (netAndDicoAndComposite at: 2).	googleModel value: googleModel value</body><body package="Mapsv0">buildNetAndSimulators	| view gc netAndDicoAndComposite gp pickModel |	Notice		showProgress: 'Building simulation files...'		complete: 3		while:  			["self halt."			self updatePickModel.			pickModel := googleModel value pickModelTmp.			pickModel colNodes: googleModel value colNodes.			pickModel filename: 'santander.net'.			view := self tileView.			gc := view graphicsContext.			gp := self drawingParameters.			IncrementNotification raiseSignal.			netAndDicoAndComposite := pickModel buildNetAndDisplayOn: gc graphicParameters: gp.			IncrementNotification raiseSignal.			self googleModel value updateGeneratorsWith: netAndDicoAndComposite first.			IncrementNotification raiseSignal.			pickModel lastGraph: netAndDicoAndComposite last.			pickModel pointDictionary: (netAndDicoAndComposite at: 2).			"googleModel value: googleModel value"]		title: 'Computing'</body><body package="Mapsv0">doBuildNet	"This stub method was generated by UIDefiner"	Notice		showProgress: 'Building and drawing nets...'		complete: 3		while: [self buildNet]		title: 'Computing'</body><body package="Mapsv0">doChooseColorFor: componentColor questionString: questionString	"This stub method was generated by UIDefiner"	| outerColor newColor colorName newColorName |	outerColor := self drawingParameters perform: componentColor.	colorName := outerColor class constantNameFor: outerColor.	newColorName := Dialog request: questionString initialAnswer: colorName asString.	newColorName isEmpty		ifFalse: 			[newColor := ColorValue perform: newColorName asSymbol.			outerColor := self drawingParameters perform: (componentColor asString , ':') asSymbol with: newColor]</body><body package="Mapsv0">doChooseNameColor	"This stub method was generated by UIDefiner"	self doSelectionColorFor: #nameColor updateButton: #ChooseNameColor</body><body package="Mapsv0">doChooseNetworkColor	"This stub method was generated by UIDefiner"	self doSelectionColorFor: #networkColor updateButton: #ChooseNetworkColor</body><body package="Mapsv0">doChooseRangeColor	"This stub method was generated by UIDefiner"	self doSelectionColorFor: #outerCircleColor updateButton: #ChooseRangeColor</body><body package="Mapsv0">doExportGpx	"This stub method was generated by UIDefiner"	| gpxFilename ws |	gpxFilename := Dialog				requestFileNameWithMessage: 'Export network to GPX file'				default: '*.gpx'				version: #new				ifFail: [^'']				for: nil.	ws := gpxFilename asFilename newReadWriteStream.	ws nextPutAll: '&lt;?xml version="1.0" encoding="utf-8"?&gt;'.	ws cr.	googleModel value asGpxDocument printOn: ws.	ws close</body><body package="Mapsv0">doOffsetTile: offset	self yTile value: self yTile value + (offset y).	self xTile value: self xTile value + (offset x)</body><body package="Mapsv0">doOpenGPX	"This stub method was generated by UIDefiner"	| gpxFilename |	Notice		showProgress: 'Fetching data from Smart Santander...'		complete: 3		while: 			[Mapsv0Utilities htmlForSantander.			IncrementNotification raiseSignal.			Mapsv0Utilities testForGPX.			IncrementNotification raiseSignal.			gpxFilename := Mapsv0Utilities defaultGPXName.			self parseGPXFileOrString: gpxFilename.			IncrementNotification raiseSignal]		title: 'Fetching data'</body><body package="Mapsv0">doOpenGPXOnFile	"This stub method was generated by UIDefiner"	| gpxFilename |	gpxFilename := Dialog				requestFileNameWithMessage: 'Browse GPX file'				default: '*.gpx'				version: #mustBeOld				ifFail: [^'']				for: nil.	Notice show: 'In progress' while: [self parseGPXFileOrString: gpxFilename]</body><body package="Mapsv0">doOpenPickcell	"This stub method was generated by UIDefiner"	| box uiPickCell pm image origin image32 pixel |	box := self builder componentAt: #TileViewHolder.	origin := self builder window displayBox origin.	box := box bounds translatedBy: origin.	image := Screen default completeContentsOfArea: box.	uiPickCell := UIPickCellNodes new.	pm := uiPickCell pickModel value.	pm filename: nil. 	pm bounds: box.	pm mapOrigin: self mapOrigin.	uiPickCell pickModel value: pm. 	image32 := Image				extent: image extent				depth: image depth				palette: image palette.	image pixelsDo: 			[:x :y |			pixel := image valueAtPoint: x @ y.			image32 valueAtPoint: x @ y put: pixel].	uiPickCell laVue image: image32.	"	self tileView displayOn: image asRetainedMedium graphicsContext."	uiPickCell open</body><body package="Mapsv0">doPickNetwork	"This stub method was generated by UIDefiner"	| |	gpxPickFilename := Dialog				requestFileNameWithMessage: 'Save network into GPX file'				default: '*.gpx'				version: #mustBeNew				ifFail: [^'']				for: nil.	uiState := #picking</body><body package="Mapsv0">doPickPoint	"This stub method was generated by UIDefiner"	| lon lat meter currentTileDico currentZoom currentTileX currentTileY pixel mapX mapY circle filledCircle comp strokedCircle nodePos node |	lon := self longitude value.	lat := self latitude value "negated".	"rr"	currentTileDico := googleModel value matrixTile.	currentZoom := currentTileDico at: #zoom.	"currentTileX := currentTileDico at: #x.	currentTileY := currentTileDico at: #y."	"mapX := pixel x - (currentTileX * 256).	mapY := pixel y - (currentTileY * 256)."	"tt"	self lesPointsGPSVH value add: lon @ lat.	"noeud objet"	nodePos := NetworkPosition lon: lon lat: lat.	meter := self mercator latLonToMeter: lat lon: lon.	pixel := self mercator meterToPixelNew: meter zoom: currentZoom.	nodePos metre: meter.	nodePos setCurrentZoom: currentZoom.	nodePos currentTile: currentTileDico.	nodePos pixelDico at: currentZoom put: pixel.	nodePos mercator: self mercator.	nodePos model: googleModel.	node := AlgoDis.NetworkNodeLocalized pos: nodePos.	self colPickNodes do: 			[:each |			| nd |			nd := NetworkDistance distanceNode: each withNode: node.			googleModel value distanceSet add: nd.			(googleModel value dicoNodeDistance at: each ifAbsentPut: [SortedCollection new]) add: nd.			(googleModel value dicoNodeDistance at: node ifAbsentPut: [SortedCollection new]) add: nd].	self colPickNodes add: node.	"(mapX @ mapY) inspect."	"circle := Circle center: mapX @ mapY radius: 50."	"filledCircle := circle asFiller."	"strokedCircle := circle asStroker.	comp := (GraphicsAttributesWrapper on: strokedCircle) attributes: (GraphicsAttributes new paint: (ColorValue perform: #black))."	"comp inspect."	"self lesPointsVH value add: comp."	self tileView invalidate.	^self</body><body package="Mapsv0">doPlacePoint	"This stub method was generated by UIDefiner"	| lon lat meter currentZoom pixel currentTileDico currentTileX currentTileY mapX mapY circle filledCircle comp |	lon := self longitude value.	lat := self latitude value "negated".	meter := self mercator latLonToMeter: lat lon: lon.	currentTileDico := self matrixTile value.	currentZoom := currentTileDico at: #zoom.	currentTileX := currentTileDico at: #x.	currentTileY := currentTileDico at: #y.	pixel := self mercator meterToPixelNew: meter zoom: currentZoom.	mapX := pixel x - (currentTileX * 256).	mapY := pixel y - (currentTileY * 256).	"(mapX @ mapY) inspect."	circle := Circle center: mapX @ mapY radius: 20.	filledCircle := circle asFiller.	comp := (GraphicsAttributesWrapper on: filledCircle) attributes: (GraphicsAttributes new paint: (ColorValue perform: #white)).	"comp inspect."	self lesPointsVH value add: comp.	self tileView invalidate.	^self</body><body package="Mapsv0">doQuit	"This stub method was generated by UIDefiner"	self closeRequest.	"Dialog warn: 'Click the ''x'' in the upper right corner!'"</body><body package="Mapsv0">doReset	"This stub method was generated by UIDefiner"	self zoom retractInterestsFor: self.	"self xTile value: 998.	self yTile value: 708.	self zoom value: 11."	self xTile value: 16035.	self yTile value: 11982.	self zoom value: 15.	self oldZoom: 15.	self zoom onChangeSend: #changeZoom to: self</body><body package="Mapsv0">doSelectionColorFor: componentColor	"This stub method was generated by UIDefiner"	| csd oldColor newColor |	oldColor := self drawingParameters perform: componentColor.	csd := ColorSelectionDialog new.	csd selection: oldColor.	csd open.	newColor := csd selection.	csd accept value		ifTrue: 			[self drawingParameters perform: (componentColor asString , ':') asSymbol				with: newColor.			^newColor]		ifFalse: [^nil]</body><body package="Mapsv0">doSelectionColorFor: componentColor updateButton: aSymbol	"This stub method was generated by UIDefiner"	| csd oldColor newColor |	oldColor := self drawingParameters perform: componentColor.	csd := ColorSelectionDialog new.	csd selection: oldColor.	csd open.	newColor := csd selection.	csd accept value		ifTrue: 			[| bc |			self drawingParameters perform: (componentColor asString , ':') asSymbol with: newColor.			"change the button color"			bc := self builder componentAt: aSymbol.			bc spec colors setBackgroundColor: newColor.			bc widget invalidate]</body><body package="Mapsv0">doUpdateTile	"This stub method was generated by UIDefiner"	| tileX tileY tileZoom dico map |	tileX := self xTile value.	tileY := self yTile value.	tileZoom := self zoom value.	dico := Dictionary new.	dico		at: #x put: tileX;		at: #y put: tileY;		at: #zoom put: tileZoom.	map := googleModel value.	map matrixTile: dico.	googleModel value: map.	^self</body><body package="Mapsv0">doViewTile	"This stub method was generated by UIDefiner"	self doUpdateTile</body><body package="Mapsv0">doZoomIn	| z |	z := self zoom value.	z = self maxZoom ifFalse: [self zoom value: z + 1]</body><body package="Mapsv0">doZoomInDownLeft	self doZoomIn.	self yTile value: self yTile value + 1</body><body package="Mapsv0">doZoomInDownRight	self doZoomInDownLeft.	self xTile value: self xTile value + 1</body><body package="Mapsv0">doZoomInOffset: offset	self zoom retractInterestsFor: self.	self doZoomIn.	self changeZoom.	self doOffsetTile: offset.	self zoom onChangeSend: #changeZoom to: self</body><body package="Mapsv0">doZoomInUpLeft	self doZoomIn</body><body package="Mapsv0">doZoomInUpRight	self doZoomInUpLeft.	self xTile value: self xTile value + 1</body><body package="Mapsv0">doZoomOut	| z |	z := self zoom value.	z = 0 ifFalse: [self zoom value: z - 1]</body><body package="Mapsv0">parseGPXFileOrString: gpxFilename	| docFile doc colWayPoint colGPSPos colNodes no bn xmlMetadata symList collection |	docFile := gpxFilename asFilename.	doc := (XML.XMLParser new)				validate: false;				parse: docFile.	xmlMetadata := doc document root elementNamed: 'metadata'.	googleModel value xmlMetadata: xmlMetadata.	colWayPoint := doc document root elementsNamed: 'wpt'.	colGPSPos := colWayPoint collect: 					[:wp |					| attrLat attrLon lat lon |					attrLat := wp attributes detect: [:attr | attr tag type = 'lat'].					lat := attrLat value asNumber asFixedPoint: 5.					attrLon := wp attributes detect: [:attr | attr tag type = 'lon'].					lon := attrLon value asNumber asFixedPoint: 5.					lon @ lat].	colNodes := colWayPoint collect: 					[:wp |					| attrLat attrLon lat lon np nnl sym name n time desc cmt |					attrLat := wp attributes detect: [:attr | attr tag type = 'lat'].					lat := attrLat value asNumber asFixedPoint: 5.					attrLon := wp attributes detect: [:attr | attr tag type = 'lon'].					lon := attrLon value asNumber asFixedPoint: 5.					np := NetworkPosition lon: lon lat: lat.					np model: googleModel.					np mercator: mercator.					nnl := AlgoDis.NetworkNodeLocalized pos: np.					sym := (wp elementNamed: 'sym') elements first text.					n := (wp elementNamed: 'name') elements first text.					collection := wp elementsNamed: 'time'.					collection isEmpty						ifTrue: 							[time := XML.Element tag: 'time'										elements: (Array with: (XML.Text text: 'nil'))]						ifFalse: [time := collection first].					collection := wp elementsNamed: 'desc'.					collection isEmpty						ifTrue: 							[desc := XML.Element tag: 'desc'										elements: (Array with: (XML.Text text: 'nil'))]						ifFalse: [desc := collection first].					collection := wp elementsNamed: 'cmt'.					collection isEmpty						ifTrue: 							[cmt := XML.Element tag: 'cmt'										elements: (Array with: (XML.Text text: 'nil'))]						ifFalse: [cmt := collection first].					"name := n copyAfter: $ ."					n replaceAll: $: with: $-.					n replaceAll: $  with: $_.					name := n.					nnl sym: sym.					nnl name: name.					nnl range: 100.					nnl time: time.					nnl desc: desc.					nnl cmt: cmt.					nnl].	symList := (colNodes collect: [:n | n sym]) asSet asOrderedCollection.	self networkList list: symList.	self networkList selectAll.	googleModel value colNodes: colNodes asOrderedCollection.	googleModel value computeDistance.	googleModel value sortDistanceByNode.	googleModel value selectReachedNodes.	no := NetworkOrganisation				withReachedNodes: googleModel value dicoReachedNodes.	bn := no buildNetwork.	"bn inspect."	"self halt."	self lesPointsGPSVH value: colGPSPos.	self GPSColToPixelCol</body><body package="Mapsv0">updateGeneratorsWith: net	| uiGenerators connectivity mp pm m fakeSteps firstPoint offset |	uiGenerators := AlgoDis.UINetworkGeometry allInstances.	offset := googleModel value originOffset.	pm := googleModel value pickModelTmp.	pm originOffset: offset.	m := AlgoDis.Mobile trajectory: (AlgoDis.Trajectory position: (Point x: 10 y: 10) movement: (Point x: 10 y: 10)) range: pm portee "1000".	fakeSteps := pm steps. "OrderedCollection new."	"firstPoint := offset + (500 @ 500).	fakeSteps add: firstPoint.	1 to: 100 do: [:i | firstPoint := firstPoint + (10 @ 10). fakeSteps add: firstPoint]."	"fakeSteps add: 83100 @ 105100 ; add: 116 @ 145 ; add: 178 @ 150 ; add: 218 @ 147 ; add: 273 @ 147 ; add: 347 @ 152 ; add: 381 @ 153 ; add: 412 @ 154 ; add: 435 @ 174 ; add: 443 @ 221 ; add: 437 @ 289 ; add: 398 @ 327 ; add: 263 @ 324 ; add: 227 @ 323."	mp := AlgoDis.MobilePath mobile: m steps: "pm steps" fakeSteps.	uiGenerators isEmpty		ifTrue: 			[AlgoDis.UINetworkGeometry new."new au lieu de open "			uiGenerators := AlgoDis.UINetworkGeometry allInstances].	uiGenerators do: 			[:aGenerator |			connectivity := net buildNetworkLocalized.			"On enleve cela qui ne marche pas avec new ci dessus : aGenerator leStyle value:  #forSensors."			aGenerator theNbSystems value: net points size.			aGenerator theRadius value: googleModel value pickModelTmp portee.			aGenerator theSize value: googleModel value pickModelTmp bounds width.			aGenerator doGraphic value: true.			aGenerator execManager mobilePath: mp copy.			aGenerator execManager aPickModel:  pm copy.			aGenerator leCode value: connectivity printString]</body></methods><methods><class-id>UIMapsv0</class-id> <category>actions-moving</category><body package="Mapsv0">doChangeDownLeftTile	"This stub method was generated by UIDefiner"	self xTile value: self xTile value - 1.	self yTile value: self yTile value + 1.	self doViewTile</body><body package="Mapsv0">doChangeDownRightTile	"This stub method was generated by UIDefiner"	self xTile value: self xTile value + 1.	self yTile value: self yTile value + 1.	self doViewTile</body><body package="Mapsv0">doChangeDownTile	"This stub method was generated by UIDefiner"	self yTile value: self yTile value + 1.	self doViewTile</body><body package="Mapsv0">doChangeLeftTile	"This stub method was generated by UIDefiner"	self xTile value: self xTile value - 1.	self doViewTile</body><body package="Mapsv0">doChangeRightTile	"This stub method was generated by UIDefiner"	self xTile value: self xTile value + 1.	self doViewTile</body><body package="Mapsv0">doChangeUpLeftTile	"This stub method was generated by UIDefiner"	self xTile value: self xTile value - 1.	self yTile value: self yTile value - 1.	self doViewTile</body><body package="Mapsv0">doChangeUpRightTile	"This stub method was generated by UIDefiner"	self xTile value: self xTile value + 1.	self yTile value: self yTile value - 1.	self doViewTile</body><body package="Mapsv0">doChangeUpTile	"This stub method was generated by UIDefiner"	self yTile value: self yTile value - 1.	self doViewTile</body></methods><methods><class-id>UIMapsv0</class-id> <category>changing</category><body package="Mapsv0">GPSColToPixelCol	"This stub method was generated by UIDefiner"	| currentTileDico currentZoom currentTileX currentTileY gpsCol pixelCol |	currentTileDico := googleModel value matrixTile.	currentTileX := currentTileDico at: #x.	currentTileY := currentTileDico at: #y.	currentZoom := currentTileDico at: #zoom.	gpsCol := self lesPointsGPSVH value.	pixelCol := gpsCol collect: 					[:gps |					| meter pixel mapX mapY circle filledCircle comp |					meter := self mercator latLonToMeter: gps y "negated" lon: gps x.					pixel := self mercator meterToPixelNew: meter zoom: currentZoom.					mapX := pixel x - (currentTileX * 256).					mapY := pixel y - (currentTileY * 256).					circle := Circle center: mapX @ mapY radius: 20.					filledCircle := circle asStroker.					comp := (GraphicsAttributesWrapper on: filledCircle)								attributes: (GraphicsAttributes new paint: (ColorValue perform: #black)).					comp].	self lesPointsVH value: pixelCol.	self selectionGPSToPoint.	self tileView invalidate.	^self</body><body package="Mapsv0">GPSToPoint	"This stub method was generated by UIDefiner"	| currentTileDico currentZoom gpsCol pixelCol |	currentTileDico := googleModel value matrixTile.	"currentTileX := currentTileDico at: #x."	"currentTileY := currentTileDico at: #y."	currentZoom := currentTileDico at: #zoom.	gpsCol := self lesPointsGPSVH value.	pixelCol := gpsCol collect: 					[:gps |					| meter pixel |					meter := self mercator latLonToMeter: gps y "negated" lon: gps x.					pixel := self mercator meterToPixelNew: meter zoom: currentZoom.					"mapX := pixel x - (currentTileX * 256).					mapY := pixel y - (currentTileY * 256).					mapX rounded @ mapY rounded"					pixel x rounded @ (pixel y rounded)].	googleModel value pickModelTmp points  value: pixelCol.	^self</body><body package="Mapsv0">changeLabelPos	| widget pos posAbs pickModel con nodeDictionary pointDictionary nomProcessus fanOut pointProche wrapper color lookPref |	widget := self builder componentAt: #LabelPosition.	pos := self labelPosVH value.	pickModel := googleModel value pickModelTmp.	(pickModel isNil or: [(googleModel value matrixTile at: #x) isNil])		ifFalse: 			[posAbs := pos translatedBy: googleModel value originOffset.			widget labelString: posAbs printString.			con := pickModel connectivity.			con isNil ifTrue: [^self].			nodeDictionary := con nodeDictionary.			pointDictionary := pickModel pointDictionary.			pointDictionary isNil ifTrue: [^self].			pointProche := self pointClosedTo: posAbs.			pointProche isNil ifFalse: [nomProcessus := pointDictionary at: pointProche ifAbsent: [nil]].			wrapper := self builder componentAt: #LabelPosition.			self nodePName retractInterestsFor: self.			nomProcessus isNil				ifTrue: 					[wrapper labelString: pos printString.					color := ColorValue black.					lookPref := wrapper lookPreferences foregroundColor: color.					wrapper lookPreferences: lookPref.					self nodePName value: '']				ifFalse: 					[wrapper labelString: pos printString.					color := ColorValue black.					fanOut := nodeDictionary at: nomProcessus ifAbsent: ['none'].					self nodePName value: nomProcessus , ' ' , fanOut first size printString.					color := ColorValue red].			self nodePName onChangeSend: #changeMousePositionFromName to: self.			lookPref := wrapper lookPreferences foregroundColor: color.			wrapper lookPreferences: lookPref]</body><body package="Mapsv0">changeLabelPosSaved	| widget pos posAbs pickModel con nodeDictionary pointDictionary nomProcessus fanOut |	widget := self builder componentAt: #LabelPosition.	pos := self labelPosVH value.	pickModel := googleModel value pickModelTmp.	(pickModel isNil and: [(googleModel value matrixTile at: #x) isNil not])		ifFalse: 			[posAbs := pos translatedBy: googleModel value originOffset.			widget labelString: posAbs printString.			con := pickModel connectivity.			con isNil ifTrue: [^self].			nodeDictionary := con nodeDictionary.			pointDictionary := pickModel pointDictionary.			nomProcessus := pointDictionary at: posAbs ifAbsent: [nil].			nomProcessus isNil				ifFalse: 					["(self builder componentAt: #LabelPosition) labelString: nomProcessus."					fanOut := nodeDictionary at: nomProcessus ifAbsent: ['none'].					(self builder componentAt: #LabelPosition) labelString: nomProcessus , ' ' , fanOut first size printString.					(Delay forSeconds: 5) wait]]</body><body package="Mapsv0">changeLabelPosSaved2	| widget pos posAbs pickModel con nodeDictionary pointDictionary nomProcessus fanOut pointProche wrapper color lookPref |	widget := self builder componentAt: #LabelPosition.	pos := self labelPosVH value.	pickModel := googleModel value pickModelTmp.	(pickModel isNil or: [(googleModel value matrixTile at: #x) isNil])		ifFalse: 			[posAbs := pos translatedBy: googleModel value originOffset.			widget labelString: posAbs printString.			con := pickModel connectivity.			con isNil ifTrue: [^self].			nodeDictionary := con nodeDictionary.			pointDictionary := pickModel pointDictionary.			pointDictionary isNil ifTrue: [^self].			pointProche := self pointClosedTo: posAbs.			pointProche isNil ifFalse: [nomProcessus := pointDictionary at: pointProche ifAbsent: [nil]].			wrapper := self builder componentAt: #LabelPosition.			nomProcessus isNil				ifTrue: 					[wrapper labelString: pos printString.					color := ColorValue black.					lookPref := wrapper lookPreferences foregroundColor: color.					wrapper lookPreferences: lookPref.					self nodePName value: '']				ifFalse: 					[wrapper labelString: pos printString.					color := ColorValue black.					fanOut := nodeDictionary at: nomProcessus ifAbsent: ['none'].					self nodePName value: nomProcessus , ' ' , fanOut first size printString.					color := ColorValue red].			lookPref := wrapper lookPreferences foregroundColor: color.			wrapper lookPreferences: lookPref]</body><body package="Mapsv0">changeLabelPosSaved3	| widget pos posAbs pickModel con nodeDictionary pointDictionary nomProcessus fanOut pointProche wrapper color lookPref |	widget := self builder componentAt: #LabelPosition.	pos := self labelPosVH value.	pickModel := googleModel value pickModelTmp.	(pickModel isNil or: [(googleModel value matrixTile at: #x) isNil])		ifFalse: 			[posAbs := pos translatedBy: googleModel value originOffset.			widget labelString: posAbs printString.			con := pickModel connectivity.			con isNil ifTrue: [^self].			nodeDictionary := con nodeDictionary.			pointDictionary := pickModel pointDictionary.			pointDictionary isNil ifTrue: [^self].			pointProche := self pointClosedTo: posAbs.			pointProche isNil ifFalse: [nomProcessus := pointDictionary at: pointProche ifAbsent: [nil]].			wrapper := self builder componentAt: #LabelPosition.			nomProcessus isNil				ifTrue: 					[wrapper labelString: pos printString.					color := ColorValue black]				ifFalse: 					[fanOut := nodeDictionary at: nomProcessus ifAbsent: ['none'].					wrapper labelString: nomProcessus , ' ' , fanOut first size printString.					color := ColorValue red].			lookPref := wrapper lookPreferences foregroundColor: color.			wrapper lookPreferences: lookPref]</body><body package="Mapsv0">changeMousePositionFromName	| aNodeName processName pointPos relPos |	processName := self nodePName value.	processName isEmpty ifTrue: [^nil].	aNodeName := self cleanUpProcessName: processName.	aNodeName isEmpty		ifFalse: 			[pointPos := self pointFromName: aNodeName.			relPos := pointPos translatedBy: googleModel value originOffset negated.			tileView controller activate.			tileView controller sensor cursorPoint: relPos.			self componentAtPoint: relPos]</body><body package="Mapsv0">changeMousePositionFromName: aName	| aNodeName processName pointPos relPos |	processName := aName asString.	processName isEmpty ifTrue: [^nil].	aNodeName := self cleanUpProcessName: processName.	aNodeName isEmpty		ifFalse: 			[pointPos := self pointFromName: aNodeName.			pointPos isNil				ifFalse: 					[relPos := pointPos translatedBy: googleModel value originOffset negated.					tileView controller activate.					tileView controller sensor cursorPoint: relPos.					self componentAtPointRedrawAt: relPos]]</body><body package="Mapsv0">changeRange	"Compute the new diameter of the circles"	""	googleModel value range: self range value.	self tileView invalidate</body><body package="Mapsv0">changeZoom	| actualZoom difference xt yt |	actualZoom := self zoom value.	difference := actualZoom - oldZoom.	difference = 0 ifTrue: [^self].	xt := self xTile value.	yt := self yTile value.	difference &gt; 0		ifTrue: 			["zoom in"			difference timesRepeat: [xt := xt * 2].			difference timesRepeat: [yt := yt * 2]]		ifFalse: 			["zoom out"			difference := difference negated.			difference timesRepeat: [xt := (xt / 2) truncated].			difference timesRepeat: [yt := (yt / 2) truncated]].	self xTile value: xt.	self yTile value: yt.	oldZoom := actualZoom</body><body package="Mapsv0">cleanUpProcessName: processName	| aNodeName rs char ws myNodeName |	aNodeName := processName. 	rs := aNodeName readStream.	char := Character space.	[rs atEnd or: [char isSeparator not]] whileFalse: [char := rs next].	rs atEnd ifTrue: [^String new].	ws := (String new: 20) writeStream.	[rs atEnd or: [char isAlphaNumeric not]] whileFalse: 			[ws nextPut: char.			char := rs next].	char isAlphaNumeric ifTrue: [ws nextPut: char].	myNodeName := ws contents.	^myNodeName</body><body package="Mapsv0">collectObjectsClosedTo: posAbs inGraph: graph	| interested geom component ga |	interested := OrderedCollection new.	graph components do: 			[:comp |			geom := comp component.			(geom containsPoint: posAbs) ifTrue: [interested addFirst: comp]].	interested do: 			[:specWrapper |			component := specWrapper component.			component := component component.			((component isKindOf: FillingWrapper)				or: [component isKindOf: StrokingWrapper])					ifFalse: 						[ga :=  component attributes.						ga paint: ColorValue green]]</body><body package="Mapsv0">componentAtPoint: aPoint	| pickModel graph posAbs specWrapper component geometry |	pickModel := googleModel value pickModelTmp.	(pickModel isNil or: [(googleModel value matrixTile at: #x) isNil])		ifFalse: 			[graph := pickModel lastGraph.			graph isNil				ifFalse: 					[posAbs := aPoint translatedBy: googleModel value originOffset.					specWrapper := graph hitDetect: posAbs.					specWrapper isNil						ifFalse: 							[component := specWrapper component.							geometry := component component.							self interpretGeometry: geometry]]]</body><body package="Mapsv0">componentAtPointRedrawAt: aPoint	| pickModel graph posAbs specWrapper component geometry ga view bounds |	pickModel := googleModel value pickModelTmp.	(pickModel isNil or: [(googleModel value matrixTile at: #x) isNil])		ifFalse: 			[graph := pickModel lastGraph.			graph isNil				ifFalse: 					[posAbs := aPoint translatedBy: googleModel value originOffset.					self collectObjectsClosedTo: posAbs inGraph: graph.					specWrapper := graph hitDetect: posAbs.					specWrapper isNil						ifFalse: 							[component := specWrapper component.							ga := component component attributes.							ga paint: ColorValue green.							geometry := component component.							self interpretGeometry: geometry.							view := self builder componentAt: #TileViewHolder.							bounds := component bounds.							graph invalidateRectangle: bounds repairNow: true.							view invalidate]]]</body><body package="Mapsv0">computeGPSPoint	| lpg lp currentTileDico currentZoom currentTileX currentTileY |	lpg := self lesPointsGPSVH value.	currentTileDico := self matrixTile value.	currentZoom := currentTileDico at: #zoom.	currentTileX := currentTileDico at: #x.	currentTileY := currentTileDico at: #y.	lp := OrderedCollection new.	lp := lpg collect: 					[:p |					| meter pixel mapX mapY filledCircle comp circle |					meter := self mercator latLonToMeter: p y lon: p x.					pixel := self mercator meterToPixelNew: meter zoom: currentZoom.					mapX := pixel x - (currentTileX * 256).					mapY := pixel y - (currentTileY * 256).					circle := Circle center: mapX @ mapY radius: 20.					filledCircle := circle asFiller.					comp := (GraphicsAttributesWrapper on: filledCircle) attributes: (GraphicsAttributes new paint: (ColorValue perform: #white)).					comp].	self lesPointsVH value: lp</body><body package="Mapsv0">mapClic	| clic xclic yclic currentTileDico currentZoom tileX tileY pixelX pixelY metre latlon |	clic := self clicPointVH value.	xclic := clic x.	yclic := clic y.	"On rÃ©cupÃ¨re les coordonnÃ©es du carreau en haut Ã  gauche"	currentTileDico := googleModel value matrixTile.	currentZoom := currentTileDico at: #zoom.	currentZoom isNil ifTrue: [^nil].	tileX := currentTileDico at: #x.	tileY := currentTileDico at: #y.	"upperLeftTile := tileX @ tileY."	"Calcul des coordonnÃ©es en pixel du point cliquÃ©"	pixelX := tileX * 256 + xclic.	pixelY := tileY * 256 + yclic.	"Calcul des coordonnÃ©es en mÃ¨tre du point cliquÃ©"	metre := mercator pixelToMeterNew: pixelX @ pixelY zoom: currentZoom.	"Calcul des coordonnÃ©es WGS84 du point cliquÃ©"	latlon := self mercator meterToLatLon: metre.	self longitude value: latlon y.	self latitude value: latlon x</body><body package="Mapsv0">selectedNetworks	^self networkList selections</body><body package="Mapsv0">selectionGPSToPoint	"This stub method was generated by UIDefiner"	| currentTileDico currentZoom pixelCol typePoint selectedGpsCol |	currentTileDico := googleModel value matrixTile.	"currentTileX := currentTileDico at: #x."	"currentTileY := currentTileDico at: #y."	currentZoom := currentTileDico at: #zoom.	"gpsCol := self lesPointsGPSVH value."	typePoint := self selectedNetworks asSet.	selectedGpsCol := googleModel value colNodes				select: [:point | typePoint includes: point sym].	pixelCol := selectedGpsCol collect: 					[:node |					| gps meter pixel |					gps := node pos.					meter := self mercator latLonToMeter: gps latitude "negated" lon: gps longitude.					pixel := self mercator meterToPixelNew: meter zoom: currentZoom.					"mapX := pixel x - (currentTileX * 256).					mapY := pixel y - (currentTileY * 256).					mapX rounded @ mapY rounded"					pixel x rounded @ pixel y rounded].	googleModel value pickModelTmp points value: pixelCol.	^self</body><body package="Mapsv0">updatePickModel	| model pm currentZoom ppkm pixel |	model := googleModel value.	pm := model pickModelTmp.	currentZoom := model matrixTile at: #zoom.	ppkm := model pixelPerKmAt: currentZoom.	pixel := self range value / 1000 * ppkm.	pm portee: pixel rounded.	pm bounds: (self builder componentAt: #TileViewHolder) bounds.	"pm ppoints is auto updated by googleModel value holder"	"pm points: self lesPointsVH value."	"self halt."	googleModel value: model</body></methods><methods><class-id>UIMapsv0</class-id> <category>accessing</category><body package="Mapsv0">clicPointVH	^clicPointVH</body><body package="Mapsv0">clicPointVH: anObject	clicPointVH := anObject</body><body package="Mapsv0">colPickNodes	^googleModel value colPickedNodesVH value</body><body package="Mapsv0">drawingParameters	^drawingParameters</body><body package="Mapsv0">drawingParameters: anObject	drawingParameters := anObject</body><body package="Mapsv0">googleModel	^googleModel</body><body package="Mapsv0">googleModel: anObject	googleModel := anObject</body><body package="Mapsv0">labelPosVH	^labelPosVH</body><body package="Mapsv0">lesPointsGPSVH	^lesPointsGPSVH</body><body package="Mapsv0">lesPointsGPSVH: anObject	lesPointsGPSVH := anObject</body><body package="Mapsv0">lesPointsVH	^lesPointsVH</body><body package="Mapsv0">lesPointsVH: anObject	lesPointsVH := anObject</body><body package="Mapsv0">mapOrigin	| currentTileDico currentZoom tileX tileY pixelX pixelY |	currentTileDico := googleModel value matrixTile.	currentZoom := currentTileDico at: #zoom.	currentZoom isNil ifTrue: [^nil].	tileX := currentTileDico at: #x.	tileY := currentTileDico at: #y.	"upperLeftTile := tileX @ tileY."	"Origin of the map"	pixelX := tileX * 256.	pixelY := tileY * 256.	^Array with: pixelX @ pixelY with: currentZoom</body><body package="Mapsv0">matrixTile	^matrixTile</body><body package="Mapsv0">matrixTile: anObject	matrixTile := anObject</body><body package="Mapsv0">mercator	^mercator</body><body package="Mapsv0">mercator: anObject	mercator := anObject</body><body package="Mapsv0">oldZoom	^oldZoom</body><body package="Mapsv0">oldZoom: anObject	oldZoom := anObject</body><body package="Mapsv0">tileImage	^tileImage</body><body package="Mapsv0">tileImage: anObject	tileImage := anObject</body><body package="Mapsv0">tileView	^tileView</body><body package="Mapsv0">tileView: anObject	tileView := anObject</body></methods><methods><class-id>UIMapsv0</class-id> <category>testing</category><body package="Mapsv0">checkNameToPoint	^self absolutePointForName: 'P12'</body><body package="Mapsv0">testMoving	" test moving button in googlemap application "	| moves n |	moves := OrderedCollection new.	n := 10.	n timesRepeat: [moves add: 1 @ 0].	n timesRepeat: [moves add: 0 @ 1].	n timesRepeat: [moves add: -1 @ 0].	n timesRepeat: [moves add: 0 @ -1].	moves do: 			[:movePoint |			| newX newY |			newX := self xTile value.			newX := newX + movePoint x.			newY := self yTile value.			newY := newY + movePoint y.			self xTile value: newX.			self yTile value: newY.			(Delay forMilliseconds: 1000) wait.			self doViewTile]</body><body package="Mapsv0">testNameToPoint	^self absolutePointForName: 'P12'</body><body package="Mapsv0">testRelativeNameToPoint	^self relativePointForName: 'P12'</body></methods><methods><class-id>UIMapsv0</class-id> <category>interface closing</category><body package="Mapsv0">requestForWindowClose	^Dialog confirm: 'You are about to close the window!'</body></methods><methods><class-id>UIMapsv0</class-id> <category>computing</category><body package="Mapsv0">pointClosedTo: anAbsolutePosition	| pickModel con pointDictionary allPoints rectangle points |	pickModel := googleModel value pickModelTmp.	(pickModel isNil or: [(googleModel value matrixTile at: #x) isNil])		ifFalse: 			[con := pickModel connectivity.			con isNil ifTrue: [^self].			pointDictionary := pickModel pointDictionary.			pointDictionary isNil ifTrue: [^self].			allPoints := pointDictionary keys.			rectangle := Rectangle origin: anAbsolutePosition + (-2 @ -2)						corner: anAbsolutePosition + (2 @ 2).			points := (allPoints select: [:aPoint | rectangle containsPoint: aPoint])						asArray.			points isEmpty not ifTrue: [^points first] ifFalse: [^nil]]</body><body package="Mapsv0">pointFromName: aNodeName	| pickModel con pointDictionary allPoints |	pickModel := googleModel value pickModelTmp.	(pickModel isNil or: [(googleModel value matrixTile at: #x) isNil])		ifFalse: 			[con := pickModel connectivity.			con isNil ifTrue: [^nil].			pointDictionary := pickModel pointDictionary.			pointDictionary isNil ifTrue: [^self].			allPoints := pointDictionary associations detect: [:assoc | assoc value = aNodeName] ifNone: [nil].			allPoints isNil ifTrue: [^nil] ifFalse: [^allPoints key]]</body><body package="Mapsv0">zoomTile: origin quadrant: q displayAt: destination	self xTile value: self xTile value + origin x.	self yTile value: self yTile value + origin y.	self perform: q.	self xTile value: self xTile value - destination x.	self yTile value: self yTile value - destination y</body></methods><methods><class-id>UIMapsv0</class-id> <category>interface opening</category><body package="Mapsv0">postBuildWith: aBuilder	super postBuildWith: aBuilder.	"(builder componentAt: #theNetworkColor) widget add: (ColoredArea model: networkColorValue) in: (0 @ 0 corner: 1 @ 1)"	(self builder componentAt: #ChooseRangeColor) spec colors setBackgroundColor: drawingParameters outerCircleColor.	(self builder componentAt: #ChooseNetworkColor) spec colors setBackgroundColor: drawingParameters networkColor.	(self builder componentAt: #ChooseNameColor) spec colors setBackgroundColor: drawingParameters nameColor</body></methods><methods><class-id>UIMapsv0</class-id> <category>geometry</category><body package="Mapsv0">interpretCircle: aGeometry	| center radius process |	center := aGeometry center.	radius := aGeometry radius.	process := self nameForAbsolutePoint: center.	^process , ' range:  ' , radius printString</body><body package="Mapsv0">interpretGeometry: aGeometry	| text label geometricObject |^nil.	" geometricObject := aGeometry component component.	text := geometricObject class name. 	(geometricObject isKindOf: LineSegment)		ifTrue: [text := self interpretLineSegment: geometricObject].	(geometricObject isKindOf: Circle)		ifTrue: [text := self interpretCircle: geometricObject].	(geometricObject isKindOf: Point)		ifTrue: [text := self interpretPoint: geometricObject].	label := (self builder componentAt: #Geometry) widget.	label labelString: text"</body><body package="Mapsv0">interpretLineSegment: aGeometry	| startPoint stopPoint startProcess stopProcess length |	length := aGeometry length.	startPoint := aGeometry start.	stopPoint := aGeometry end.	startProcess := self nameForAbsolutePoint: startPoint.	stopProcess := self nameForAbsolutePoint: stopPoint.	^startProcess , ' to: ' , stopProcess , ' len: ' , length printString</body><body package="Mapsv0">interpretPoint: aGeometry</body></methods><methods><class-id>UIMapsv0 class</class-id> <category>useful workspaces</category><body package="Mapsv0">openGMapGettingStarted	"Schedule a view of the Getting Started Workspace."	"SimpleWorkspace openGettingStartedWorkspace."	| application |	application := SimpleWorkspace new.	application setWorkspace: GMapGettingStarted.	application open.	application builder window label: 'Getting Started'.	^application</body></methods><methods><class-id>QuickTileProxyOCM</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyOCM</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://tile.thunderforest.com/cycle/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body></methods><methods><class-id>QuickTileProxyOCM class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^'Open Cycle Map'</body><body package="QuickMap">maxSocket	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^6</body><body package="QuickMap">maxZoom	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^18</body></methods><methods><class-id>AlgoDis.ElevationReader</class-id> <category>accessing</category><body package="PickCell">process	^process</body><body package="PickCell">process: anObject	process := anObject</body><body package="PickCell">processTable	^processTable</body><body package="PickCell">processTable: anObject	processTable := anObject</body><body package="PickCell">reader	Reader isNil ifTrue: [Reader := ElevationReader new].	^Reader</body><body package="PickCell">requestBuffer	^requestBuffer</body><body package="PickCell">requestBuffer: anObject	requestBuffer := anObject</body><body package="PickCell">requestTime	^requestTime</body><body package="PickCell">requestTime: anObject	requestTime := anObject</body></methods><methods><class-id>AlgoDis.ElevationReader</class-id> <category>processing</category><body package="PickCell">addRequest: geoLoc forCellImage: cellImage	self requestBuffer addLast: (Array with: geoLoc with: cellImage).</body><body package="PickCell">awake	| p |	p := 			[5 to: 0				by: -1				do: 					[:i |					(Delay forMilliseconds: 10) wait.					self sendRequestArray: i]]					fork.	self process: p.	self processTable add: p</body><body package="PickCell">backgroundElevationAt: geoLoc forCellImage: cellImage	self addRequest: geoLoc forCellImage: cellImage.	self reader awake</body><body package="PickCell">buildUrlFor: geoLoc	| latitude longitude ws http string url |	latitude := geoLoc y.	longitude := geoLoc x.	ws := (String new: 100) writeStream.	http := 'http://maps.googleapis.com/maps/api/elevation/json?locations='.	ws nextPutAll: http.	string := latitude printString.	string := string copyFrom: 1 to: string size - 1.	ws nextPutAll: string.	ws nextPut: $,.	string := longitude printString.	string := string copyFrom: 1 to: string size - 1.	ws nextPutAll: string.	ws nextPutAll: '&amp;sensor=false'.	url := ws contents.	^url</body><body package="PickCell">buildUrlFor: geoLoc with: stream	| latitude longitude string |	latitude := geoLoc y.	longitude := geoLoc x.	string := latitude printString.	string := string copyFrom: 1 to: string size - 1.	stream nextPutAll: string.	stream nextPut: $,.	string := longitude printString.	string := string copyFrom: 1 to: string size - 1.	stream nextPutAll: string</body><body package="PickCell">directBackgroundElevationAt: geoLoc forCellImage: cellImage	| url replyTo httpRequest |	url := self buildUrlFor: geoLoc.	httpRequest := Net.HttpRequest get: url.	[replyTo := httpRequest execute] on: Net.HttpException		do: [:ex | replyTo := ex parameter].	^self processReply: replyTo forCellImage: cellImage</body><body package="PickCell">processReply: replyTo forCellImage: cellImage	| source bytes text status jjasonResult result elevation |	source := replyTo value byteSource.	bytes := source contents.	text := bytes asByteString.	status := replyTo statusLine.	status code = '403'		ifTrue: 			["Dialog warn: 'elevation rejected'.			Dialog warn: text."			^nil]		ifFalse: 			[jjasonResult := JSON.JsonReader readFrom: text readStream.			result := jjasonResult at: 'results'.			result isEmpty				ifTrue: [^nil]				ifFalse: 					[elevation := result first at: 'elevation'.					cellImage elevation: elevation.					^elevation]]</body><body package="PickCell">sendRequest	| request urlText cellImage httpRequest replyTo |	request := self requestBuffer removeFirst.	urlText := self buildUrlFor: request first.	cellImage := request last.	httpRequest := Net.HttpRequest get: urlText.	[replyTo := httpRequest execute] on: Net.HttpException		do: [:ex | replyTo := ex parameter].	^self processReply: replyTo forCellImage: cellImage</body><body package="PickCell">sendRequestArray	| urlText cellImage httpRequest replyTo nb urlConstructStream theseRequests geoLoc |	nb := self requestBuffer size.	nb = 0 ifTrue: [^nil].	nb := nb min: 10.	urlConstructStream := self urlInitialStream.	theseRequests := OrderedCollection new.	1 to: nb		do: 			[:i |			theseRequests add: self requestBuffer first.			self requestBuffer removeFirst].	theseRequests do: 			[:request |			cellImage := request last.			geoLoc := request first.			self buildUrlFor: geoLoc with: urlConstructStream]		separatedBy: [urlConstructStream nextPut: $|].	urlText := urlConstructStream contents.	Transcript		show: urlText;		show: nb printString;		cr.	httpRequest := Net.HttpRequest get: urlText.	[replyTo := httpRequest execute] on: Net.HttpException		do: [:ex | replyTo := ex parameter].	^self processReply: replyTo forCellImage: cellImage</body><body package="PickCell">sendRequestArray: ii	| urlText cellImage httpRequest replyTo nb urlConstructStream theseRequests geoLoc |	nb := self requestBuffer size.	(nb = 0 or: [nb &lt; 10 and: [ii &gt; 0]]) ifTrue: [^nil].	nb := nb min: 10.	urlConstructStream := self urlInitialStream.	theseRequests := OrderedCollection new.	1 to: nb		do: 			[:i |			theseRequests add: self requestBuffer first.			self requestBuffer removeFirst].	theseRequests do: 			[:request |			cellImage := request last.			geoLoc := request first.			self buildUrlFor: geoLoc with: urlConstructStream]		separatedBy: [urlConstructStream nextPut: $|].	urlText := urlConstructStream contents.	Transcript		show: urlText;		show: nb printString;		cr.	httpRequest := Net.HttpRequest get: urlText.	[replyTo := httpRequest execute] on: Net.HttpException		do: [:ex | replyTo := ex parameter].	^self processReply: replyTo forCellImage: cellImage</body><body package="PickCell">terminate	self process isNil ifFalse: [self process terminate].	self processTable do: [:proc | proc terminate]</body><body package="PickCell">urlInitialStream	| http |	http := 'http://maps.googleapis.com/maps/api/elevation/json?locations='.	^WriteStream on: http copy.</body></methods><methods><class-id>AlgoDis.ElevationReader</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	requestBuffer := OrderedCollection new.	processTable := OrderedCollection new.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.ElevationReader class</class-id> <category>class initialization</category><body package="PickCell">initialize   Reader := nil.</body></methods><methods><class-id>AlgoDis.ElevationReader class</class-id> <category>accessing</category><body package="PickCell">reader	^Reader isNil ifTrue: [Reader := self new] ifFalse: [Reader]</body><body package="PickCell">terminate	^Reader isNil		ifFalse: 			[Reader terminate.			Reader := nil]</body></methods><methods><class-id>AlgoDis.ElevationReader class</class-id> <category>testing</category><body package="PickCell">testNew  ^self new</body></methods><methods><class-id>AlgoDis.ElevationReader class</class-id> <category>instance creation</category><body package="PickCell">new	^self basicNew initialize</body></methods><methods><class-id>AlgoDis.PickCellModel</class-id> <category>accessing</category><body package="PickCell">bounds	^bounds</body><body package="PickCell">bounds: anObject	bounds := anObject</body><body package="PickCell">cellArray	^cellArray</body><body package="PickCell">cellArray: anObject	cellArray := anObject</body><body package="PickCell">cellClassifier	^cellClassifier</body><body package="PickCell">cellClassifier: anObject	cellClassifier := anObject</body><body package="PickCell">cellDisplay	^cellDisplay</body><body package="PickCell">cellDisplay: anObject	cellDisplay := anObject</body><body package="PickCell">colNodes	^colNodes</body><body package="PickCell">colNodes: anObject	colNodes := anObject</body><body package="PickCell">connectivity	^connectivity</body><body package="PickCell">connectivity: anObject	connectivity := anObject</body><body package="PickCell">displayModeDictionary	displayModeDictionary isNil		ifTrue: 			[displayModeDictionary := Dictionary new.			self defaultDisplayMode].	^displayModeDictionary</body><body package="PickCell">displayModeDictionary: anObject	displayModeDictionary := anObject</body><body package="PickCell">filename	^filename</body><body package="PickCell">filename: anObject	filename := anObject</body><body package="PickCell">geoRef1	^geoRef1</body><body package="PickCell">geoRef1: anObject	geoRef1 := anObject</body><body package="PickCell">geoRef2	^geoRef2</body><body package="PickCell">geoRef2: anObject	geoRef2 := anObject</body><body package="PickCell">getElevation	^getElevation</body><body package="PickCell">getElevation: anObject	getElevation := anObject</body><body package="PickCell">grid	^grid</body><body package="PickCell">grid: anObject	grid := anObject</body><body package="PickCell">guessedDirectory	^guessedDirectory</body><body package="PickCell">guessedDirectory: anObject	guessedDirectory := anObject</body><body package="PickCell">guessedName	guessedName isNil ifTrue: [self guessedName: 'aCellSystem'].	^guessedName</body><body package="PickCell">guessedName: projectName	guessedName := projectName.	self filename: projectName.	self setDefaultDirectory: projectName.	^projectName</body><body package="PickCell">highLightCells	^highLightCells</body><body package="PickCell">highLightCells: anObject	highLightCells := anObject</body><body package="PickCell">lastGraph	^lastGraph</body><body package="PickCell">lastGraph: anObject	lastGraph := anObject</body><body package="PickCell">mapOrigin	^mapOrigin</body><body package="PickCell">mapOrigin: anObject	mapOrigin := anObject</body><body package="PickCell">mercator	^mercator</body><body package="PickCell">mercator: anObject	mercator := anObject</body><body package="PickCell">mouseCell	^mouseCell</body><body package="PickCell">mouseCell: anObject	mouseCell := anObject</body><body package="PickCell">mousePoint	^mousePoint</body><body package="PickCell">mousePoint: anObject	mousePoint := anObject</body><body package="PickCell">newCellArray	^newCellArray</body><body package="PickCell">newCellArray: anObject	newCellArray := anObject</body><body package="PickCell">pointDictionary	^pointDictionary</body><body package="PickCell">pointDictionary: anObject	pointDictionary := anObject</body><body package="PickCell">points	^points</body><body package="PickCell">points: anObject	points := anObject</body><body package="PickCell">portee	^portee</body><body package="PickCell">portee: anObject	portee := anObject</body><body package="PickCell">windArray	^windArray</body><body package="PickCell">windArray: anObject	windArray := anObject</body><body package="PickCell">zones	^zones</body><body package="PickCell">zones: anObject	zones := anObject</body></methods><methods><class-id>AlgoDis.PickCellModel</class-id> <category>processing</category><body package="PickCell">backgroundElevationAt: geoLoc forCellImage: cellImage	self getElevation		ifTrue: 			[ElevationReader  reader backgroundElevationAt: geoLoc				forCellImage: cellImage].	^nil</body><body package="PickCell">computeMouseCell	| mp |	mp := self mousePoint value.	self mouseCell: (mp / self grid) rounded</body><body package="PickCell">computeMouseCellAtPoint: aPoint	self mouseCell: (aPoint / self grid) rounded</body><body package="PickCell">doText	| textCollector loc string tp thisCell position |	textCollector := Text new writeStream.	textCollector		nextPutAll: 'latitude,longitude,elevation,name';		cr.	self newCellArray keysAndValuesDo: 			[:yPos :rowOfCell |			rowOfCell keysAndValuesDo: 					[:xPos :aCellImage |					thisCell := aCellImage at: 3.					loc := thisCell geoPosition.					position := xPos @ yPos.					string := loc y printString.					string := string copyFrom: 1 to: string size - 1.					textCollector						nextPutAll: string;						nextPut: $,.					string := loc x printString.					string := string copyFrom: 1 to: string size - 1.					textCollector						nextPutAll: string;						nextPut: $,;						nextPutAll: '0.0,'.					textCollector						nextPutAll: (self processNameAtPos: position);						cr]].	tp := UITextPoints new.	tp pickModel: self.	tp open.	tp leTexte value: textCollector contents.	[tp doGetBackForURL] fork</body><body package="PickCell">doTextToDegrib	| textCollector loc string tp thisCell position string1 string2 ws rs  entryWS uwindString vwindString processName |	textCollector := Text new writeStream.	textCollector		nextPutAll: 'latitude,longitude,uwind,vwind,name';		cr.	windArray := OrderedCollection new.	self newCellArray keysAndValuesDo: 			[:yPos :rowOfCell |			rowOfCell keysAndValuesDo: 					[:xPos :aCellImage | 					entryWS := Array new writeStream.					thisCell := aCellImage at: 3.					loc := thisCell geoPosition.					position := xPos @ yPos.					entryWS nextPut: position .					entryWS nextPut: loc.					ws := String new writeStream.					string := loc y printString.					string1 := string copyFrom: 1 to: string size - 1.					ws nextPutAll: 'echo -n  '.					ws						nextPutAll: string1;						nextPut: $,.					string := loc x printString.					string2 := string copyFrom: 1 to: string size - 1.					ws						nextPutAll: string2;						nextPutAll: ';degrib -in ~wsn/grib.grb -P -pnt '.					ws						nextPutAll: string1;						nextPut: $,;						nextPutAll: string2;						nextPut: $ ;						nextPutAll: ' | head -3  | grep GRD';						cr.					string := UnixProcess cshOne: ws contents.					rs := string readStream.					textCollector nextPutAll: (rs upTo: $U).					textCollector nextPut: $,.					4 timesRepeat: [rs upTo: $,].					textCollector nextPutAll: (uwindString := rs upTo: Character cr).					entryWS nextPut: uwindString asNumber.					textCollector nextPut: $,.					4 timesRepeat: [rs upTo: $,].					textCollector nextPutAll: (vwindString := rs upTo: Character cr).					entryWS nextPut: vwindString asNumber.					textCollector nextPut: $,.					textCollector						nextPutAll: (processName := self processNameAtPos: position);						cr.					entryWS nextPut: processName.					windArray add: entryWS contents]].	tp := UITextPoints new.	tp pickModel: self.	tp open.	tp leTexte value: textCollector contents.	self windArray: windArray.</body><body package="PickCell">doTextToDegrib1	| textCollector loc string tp thisCell position string1 string2 ws rs  entryWS uwindString vwindString processName |	textCollector := Text new writeStream.	textCollector		nextPutAll: 'latitude,longitude,uwind,vwind,name';		cr.	self halt.	windArray := OrderedCollection new.	self newCellArray keysAndValuesDo: 			[:yPos :rowOfCell |			rowOfCell keysAndValuesDo: 					[:xPos :aCellImage | 					entryWS := Array new writeStream.					thisCell := aCellImage at: 3.					loc := thisCell geoPosition.					position := xPos @ yPos.					entryWS nextPut: position .					entryWS nextPut: loc.					ws := String new writeStream.					string := loc y printString.					string1 := string copyFrom: 1 to: string size - 1.					ws nextPutAll: 'echo -n  '.					ws						nextPutAll: string1;						nextPut: $,.					string := loc x printString.					string2 := string copyFrom: 1 to: string size - 1.					ws						nextPutAll: string2;						nextPutAll: '; degrib -in ~wsn/grib.grb -P -pnt '.					ws						nextPutAll: string1;						nextPut: $,;						nextPutAll: string2;						nextPut: $ ;						nextPutAll: ' | head -3  | grep GRD';						cr.					string := UnixProcess cshOne: ws contents.					rs := string readStream.					textCollector nextPutAll: (rs upTo: $U).					textCollector nextPut: $,.					4 timesRepeat: [rs upTo: $,].					textCollector nextPutAll: (uwindString := rs upTo: Character cr).					entryWS nextPut: uwindString asNumber.					textCollector nextPut: $,.					4 timesRepeat: [rs upTo: $,].					textCollector nextPutAll: (vwindString := rs upTo: Character cr).					entryWS nextPut: vwindString asNumber.					textCollector nextPut: $,.					textCollector						nextPutAll: (processName := self processNameAtPos: position);						cr.					entryWS nextPut: processName.					windArray add: entryWS contents]].	tp := UITextPoints new.	tp pickModel: self.	tp open.	tp leTexte value: textCollector contents.	self windArray: windArray.</body><body package="PickCell">getElevationAtPosition: geoLoc	| latitude longitude url hr r result ws string http elevation status source bytes text jjasonResult |	self getElevation		ifTrue: 			[latitude := geoLoc y.			longitude := geoLoc x. 			ws := (String new: 100) writeStream.			http := 'http://maps.googleapis.com/maps/api/elevation/json?locations='.			ws nextPutAll: http.			string := latitude printString.			string := string copyFrom: 1 to: string size - 1.			ws nextPutAll: string.			ws nextPut: $,.			string := longitude printString.			string := string copyFrom: 1 to: string size - 1.			ws nextPutAll: string.			ws nextPutAll: '&amp;sensor=false'.			url := ws contents.			hr := Net.HttpRequest get: url.			[r := hr execute] on: Net.HttpException do: [:ex | r := ex parameter].			source := r value byteSource.			bytes := source contents.			text := bytes asByteString.	"copy changeClassTo: ByteString."	"ISO8859L1String."			status := r statusLine.			status code = '403'				ifTrue: 					[Dialog warn: 'elevation rejected'.					Dialog warn: text.					self getElevation: false]				ifFalse: 					[jjasonResult := JSON.JsonReader readFrom: text readStream.					result := jjasonResult at: 'results'.					result isEmpty						ifFalse: 							[elevation := result first at: 'elevation'.							^elevation]].			^nil	"copy changeClassTo: ISO8859L1String"]</body><body package="PickCell">nameDictionary: cellPosArray	| name posDico key |	posDico := Dictionary new.	cellPosArray do: 			[:element |			name := element at: 4.			key := self positionFromName: name.			posDico at: key put: element].	^posDico</body><body package="PickCell">positionCoverDictionary: cellPosArray	| name posDico key elementWithPoint line cellImage |	newCellArray isNil ifTrue:  [ Dialog warn: 'must build cell system first'. ^nil] ifFalse: [ 	posDico := Dictionary new.	cellPosArray do: 			[:element |			name := element at: 4.			key := self positionFromName: name.			elementWithPoint := Array new: 6.			1 to: 3 do: [:i | elementWithPoint at: i put: (element at: i)].			elementWithPoint at: 4 put: key.			line := newCellArray at: key y .			cellImage := line at: key x  .			elementWithPoint at: 5 put: (cellImage at: 3).			elementWithPoint at: 6 put: name.			posDico at: key put: elementWithPoint.]. 	^posDico ]</body><body package="PickCell">positionDictionary: cellPosArray	| name posDico key elementWithPoint line cellImage |	posDico := Dictionary new.	cellPosArray do: 			[:element |			name := element at: 4.			key := self positionFromName: name.			elementWithPoint := Array new: 5.			1 to: 3 do: [:i | elementWithPoint at: i put: (element at: i)].			elementWithPoint at: 4 put: key.			line := newCellArray at: key y .			cellImage := line at: key x  .			elementWithPoint at: 5 put: cellImage.			posDico at: key put: elementWithPoint].	^posDico</body><body package="PickCell">positionFromName: nameString	| char xstream ystream key name |	name := nameString readStream.	char := name next.	xstream := String new writeStream.	[char isDigit] whileFalse: [char := name next].	[char isDigit] whileTrue: 			[xstream nextPut: char.			char := name next].	ystream := String new writeStream.	[char isDigit] whileFalse: [char := name next].	[name atEnd] whileFalse: 			[ystream nextPut: char.			char := name next].	ystream nextPut: char.	key := xstream contents asNumber @ ystream contents asNumber.	^key</body><body package="PickCell">positionWindDictionary: cellPosArray	| name posDico key elementWithPoint line cellImage index i image found |	newCellArray isNil		ifTrue: 			[Dialog warn: 'must build cell system first'.			^nil]		ifFalse: 			[posDico := Dictionary new.			cellPosArray do: 					[:element |					name := element at: 6.					key := self positionFromName: name.					elementWithPoint := Array new: 6.					1 to: 3 do: [:iii | elementWithPoint at: iii put: (element at: iii)].					elementWithPoint at: 4 put: key.					line := newCellArray at: key y.					cellImage := line at: key x.					elementWithPoint at: 5 put: (cellImage at: 3).					elementWithPoint at: 6 put: name.					index := nil.					i := 0.					image := newCellArray detect: 									[:cell |									i := i + 1.									cellImage := (cell at: 3) at:3.									found := cellImage position = key.									found ifTrue: [index := i].									found]								ifNone: [nil].					posDico at: key put: elementWithPoint.					image isNil						ifFalse: 							[windArray at: i								put: (Array with: (elementWithPoint at: 4) with: (elementWithPoint at: 5))]].			^posDico]</body><body package="PickCell">processElevations: cellPosArray	| loc externalCell latitude longitude elevation distance name posDico thisCell |	posDico := self nameDictionary: cellPosArray.	self newCellArray keysAndValuesDo: 			[:yPos :rowOfCell |			rowOfCell keysAndValuesDo: 					[:xPos :aCellImage |					externalCell := posDico at: xPos @ yPos ifAbsent: [nil].					externalCell isNil						ifFalse: 							[latitude := externalCell first.							longitude := externalCell at: 2.							elevation := externalCell at: 3.							name := externalCell at: 4.							thisCell := aCellImage at: 3.							loc := thisCell geoPosition.							distance := ((loc x - longitude) squared + (loc y - latitude) squared)										sqrt.							distance &lt; 0.001								ifTrue: 									[thisCell										elevation: elevation;										name: name]								ifFalse: [self halt]]]]</body><body package="PickCell">  processNameAtPos:   position	^'Px', position x printString , 'y', position y printString.</body><body package="PickCell">processWinds: cellPos	| textCollector loc string tp thisCell position string1 string2 ws rs entryWS uwindString vwindString processName |	textCollector := Text new writeStream.	textCollector		nextPutAll: 'latitude,longitude,uwind,vwind,name';		cr.	windArray := OrderedCollection new.	self newCellArray keysAndValuesDo: 			[:yPos :rowOfCell |			rowOfCell keysAndValuesDo: 					[:xPos :aCellImage |					entryWS := Array new writeStream.					thisCell := aCellImage at: 3.					loc := thisCell geoPosition.					position := xPos @ yPos.					entryWS nextPut: position.					entryWS nextPut: loc.					ws := String new writeStream.					string := loc y printString.					string1 := string copyFrom: 1 to: string size - 1.					ws nextPutAll: 'echo -n  '.					ws						nextPutAll: string1;						nextPut: $,.					string := loc x printString.					string2 := string copyFrom: 1 to: string size - 1.					ws						nextPutAll: string2;						nextPutAll: ';degrib -in ~wsn/grib.grb -P -pnt '.					ws						nextPutAll: string1;						nextPut: $,;						nextPutAll: string2;						nextPut: $ ;						nextPutAll: ' | head -3  | grep GRD';						cr.					string := UnixProcess cshOne: ws contents.					rs := string readStream.					textCollector nextPutAll: (rs upTo: $U).					textCollector nextPut: $,.					4 timesRepeat: [rs upTo: $,].					textCollector nextPutAll: (uwindString := rs upTo: Character cr).					entryWS nextPut: uwindString asNumber.					textCollector nextPut: $,.					4 timesRepeat: [rs upTo: $,].					textCollector nextPutAll: (vwindString := rs upTo: Character cr).					entryWS nextPut: vwindString asNumber.					textCollector nextPut: $,.					textCollector						nextPutAll: (processName := self processNameAtPos: position);						cr.					entryWS nextPut: processName.					windArray add: entryWS contents]].	tp := UITextPoints new.	tp pickModel: self.	tp open.	tp leTexte value: textCollector contents.	self windArray: windArray</body><body package="PickCell">scanCellArray: seuil	| result row cellImage geoLoc extent corner x y verif |	self cellDisplay getCellFromGrid. 	self cellClassifier: CellClassifier new.	self cellClassifier dictionary: Dictionary new.	"si l'intention de ce set est  d'Ã©viter de garder plusieurs fois la mÃªme cellule, c'est rÃ©ussi  voir la disparition de la mer sur diego.png ou le senegal "	self cellClassifier pickModel: self. 	self newCellArray: (Array new: cellArray size).	"cellArray est un tableau 2D donnant acces aux images des cellules 	On balaie d'abord verticalement."	self cellArray keysAndValuesDo: 			[:yPos :rowOfCell |			"yPos est le numero de la ligne, rowOfCell est la ligne"			row := Array new: rowOfCell size.			newCellArray at: yPos put: row.			"On ajoute une ligne de meme taille  a newCellArray,			et on attaque un balayage horizontal de la ligne d'origine"			rowOfCell keysAndValuesDo: 					[:xPos :aCellImage |					aCellImage isNil						ifTrue: [self halt " a priori, cela ne devrait pas arriver !"]						ifFalse: 							["Creation et definition d'un objet cellImage, incluant les coordonnÃ©es xy et geo "							cellImage := CellImage new.							cellImage cellImage: aCellImage.							x := 1 + ((xPos - 1) * aCellImage width).							y := 1 + ((yPos - 1) * aCellImage height).							cellImage position: x @ y.							geoLoc := self computeLocationAtPoint: cellImage position.							cellImage geoPosition: geoLoc.							self setElevationAt: geoLoc forCellImage: cellImage.							extent := cellImage cellImage extent.							corner := cellImage position + extent.							geoLoc := self computeLocationAtPoint: corner.							cellImage geoPositionCorner: geoLoc.							"On passe le CellImage au classifier"							self cellClassifier cell: aCellImage.							"Calcul de la classe"							result := self cellClassifier scan: seuil.							"IntÃ©gration au cellImage"							cellImage signature: result.							"Et sauvegarde dans lenewCellArray"							row at: xPos put: (Array with: aCellImage with: result with: cellImage)]]].	self cellClassifier newCellArray: newCellArray.	verif := self cellArray size = self newCellArray size.	self cellArray with: self newCellArray do: [:caEl :newCaEl | verif := verif and: [ caEl size = newCaEl size ]].	"Dialog warn: 'scanCellArray mutation ', verif printString."	self doText. 	"self doTextToDegrib."	^self cellClassifier updateUICellShow: seuil</body><body package="PickCell">setElevationAt: geoLoc forCellImage: cellImage	| elevation array |	self getElevation 		ifTrue: 			[array := Array with: geoLoc x with: geoLoc y.			elevation := GDALReader default getValueAtCoord: array.			elevation isNil ifFalse: [cellImage elevation: elevation]].	^nil</body><body package="PickCell">writeColor: pixel	| myFN ws |	myFN := '../colorfile' asFilename.	ws := myFN writeStream.	(255 * pixel red) truncated printOn: ws.	ws space.	(255 * pixel green) truncated printOn: ws.	ws space.	(255 * pixel blue) truncated printOn: ws.	ws cr.	ws close</body></methods><methods><class-id>AlgoDis.PickCellModel</class-id> <category>building</category><body package="PickCell">buildCellArrayModel	| cells | 	self cellArray isNil		ifFalse: 			[cells := self cellArray						collect: [:line | line collect: [:cell | CellImage with: cell]].			^cells].	^nil</body><body package="PickCell">buildGraph: gc	| netAndDicoAndComposite |	netAndDicoAndComposite := self buildNetAndDisplayOn: gc.	netAndDicoAndComposite isNil		ifFalse: [self lastGraph: netAndDicoAndComposite last].	^netAndDicoAndComposite</body><body package="PickCell">buildGraphInactive: gc	| netAndDicoAndComposite |	"self halt."	netAndDicoAndComposite := self buildNetAndDisplayOnInactive: gc.	self lastGraph: netAndDicoAndComposite last</body><body package="PickCell">buildNet	| networkGraph |	self filename isNil		ifTrue: 			[self filename: (Dialog requestFileName: 'name for this net'						default: self guessedName)].	networkGraph := NetworkGeometry				knownNetwork: self				drawing: true				title: self filename , 'Range' , self portee printString , 'Points'						, self points size printString.	^networkGraph</body><body package="PickCell">buildNetAndDisplayOn: aGC	| graphAndComposite |	self filename isNil ifTrue: [		Dialog warn: 'Please use File menu option to define a name first.'.		^ nil.		"self filename: (Dialog requestFileName: 'name for this net' default: self guessedNameForNet )"]. 	graphAndComposite := NetworkGeometry				knownNetwork: self				drawingOnlyOn: aGC				title: self filename , 'Range' , self portee printString , 'Points' , self points size printString.	^graphAndComposite</body><body package="PickCell">buildNetAndDisplayOn: aGC graphicParameters: graphicParameters	| graphAndComposite |	self filename isNil ifTrue: [self filename: (Dialog requestFileName: 'name for this net' default: 'aMap')].	graphAndComposite := NetworkGeometry				knownNetwork: self				drawingOnlyOn: aGC				title: self filename , 'Range' , self portee printString , 'Points' , self points size printString				parameters: graphicParameters.	^graphAndComposite</body><body package="PickCell">buildNetAndDisplayOnInactive: aGC	| graphAndComposite |	self filename isNil ifTrue: [self filename: (Dialog requestFileName: 'name for this net' default: self guessedNameForNet )]. 	graphAndComposite := NetworkGeometry				knownNetworkInactive: self				drawingOnlyOn: aGC				title: self filename , 'Range' , self portee printString , 'Points' , self points size printString.	^graphAndComposite</body><body package="PickCell">computeLocationAtPoint: aPixel	| zoom origin currentPoint mapArray meter lonlat |	mapArray := self mapOrigin.	mapArray isNil		ifFalse: 			[origin := mapArray at: 1.			zoom := mapArray at: 2.			currentPoint := origin + aPixel.			meter := self mercator pixelToMeterNew: currentPoint zoom: zoom.			lonlat := self mercator meterToLonLat: meter.			^lonlat			"m := gm pixelToMeterNew: currentPoint zoom: zoom.			^gm meterToLonLat: m"]</body></methods><methods><class-id>AlgoDis.PickCellModel</class-id> <category>initialize-release</category><body package="PickCell">defaultDisplayMode	displayModeDictionary at: #displayGrid put: true.	displayModeDictionary at: #displayImage put: true.	displayModeDictionary at: #displayGraph put: true.	displayModeDictionary at: #displayCoverCells put: true.	displayModeDictionary at: #displayZones put: true.	displayModeDictionary at: #displayWinds  put: false.</body><body package="PickCell">initialize	super initialize.	self mousePoint: nil asValue.	self mercator: GlobalMercator new.	self getElevation: true.	self setDefaultDirectory</body><body package="PickCell">setDefaultDirectory	| dd |	dd := Filename defaultDirectory.	dd := dd asString.	self guessedDirectory: dd , '/Generated'.	self guessedDirectory asFilename ensureDirectory.	^self guessedDirectory</body><body package="PickCell">setDefaultDirectory: projectName	| dd |	dd := Filename defaultDirectory.	dd := dd asString.	self guessedDirectory: dd , '/Generated/' , projectName.	self guessedDirectory asFilename ensureDirectory.	^self guessedDirectory</body></methods><methods><class-id>AlgoDis.PickCellModel</class-id> <category>parsing</category><body package="PickCell">guessedNameForNet	| name |	name := self guessedName.	name isNil		ifTrue: 			[name := 'aSystem'.			self guessedName: name].	^name , '.net'</body></methods><methods><class-id>AlgoDis.PickCellModel class</class-id> <category>instance creation</category><body package="PickCell">new	^super new initialize</body></methods><methods><class-id>AlgoDis.PickCellModelFromUrl</class-id> <category>accessing</category><body package="PickCell">getKnownUrl	^knownUrl</body><body package="PickCell">knownUrl: anObject	knownUrl := anObject</body></methods><methods><class-id>AlgoDis.PickCellModelFromUrl</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	knownUrl := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyCentralAmerica</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyCentralAmerica</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string := super baseWsn, '/osm_centralamerica/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>QuickTile</class-id> <category>accessing</category><body package="QuickMap">getTile	| httpResponse imageStream readerClass reader |	httpResponse := "MapServerConnection x: x y: y zoom:" zoom. "modified"	imageStream := httpResponse value byteSource.	png := imageStream.	[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream] ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	"self halt."	"self invalidate."	^tile</body><body package="QuickMap">getTile2	"httpResponse := MapServerConnection x: x y: y zoom: zoom."	| httpResponse imageStream readerClass reader url qhr |	url := ('http://mt.google.com/vt/x=' , x printString , '&amp;y='				, y printString , '&amp;z='				, zoom printString) asURI.	qhr := QuickHttpRequest get: url.	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: mapClient.	httpResponse := qhr execute.	imageStream := httpResponse value byteSource.	png := imageStream.		[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream]			ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	"self halt."	"self invalidate."	^tile</body><body package="QuickMap">getTile3	"httpResponse := MapServerConnection x: x y: y zoom: zoom."	| httpResponse imageStream url qhr galileo |	galileo := 'Galileo' readStream next: (Random new next * 7) rounded.	url := ('http://mt' , index printString				, '.google.com/vt/lyrs=m@259000000&amp;hl=en&amp;src=app&amp;x=' , x printString "app, aipv2"				, '&amp;y=' , y printString				, '&amp;z=' , zoom printString				, '&amp;s=' , galileo)				asURI.	qhr := QuickHttpRequest get: url.	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: mapClient.	httpResponse := qhr execute.	imageStream := httpResponse value byteSource.	^imageStream	"[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream]			ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	"	"self halt."	"	"	"self invalidate."	"	^tile"</body><body package="QuickMap">getTile4	"httpResponse := MapServerConnection x: x y: y zoom: zoom."	| httpResponse imageStream url qhr |	url := ('http://khm.google.com/kh/v=147&amp;src=app&amp;x=' , x printString , '&amp;y='				, y printString , '&amp;z='				, zoom printString) asURI.	qhr := QuickHttpRequest get: url.	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: mapClient.	httpResponse := qhr execute.	imageStream := httpResponse value byteSource.	^imageStream.		"[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream]			ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	""self halt.""	""self invalidate.""	^tile"</body><body package="QuickMap">getTile5	"httpResponse := MapServerConnection x: x y: y zoom: zoom."	| httpResponse imageStream url qhr galileo |	galileo := 'Galileo' readStream next: (Random new next * 7) rounded.	url := ('http://tile.openstreetmap.org/' , zoom printString , '/' , x printString , '/' , y printString , '.png')				asURI.	qhr := QuickHttpRequest get: url.	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: mapClient.	httpResponse := qhr execute.	imageStream := httpResponse value byteSource.	^imageStream	"[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream]			ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	"	"self halt."	"	"	"self invalidate."	"	^tile"</body><body package="QuickMap">getTile6	"httpResponse := MapServerConnection x: x y: y zoom: zoom."	| httpResponse imageStream url qhr galileo |	galileo := 'Galileo' readStream next: (Random new next * 7) rounded.	url := ('http://otile1.mqcdn.com/tiles/1.0.0/map/' , zoom printString , '/' , x printString , '/' , y printString , '.png')				asURI.	qhr := QuickHttpRequest get: url.	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: mapClient.	httpResponse := qhr execute.	imageStream := httpResponse value byteSource.	^imageStream	"[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream]			ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	"	"self halt."	"	"	"self invalidate."	"	^tile"</body><body package="QuickMap">getTile7	"httpResponse := MapServerConnection x: x y: y zoom: zoom."	| httpResponse imageStream url qhr galileo |	galileo := 'Galileo' readStream next: (Random new next * 7) rounded.	url := ('http://otile1.mqcdn.com/tiles/1.0.0/sat' , zoom printString , '/' , x printString , '/' , y printString , '.png')				asURI.	qhr := QuickHttpRequest get: url.	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: mapClient.	httpResponse := qhr execute.	imageStream := httpResponse value byteSource.	^imageStream	"[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream]			ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	"	"self halt."	"	"	"self invalidate."	"	^tile"</body><body package="QuickMap">idx	^idx</body><body package="QuickMap">idx: anObject	idx := anObject</body><body package="QuickMap">image	^image</body><body package="QuickMap">image: anObject	image := anObject</body><body package="QuickMap">index	^index</body><body package="QuickMap">index: anObject	index := anObject</body><body package="QuickMap">mapClient	^mapClient</body><body package="QuickMap">mapClient: anObject	mapClient := anObject</body><body package="QuickMap">pickCellDir	| homeDir baseDirName baseDir |	homeDir := SystemVariable named: 'HOME'.	baseDirName := homeDir value , '/.pickcell/cache/'.	baseDir := baseDirName asFilename.	baseDir ensureDirectory.	^baseDirName</body><body package="QuickMap">png	^png</body><body package="QuickMap">png: anObject	png := anObject</body><body package="QuickMap">prefetch	self tile2</body><body package="QuickMap">prx	^theProxy</body><body package="QuickMap">prx: anObject	theProxy := anObject</body><body package="QuickMap">refresh	^refresh</body><body package="QuickMap">retrieving	^retrieving</body><body package="QuickMap">retrieving: anObject	retrieving := anObject</body><body package="QuickMap">semaphore	^semaphore</body><body package="QuickMap">semaphore: anObject	semaphore := anObject</body><body package="QuickMap">theProxy	^theProxy</body><body package="QuickMap">theProxy: p	theProxy := p</body><body package="QuickMap">tile	^tile isNil		ifFalse: [tile]		ifTrue: 			[retrieving				ifFalse: 					[| reader readerClass is |					retrieving := true.										["sema critical: "					"self halt."					"sema excessSignals inspect."					idx := theProxy semIndexClient.					sema := theProxy semaphoreAt: idx.					mapClient := theProxy clientAt: idx.					semaQueue := sema size.					sema critical: [is := self getTile3].					is isNil						ifFalse: 							[							[readerClass := ImageReader readerClassFor: is.							reader := readerClass new from: is]									ensure: 										[is											ifNotNil: 												[:stream |												stream reset.												png := stream contents.												stream close]].							image := reader image.							Processor yield.							tile := image asRetainedMedium							"self refresh value: #ok."].					retrieving := false.					is isNil ifFalse: [self refresh value: #ok]]							forkAt: Processor userBackgroundPriority					"systemBackgroundPriority"					"activePriority"					"value"	"PlusOne"	"systemRockBottomPriority"].			"^(x @ y) printString asComposedText"			tile]</body><body package="QuickMap">tile2	| imageStream reader readerClass |	tile isNil ifFalse: [^tile].	retrieving		ifFalse: 			[retrieving := true.			 [			imageStream := self theProxy						getPng: index						x: x						y: y						zoom: zoom.			(imageStream isKindOf: Image)				ifTrue: [image := imageStream]				ifFalse: 					[readerClass := ImageReader readerClassFor: imageStream.					reader := readerClass new from: imageStream.					"reader readImage."					image := reader image.					"jpeg is 32 bits depth, but Screen default is 24: it needs particular processing"					readerClass = JPEGImageReader 						ifTrue: [image depth = 32 ifTrue: [image instVarNamed: 'depth' put: 24]						"maybe better : image := image convertForGraphicsDevice: Screen default."].					self png: image.					"self png: imageStream contents."					imageStream close].	"ifFalse:"			Processor yield.			tile := image asRetainedMedium.	retrieving := false.	imageStream isNil ifFalse: [self refresh value: #ok]] "value" forkAt: Processor userBackgroundPriority].	^tile</body><body package="QuickMap">tile2old	| imageStored reader |	tile isNil ifFalse: [^tile].	retrieving		ifFalse: 			[retrieving := true.						[imageStored := self theProxy						getPng: index						x: x						y: y						zoom: zoom.			imageStored isNil				ifFalse: 					[					[| readerClass |					readerClass := ImageReader readerClassFor: imageStored.					reader := readerClass new from: imageStored]							ensure: 								[imageStored									ifNotNil: 										[:stream |										stream reset.										png := stream contents.										stream close]].	"ifFalse:"					Processor yield.					image := reader image.					tile := image asRetainedMedium].			retrieving := false.			imageStored isNil ifFalse: [self refresh value: #ok]]					forkAt: Processor userBackgroundPriority].	^tile</body><body package="QuickMap">tile: anObject	tile := anObject</body><body package="QuickMap">x	^x</body><body package="QuickMap">x: anObject	x := anObject</body><body package="QuickMap">y	^y</body><body package="QuickMap">y: anObject	y := anObject</body><body package="QuickMap">zoom	^zoom</body><body package="QuickMap">zoom: anObject	zoom := anObject</body></methods><methods><class-id>QuickTile</class-id> <category>computing</category><body package="QuickMap">displayOn: aGraphicsContext	| tileSize thisTile |	tileSize := 256.	thisTile := self tile2.	thisTile isNil		ifFalse: 			[(thisTile instVarNamed: 'handle') isNil				ifTrue: 					[tile := image asRetainedMedium.					thisTile := tile].			thisTile displayOn: aGraphicsContext at: x @ y * tileSize]</body><body package="QuickMap">toFile: aFilename	| f |	f := aFilename asFilename writeStream.	f nextPutAll: self png.	f close</body></methods><methods><class-id>QuickTile</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	retrieving := false.	refresh := #nok asValue.	refresh onChangeSend: #invalidateNow to: self.	^self</body></methods><methods><class-id>QuickTile</class-id> <category>bounds accessing</category><body package="QuickMap">bounds	^self preferredBounds</body><body package="QuickMap">preferredBounds	" *** This method was defined by VisualComponent as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| p |	p := x @ y * 256.	^p corner: p + (256 @ 256)</body></methods><methods><class-id>QuickTile class</class-id> <category>instance creation</category><body package="QuickMap">x: x y: y zoom: zoom	^(self new)		x: x;		y: y;		zoom: zoom;		yourself</body></methods><methods><class-id>AlgoDis.TraceParserForCSV</class-id> <category>fileIn/Out</category><body package="PickCell">parseLine: line	| rs char ws word rsw |	rs := line readStream.	ws := Array new writeStream.	[rs atEnd] whileFalse: 			[word := rs upTo: $,.			word isEmpty				ifTrue: [ws nextPut: word]				ifFalse: 					[rsw := word readStream.					char := rsw next.					[char isSeparator and: [rsw atEnd not]] whileTrue: [char := rsw next].					ws nextPut: (String with: char) , rsw upToEnd]].	^ws contents</body><body package="PickCell">parseLine: line separator: sep	| rs char ws word rsw |	rs := line readStream.	ws := Array new writeStream.	[rs atEnd] whileFalse: 			[word := rs upTo: sep.			word isEmpty				ifTrue: [ws nextPut: word]				ifFalse: 					[rsw := word readStream.					char := rsw next.					[char isSeparator and: [rsw atEnd not]] whileTrue: [char := rsw next].					ws nextPut: (String with: char) , rsw upToEnd]].	^ws contents</body><body package="PickCell">parseLineComma: line	^self parseLine: line separator: $,</body><body package="PickCell">parseLineTab: line	^self parseLine: line separator: Character tab</body><body package="PickCell">readFile	|  rs line items records |	fileName := Dialog requestFileName: 'choose trace file :'. 	fileName isEmpty		ifFalse: 			[rs := fileName asFilename readStream.			records := OrderedCollection new.			[rs atEnd] whileFalse: 					[line := rs upTo: Character cr.					(line includes: Core.Character esc)						ifFalse: 							[items := self parseLine: line.							records add: items]]].	^records</body><body package="PickCell">readFileComma	| rs line items records |	fileName := Dialog requestFileName: 'choose trace file :'.	fileName isEmpty		ifFalse: 			[rs := fileName asFilename readStream.			records := OrderedCollection new.			[rs atEnd] whileFalse: 					[line := rs upTo: Character cr.					(line includes: Core.Character esc)						ifFalse: 							[items := self parseLineComma: line.							records add: items]]].	self title: records first.	records removeFirst.	self columns: records.	^records</body><body package="PickCell">readFileTab	| rs line items records |	fileName := Dialog requestFileName: 'choose trace file :'.	fileName isEmpty		ifFalse: 			[rs := fileName asFilename readStream.			records := OrderedCollection new.			[rs atEnd] whileFalse: 					[line := rs upTo: Character cr.					(line includes: Core.Character esc)						ifFalse: 							[items := self parseLineTab: line.							records add: items]]].	self title: records first.	records removeFirst.	self columns: records.	^records</body></methods><methods><class-id>AlgoDis.TraceParserForCSV</class-id> <category>accessing</category><body package="PickCell">columns	^columns</body><body package="PickCell">columns: anObject	columns := anObject</body><body package="PickCell">fileName	^fileName</body><body package="PickCell">fileName: anObject	fileName := anObject</body><body package="PickCell">lines	^lines</body><body package="PickCell">lines: anObject	lines := anObject</body><body package="PickCell">title	^title</body><body package="PickCell">title: anObject	title := anObject</body></methods><methods><class-id>AlgoDis.TraceParserForCSV</class-id> <category>processing</category><body package="PickCell">buildOn: array	| rs line col width |	rs := array readStream.	columns := self title collect: [:item | OrderedCollection new].	width := columns size.	[rs atEnd] whileFalse: 			[line := rs next.			line keysAndValuesDo: 					[:index :word |					col := columns at: index.					col add: word].			line size + 1 to: width				do: 					[:k |					col := columns at: k.					col add: String new]].	self checkSize.	^columns</body><body package="PickCell">checkSize	| sizes |	sizes := self columns collect: [:col | col size].	sizes asSet size &gt; 1 ifTrue: [self halt]</body><body package="PickCell">keepColumns: indexArray	| col2 title2 |	col2 := OrderedCollection new.	title2 := OrderedCollection new.	self columns keysAndValuesDo: 			[:key :val |			(indexArray includes: key)				ifTrue: 					[col2 add: val.					title2 add: (self title at: key)]].	self columns: col2.	self title: title2.				self checkSize.	^col2</body><body package="PickCell">newOrder: indexArray	| col2 aColumn title2 |	col2 := OrderedCollection new.	title2 := OrderedCollection new.	indexArray do: 			[:anIndex |			aColumn := self columns at: anIndex.			col2 add: aColumn.			title2 add: (self title at: anIndex)].	self columns: col2.	self title: title2.				self checkSize.	^col2</body><body package="PickCell">removeInvalids	| indexes col2 index newCol |	indexes := Set new.	(self columns at: 2)		keysAndValuesDo: [:key :val | val = 'XXX' ifTrue: [indexes add: key]].	col2 := OrderedCollection new.	self columns do: 			[:aColumn |			index := 1.			newCol := OrderedCollection new.			aColumn				keysAndValuesDo: [:k :v | (indexes includes: k) ifFalse: [newCol add: v]].			col2 add: newCol].	self columns: col2.				self checkSize.	^columns</body></methods><methods><class-id>AlgoDis.TraceParserForCSV</class-id> <category>printing</category><body package="PickCell">printOn: aStream	| rs word max width | 	rs := self title readStream.	[rs atEnd] whileFalse: 			[word := rs next.			aStream nextPutAll: word.			rs atEnd ifFalse: [aStream tab]].	aStream cr.	max := 0.	self columns do: [:col | max := max max: col size].	width := self columns size.	1 to: max		do: 			[:index |			self columns keysAndValuesDo: 					[:key :column |					word := column at: index .					aStream nextPutAll: word.					key &lt; width ifTrue: [aStream tab] ifFalse: [aStream cr]]]</body></methods><methods><class-id>AlgoDis.TraceParserForCSV class</class-id> <category>testing</category><body package="PickCell">testLine	" self testLine "	| t1 a1 |	t1 := 'type,	latitude,	longitude,	altitude (m),	name'.	a1 := self new parseLine: t1.	^a1</body><body package="PickCell">testLineComma	" self testLineComma "	| a1 |	a1 := self new readFileComma.	^a1</body><body package="PickCell">testLineTab	" self testLineTab "	| t1 a1 |	t1 := 'W	19.755071769	-16.570816040	0.0	Px1y1'.	a1 := self new parseLineTab: t1. 	^a1</body><body package="PickCell">testParseLineCommaAndFilter	" self testParseLineComma  "	| tP array |	tP := self new.	array := tP readFileComma.	tP buildOn: array.	tP removeInvalids.	tP keepColumns: #(1 6).	tP newOrder: #(2 1).	^tP</body><body package="PickCell">testParseLineTab	" self testParseLineTab  "	| tP array result |	tP := self new.	array := tP readFileTab.	result := tP buildOn: array.	^result</body><body package="PickCell">testParseLineTabAndFilter	" self testParseLineTab  "	| tP array |	tP := self new.	array := tP readFileTab.	tP buildOn: array.	tP removeInvalids.	^tP</body></methods><methods><class-id>AlgoDis.BGPickCellData</class-id> <category>accessing</category><body package="PickCell">code	^code</body><body package="PickCell">code: anObject	code := anObject</body><body package="PickCell">nbElements	^nbElements</body><body package="PickCell">nbElements: anObject	nbElements := anObject</body><body package="PickCell">xyzRef	^xyzRef</body><body package="PickCell">xyzRef: anObject	xyzRef := anObject</body></methods><methods><class-id>GlobalMercator</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	tileSize := 256.	initialResolution := 2 * Double pi * 6378137 / tileSize.	originShift := 2 * Double pi * 6378137 / 2.0.	^self</body></methods><methods><class-id>GlobalMercator</class-id> <category>accessing</category><body package="Mapsv0">initialResolution	^initialResolution</body><body package="Mapsv0">initialResolution: anObject	initialResolution := anObject</body><body package="Mapsv0">originShift	^originShift</body><body package="Mapsv0">originShift: anObject	originShift := anObject</body><body package="Mapsv0">tileSize	^tileSize</body><body package="Mapsv0">tileSize: anObject	tileSize := anObject</body></methods><methods><class-id>GlobalMercator</class-id> <category>computing</category><body package="Mapsv0">latLonToMeter1: lat lon: lon	| sm_a x y mx my |		mx := (lon /180.0) * self originShift .	my:= (lat /180.0) * self originShift .	sm_a := 6378137.0.	x := mx * sm_a.	y := (my sin + 1 log: 10) * sm_a / my cos.	^x @ y"| mx my lon lat |	mx := mPoint x.	my := mPoint y.	lon := mx / self originShift * 180.0.	lat := my / self originShift * 180.0.	lat := 180 / Double pi * (2 * (lat * Double pi / 180.0) exp arcTan - (Double pi / 2.0)).	^lat @ lon""originShift =pi * 6378137"</body><body package="Mapsv0">latLonToMeter2: lat lon: lon	| mx my |	mx := lon * self originShift / 180.0.	my := ((90 + lat) * Double pi / 360.0) tan log:10 / (Double pi / 180.0).	my := my * self originShift / 180.0.	^mx @ my"var degrees2meters = function(lon,lat) {var x = lon * 20037508.34 / 180;var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);y = y * 20037508.34 / 180;return [x, y]}"</body><body package="Mapsv0">latLonToMeter: lat lon: lon	| mx my |	mx := lon * self originShift / 180.0.	my := ((90 + lat) * Double pi / 360.0) tan ln / (Double pi / 180.0).	my := my * self originShift / 180.0.	^mx @ my"	| mx my lon lat |	mx := mPoint x.	my := mPoint y.	lon := mx / self originShift * 180.0.	lat := my / self originShift * 180.0.	lat := 180 / Double pi * (2 * (lat * Double pi / 180.0) exp arcTan - (Double pi / 2.0)).	^lat @ lon"</body><body package="Mapsv0">meterToLatLon: mPoint	| mx my lon lat |	mx := mPoint x.	my := mPoint y.	lon := mx / self originShift * 180.0.	lat := my / self originShift * 180.0.	lat := 180 / Double pi * (2 * (lat * Double pi / 180.0) exp arcTan - (Double pi / 2.0)).	^lat @ lon"originShift =pi * 6378137"</body><body package="Mapsv0">meterToLonLat1: mPoint	| mx my lon lat a |	mx := mPoint x.	my := mPoint y.	a:=  mx/ self originShift .	lon :=  a * 180.0.	lat := my / a.	lat := 180 / Double pi * (2 * (lat * Double pi / 180.0) exp arcTan - (Double pi / 2.0)).	^lon @ lat</body><body package="Mapsv0">meterToLonLat: mPoint	| mx my lon lat |	mx := mPoint x.	my := mPoint y.	lon := (mx / self originShift) * 180.0.	lat := (my / self originShift) * 180.0.	lat := 180 / Double pi * (2 * (lat * Double pi / 180.0) exp arcTan - (Double pi / 2.0)).	^lon @ lat</body><body package="Mapsv0">meterToPixelNew: xy zoom: zoom	| mx my res px py |	res := self resolution: zoom.	mx := xy x.	my := xy y negated.	px := (mx + self originShift) / res.	py := (my + self originShift) / res.	^px @ py</body><body package="Mapsv0">pixelToMeterNew: pPoint zoom: zoom	| px py res mx my |	px := pPoint x.	py := pPoint y.	res := self resolution: zoom.	mx := px * res - self originShift.	my := (py * res - self originShift) negated.	^mx @ my</body><body package="Mapsv0">resolution: zoom	^self initialResolution / (2 raisedTo: zoom)</body><body package="Mapsv0">tileBounds: tilePoint zoom: zoom	| tx ty ts min max |	tx := tilePoint x.	ty := tilePoint y.	ts := self tileSize.	min := self pixelToMeterNew: (tx * ts) @ (ty * ts) zoom: zoom.	max := self pixelToMeterNew: ((tx + 1) * ts) @ ((ty + 1) * ts) zoom: zoom.	^Rectangle origin: min corner: max</body></methods><methods><class-id>GlobalMercator</class-id> <category>deprecated</category><body package="Mapsv0">meterToPixel: xy zoom: zoom	| mx my res px py |	self error: 'Don''t use this!'.	res := self resolution: zoom.	mx := xy x.	my := xy y.	px := (mx + self originShift) / res.	py := (my + self originShift) / res.	^px @ py</body><body package="Mapsv0">pixelToMeter: pPoint zoom: zoom	| px py res mx my |	self error: 'Don''t use this!'.	px := pPoint x.	py := pPoint y.	res := self resolution: zoom.	mx := px * res - self originShift.	my := py * res - self originShift.	^mx @ my</body></methods><methods><class-id>GlobalMercator class</class-id> <category>instance creation</category><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>GlobalMercator class</class-id> <category>testing</category><body package="Mapsv0">test	"self test"	| gm p m |	gm := self new.	p := 0 @ 0.	m := gm pixelToMeterNew: p zoom: 0.	^m</body><body package="Mapsv0">test1	"POINT(-79.1923852433996 37.3317650468903)"	"Convert lat/lon from OSM format to WSG-84"	| loc osmLat osmLon osmPoint geoPoint testLat testLon geoLat geoLon |	testLat := -881565606 / 100.	testLon := 448545276 / 100.	osmPoint := testLat @ testLon.	loc := self new meterToLonLat: osmPoint.	osmLat := loc x.	osmLon := loc y.	geoPoint := self new latLonToMeter: osmLat lon: osmLon.	geoLat := geoPoint x * 100.	geoLon := geoPoint y * 100.	self halt.	^geoPoint</body><body package="Mapsv0">test2	"POINT(-79.1923852433996 37.3317650468903)"	"Convert lat/lon from OSM format to WSG-84"	| loc osmLat osmLon osmPoint geoPoint testLat testLon geoLat geoLon |	testLat := 1.	testLon := 1.	osmPoint := testLat @ testLon.	loc := self new meterToLonLat: osmPoint.	osmLat := loc x.	osmLon := loc y.	geoPoint := self new latLonToMeter: osmLat lon: osmLon.	geoLat := geoPoint x .	geoLon := geoPoint y.	self halt.	^geoPoint</body><body package="Mapsv0">test3	"POINT(-79.1923852433996 37.3317650468903)"	"Convert lat/lon from OSM format to WSG-84"	| loc osmLat osmLon osmPoint geoPoint testLat testLon geoLat geoLon |	testLat := -881565606 / 100.	testLon := 448545276 / 100.	osmPoint := testLat @ testLon.	loc := self new meterToLonLat: osmPoint.	osmLat := loc x.	osmLon := loc y.	geoPoint := self new latLonToMeter2: osmLat lon: osmLon.	geoLat := geoPoint x * 100.	geoLon := geoPoint y * 100.	self halt.	^geoPoint</body></methods><methods><class-id>MapServerConnection</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MapServerConnection class</class-id> <category>map server</category><body package="MapAccess">getGoogleMapTileUrl: stringTileX tileY: stringTileY tileZoom: stringTileZoom	^('http://mt.google.com/vt/x=' , stringTileX , '&amp;y=' , stringTileY , '&amp;z=' , stringTileZoom) asURI</body><body package="MapAccess">getOCMTileUrl: stringTileX tileY: stringTileY tileZoom: stringTileZoom	^('http://a.tile2.opencyclemap.org/transport/' , stringTileZoom , '/' , stringTileX , '/' , stringTileY , '.png') asURI</body><body package="MapAccess">getOSMTileUrl: stringTileX tileY: stringTileY tileZoom: stringTileZoom	^('http://tile.openstreetmap.org/' , stringTileZoom , '/' , stringTileX , '/' , stringTileY , '.png') asURI</body></methods><methods><class-id>MapServerConnection class</class-id> <category>server name</category><body package="MapAccess">selectedServer	^SelectedServer isNil ifTrue: [SelectedServer := 1] ifFalse: [SelectedServer]</body><body package="MapAccess">selectedServer: anInteger	^SelectedServer := anInteger</body><body package="MapAccess">serverList	"self serverList"	| url sName |	url := self class organization listAtCategoryNamed: #'map server'.	sName := url collect: [:each | self serverNameFor: each].	^sName</body><body package="MapAccess">serverListDico	"self serverListDico"	| url sName dico |	url := self class organization listAtCategoryNamed: #'map server'.	sName := url collect: [:each | self serverNameFor: each].	dico := Dictionary new: url size.	sName with: url do: [:iname :iurl | dico at: iname put: iurl].	^dico</body><body package="MapAccess">serverNameFor: aByteSymbol	^aByteSymbol asString readStream upTo: $:</body><body package="MapAccess">serverPath	"self serverPath"	^self class organization listAtCategoryNamed: #'map server'</body></methods><methods><class-id>MapServerConnection class</class-id> <category>testing</category><body package="MapAccess">test1	"self test1"	| x y zoom |	x := 0.	y := 0.	zoom := 0.	^self x: x y: y zoom: zoom</body></methods><methods><class-id>MapServerConnection class</class-id> <category>accessing</category><body package="MapAccess">mapClient	^MapClient isNil ifFalse: [MapClient] ifTrue: [MapClient := Net.HttpClient connectToHost: 'mt.google.com']</body><body package="MapAccess">mapClient: anObject	MapClient := anObject</body></methods><methods><class-id>MapServerConnection class</class-id> <category>http</category><body package="MapAccess">x: x y: y zoom: zoom	| stringTileX stringTileY stringTileZoom url req resp |	stringTileX := x printString.	stringTileY := y printString.	stringTileZoom := zoom printString.	"url := self getGoogleMapTileUrl: stringTileX tileY: stringTileY tileZoom: stringTileZoom."	"url := self getOSMTileUrl: stringTileX tileY: stringTileY tileZoom: stringTileZoom."	url := self				perform: (self serverPath at: self selectedServer)				with: stringTileX				with: stringTileY				with: stringTileZoom.	req := Net.HttpRequest get: url.	req fieldValueAt: 'User-Agent' put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	resp := req execute.	^resp</body></methods><methods><class-id>MapServerConnection class</class-id> <category>instance creation</category><body package="MapAccess">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyArcgisWorldHillshade</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyArcgisWorldHillshade</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	^('http://services.arcgisonline.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer/tile/'		, zoom printString , '/'		, y printString , '/'		, x printString) asURI</body></methods><methods><class-id>QuickTileProxyArcgisWorldHillshade class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^'ArcGis World Hillshade'</body><body package="QuickMap">maxSocket	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^2</body><body package="QuickMap">maxZoom	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^23</body></methods><methods><class-id>Mapsv0Controller</class-id> <category>events</category><body package="Mapsv0">blueButtonPressedEvent: aYellowButtonPressedEvent	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	self application zoom value = self application minZoom ifTrue: [^self].	self application doZoomOut.	self application doViewTile</body><body package="Mapsv0">enterEventSaved: anEnterEvent	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	| processName appli pickModel con nodeDictionary dataList pos |	appli := self application.	 	processName := appli nodePName value.	processName isEmpty ifTrue: [^nil].	processName := appli cleanUpProcessName: processName.	pickModel := appli googleModel value pickModelTmp.	self halt.	(pickModel isNil and: [(appli googleModel value matrixTile at: #x) isNil not])		ifFalse: 			[con := pickModel connectivity.			nodeDictionary := con nodeDictionary.			dataList := nodeDictionary at: processName ifAbsent: [^nil].			pos := dataList at: 2.			pos translatedBy: appli googleModel value originOffset negated.			processName isNil				ifFalse: 					[nodeDictionary at: processName ifAbsent: ['none'].					(Delay forSeconds: 5) wait]].	appli halt</body><body package="Mapsv0">mouseMovedEvent: aMouseMovedEvent	"Capte les mouvements de la souris."	"Cursor crossHair show."	| position |	position := self sensor cursorPointFor: aMouseMovedEvent.	self application labelPosVH value: position.	self application componentAtPoint: position</body><body package="Mapsv0">redButtonPressedEvent1: aRedButtonPressedEvent	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	| point clickedX clickedY xTile128 yTile128 centerTile128 vb nbXtiles256 nbYtiles256 centerTile256 xZoomedTile128 yZoomedTile128 xTile256 yTile256 q xZoomedTile256 yZoomedTile256 |	self application zoom value = self application maxZoom ifTrue: [^self].	point := self sensor cursorPointFor: aRedButtonPressedEvent.	clickedX := point x.	clickedY := point y.	"zoomed tile display zone"	vb := self application tileView viewBounds.	nbXtiles256 := (vb x / 256) rounded.	nbYtiles256 := (vb y / 256) rounded.	centerTile256 := (nbXtiles256 // 2) @ (nbYtiles256 // 2).	centerTile128 := (centerTile256 x * 2) @ (centerTile256 y * 2).	"clicked tile"	xTile128 := clickedX // 128.	yTile128 := clickedY // 128.	xTile256 := clickedX // 256.	yTile256 := clickedY // 256.	q := self quadrant: point - ((vb x // 256) @ (vb y // 256)).	"clicked tile desired position"	xTile128 &gt; centerTile128 x ifTrue: [xZoomedTile128 := centerTile128 x] ifFalse: [xZoomedTile128 := centerTile128 x - 1].	yTile128 &gt; centerTile128 y ifTrue: [yZoomedTile128 := centerTile128 y] ifFalse: [yZoomedTile128 := centerTile128 y - 1].	"zoomed tile position"	xZoomedTile256 := xZoomedTile128 // 2.	yZoomedTile256 := yZoomedTile128 // 2.	"offset"	self application		zoomTile: xTile256 @ yTile256		quadrant: q		displayAt: xZoomedTile256 @ yZoomedTile256.	"self halt."	self application doViewTile</body><body package="Mapsv0">redButtonPressedEvent: aRedButtonPressedEvent	| cursorPoint |	cursorPoint := self sensor cursorPointFor: aRedButtonPressedEvent.	"self zoomIn: cursorPoint"	self application clicPointVH value: cursorPoint</body><body package="Mapsv0">waitClickButton	^Dialog warn: 'toto'</body><body package="Mapsv0">yellowButtonPressedEvent: aYellowButtonPressedEvent	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	self application zoom value = self application minZoom ifTrue: [^self].	self application doZoomOut.	self application doViewTile</body></methods><methods><class-id>Mapsv0Controller</class-id> <category>accessing</category><body package="Mapsv0">application	^application</body><body package="Mapsv0">application: anObject	application := anObject</body></methods><methods><class-id>Mapsv0Controller</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Mapsv0Controller</class-id> <category>computing</category><body package="Mapsv0">quadrant: aPoint	| x y |	x := aPoint x.	y := aPoint y.	x &gt; 127 ifTrue: [y &gt; 127 ifTrue: [^#doZoomInDownRight] ifFalse: [^#doZoomInUpRight]] ifFalse: [y &gt; 127 ifTrue: [^#doZoomInDownLeft] ifFalse: [^#doZoomInUpLeft]]</body><body package="Mapsv0">zoomIn: cursorPoint	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	| point clickedX clickedY xTile128 yTile128 centerTile128 vb nbXtiles256 nbYtiles256 centerTile256 xTile256 yTile256 q |	self application zoom value = self application maxZoom ifTrue: [^self].	point := cursorPoint. 	clickedX := point x.	clickedY := point y.	"zoomed tile display zone"	vb := self application tileView viewBounds.	nbXtiles256 := (vb x / 256) rounded.	nbYtiles256 := (vb y / 256) rounded.	centerTile256 := (nbXtiles256 // 2) @ (nbYtiles256 // 2).	centerTile128 := (centerTile256 x * 2) @ (centerTile256 y * 2).	"clicked tile"	xTile128 := clickedX // 128.	yTile128 := clickedY // 128.	xTile256 := (clickedX // 256) .	yTile256 := (clickedY // 256) .	q := self quadrant: point - ((vb x // 256) @ (vb y // 256)).	"clicked tile desired position"	xTile128 &gt; centerTile128 x ifTrue: [centerTile128 x] ifFalse: [centerTile128 x - 1].	yTile128 &gt; centerTile128 y ifTrue: [centerTile128 y] ifFalse: [centerTile128 y - 1].	"offset"	self application		zoomTile: xTile256 @ yTile256		quadrant: q		displayAt: ((clickedX // 256) rounded) @ ((clickedX // 256) rounded).	"self halt."	self application doViewTile</body></methods><methods><class-id>AlgoDis.LightTrap</class-id> <category>accessing</category><body package="PickCell">lat	^lat</body><body package="PickCell">lat: anObject	lat := anObject</body><body package="PickCell">lon	^lon</body><body package="PickCell">lon: anObject	lon := anObject</body><body package="PickCell">name	^name</body><body package="PickCell">name: anObject	name := anObject</body><body package="PickCell">values	^values</body><body package="PickCell">values: anObject	values := anObject</body></methods><methods><class-id>AlgoDis.LightTrap</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	name := nil.	lat := nil.	lon := nil.	values := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.LightTrap class</class-id> <category>instance creation</category><body package="PickCell">name: sname lat: slat lon: slon	^(self new)		name: sname;		lat: slat;		lon: slon</body><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>UIMapTileCacheConfig</class-id> <category>aspects</category><body package="MapAccess">dicoBox	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dicoBox isNil		ifTrue:			[dicoBox := String new asValue]		ifFalse:			[dicoBox]</body><body package="MapAccess">dicoChoices	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dicoChoices isNil 		ifTrue: [dicoChoices := SelectionInList new] 		ifFalse: [dicoChoices]</body><body package="MapAccess">dicoList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dicoList isNil		ifTrue:			[dicoList := SelectionInList new]		ifFalse:			[dicoList]</body><body package="MapAccess">server	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^server isNil		ifTrue:			[server := nil asValue]		ifFalse:			[server]</body></methods><methods><class-id>UIMapTileCacheConfig</class-id> <category>accessing</category><body package="MapAccess">parent	^parent</body><body package="MapAccess">parent: anObject	parent := anObject</body></methods><methods><class-id>UIMapTileCacheConfig</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"self dicoChoices list addAll: MapServerConnection serverList.	self dicoBox value: (MapServerConnection serverList				at: MapServerConnection selectedServer)"	self server value: self serverName.	self server onChangeSend: #changeServer to: self</body></methods><methods><class-id>UIMapTileCacheConfig</class-id> <category>private</category><body package="MapAccess">serverId	^self serverList indexOf: self server value</body><body package="MapAccess">serverList	^#(#googleMap #OCM #OSM)</body><body package="MapAccess">serverName	^self serverList at: MapServerConnection selectedServer</body></methods><methods><class-id>UIMapTileCacheConfig</class-id> <category>actions</category><body package="MapAccess">doEmptyCache	self parent mapAccess mapTileCache emptyCache</body></methods><methods><class-id>UIMapTileCacheConfig</class-id> <category>changing</category><body package="MapAccess">changeServer	MapServerConnection selectedServer: self serverId</body></methods><methods><class-id>AlgoDis.TraceParserForCrickets</class-id> <category>fileIn/Out</category><body package="PickCell">parseLine: line	| rs char ws node phase tour values foundEnd |	rs := line readStream.	char := rs next.	ws := String new writeStream.	[char isAlphabetic] whileFalse: 			[ws nextPut: char.			char := rs next].	node := ws contents asNumber.	ws := String new writeStream.	[char isAlphabetic] whileTrue: 			[ws nextPut: char.			char := rs next].	phase := ws contents asSymbol.	ws := String new writeStream.	char := rs next.	[char isDigit or: [char = $-]] whileTrue: 			[ws nextPut: char.			char := rs next]. 	tour := ws contents asNumber.	ws := String new writeStream.	[char isDigit] whileFalse: 			[ws nextPut: char.			char := rs next]. 	values := OrderedCollection new.	foundEnd := false.	[foundEnd or: [rs atEnd]] whileFalse: 			[ws := String new writeStream. 							[char isDigit or: [rs atEnd]] whileFalse: 					[ 					char := rs next].			[char isDigit and: [rs atEnd not]] whileTrue: 					[ws nextPut: char.					char := rs next].			values add: ws contents asNumber. 			foundEnd := char = $;].	^Array		with: node		with: phase		with: tour		with: values</body><body package="PickCell">readFile	|  rs line items records |	fileName := Dialog requestFileName: 'choose trace file :'.	texte := String new.	fileName isEmpty		ifFalse: 			[rs := fileName asFilename readStream.			records := OrderedCollection new.			[rs atEnd] whileFalse: 					[line := rs upTo: Character cr.					(line includes: Core.Character esc)						ifFalse: 							[items := self parseLine: line.							records add: items]]].	^records</body><body package="PickCell">writeFile	| ws selection |	fileName := fileName , '.jgr'.	texte isEmpty		ifFalse: 			[ws := fileName asFilename writeStream.			ws				nextPutAll: texte;				close].	selection := 'jgraph -P ' , fileName , ' &gt; ' , fileName , '.ps'.	TextEditorController copySelection: selection.	Dialog warn: '(paste) ' , selection.	^texte</body><body package="PickCell">writeFile: thisNode	| ws selection |	fileName := fileName , '-' , thisNode printString.	fileName := fileName , '.jgr'.	texte isEmpty		ifFalse: 			[ws := fileName asFilename writeStream.			ws				nextPutAll: texte;				close].	selection := 'jgraph  ' , fileName , ' &gt; ' , fileName , '.eps'.	TextEditorController copySelection: selection.	Dialog warn: '(paste) ' , selection.	^texte</body><body package="PickCell">writeFile: thisNode limit:limit	| ws selection |	fileName := fileName , '-' , thisNode printString, '-' , limit printString.	fileName := fileName , '.jgr'.	texte isEmpty		ifFalse: 			[ws := fileName asFilename writeStream.			ws				nextPutAll: texte;				close].	selection := 'jgraph  ' , fileName , ' &gt; ' , fileName , '.eps'.	TextEditorController copySelection: selection.	Dialog warn: '(paste) ' , selection.	^texte</body></methods><methods><class-id>AlgoDis.TraceParserForCrickets</class-id> <category>processing</category><body package="PickCell">byNode	| byNode values nodes allValues collection |	byNode := Dictionary new.	nodes := self dicoState collect: [:items | items first].	nodes := nodes asSet asSortedCollection.	nodes do: 			[:aNode |			allValues := self dicoState select: [:items | items first = aNode].			collection := allValues collect: 							[:items |							values := items copyFrom: 2 to: items size.							values].			byNode at: aNode put: collection].	^byNode</body><body package="PickCell">byNode: thisNode	| byNode values nodes allValues collection |	byNode := Dictionary new.	nodes := self dicoState collect: [:items | items first].	nodes := nodes asSet asSortedCollection.	nodes do: 			[:aNode |			allValues := self dicoState select: [:items | items first = aNode].			collection := allValues collect: 							[:items |							values := items copyFrom: 2 to: items size.							values].			byNode at: aNode put: collection].	^byNode at: thisNode</body><body package="PickCell">byNodeAndTurns: thisNode	| byNode values nodes allValues collection trace sortedTrace sc order t1 |	byNode := Dictionary new.	nodes := self dicoState collect: [:items | items first].	nodes := nodes asSet asSortedCollection.	order := self lifeStatesDico.	nodes do: 			[:aNode |			allValues := self dicoState select: [:items | items first = aNode].			collection := allValues collect: 							[:items |							values := items copyFrom: 2 to: items size.							values].  			byNode at: aNode put: collection].	trace := byNode at: thisNode.	sortedTrace := SortedCollection sortBlock: 					[:items1 :items2 |					t1 := (items1 at: 2) = (items2 at: 2).					t1						ifTrue: [(order at: items1 first) &lt; (order at: items2 first)]						ifFalse: [(items1 at: 2) &lt; (items2 at: 2)]].	sortedTrace addAll: trace.	^sortedTrace asArray</body><body package="PickCell">lifeStates	| symbols |	symbols := #(#Eggs #Larvaes #Winged #Solitarious #Gregarious).	^symbols</body><body package="PickCell">lifeStatesDico	| symbols dico |	symbols := self lifeStates.	dico := Dictionary new.	symbols keysAndValuesDo: [:key :sym |  dico at: sym put: key.].	^ dico</body><body package="PickCell">printJGraph: thisNode	| ws array lifeDico minX maxX x marktypes linetypes |	ws := String new writeStream.	ws		nextPutAll: '            newgraph';		cr.	marktypes := #(#circle #box #diamond #triangle #x #cross #ellipse #xbar #ybar)				readStream.				 	linetypes := ReadStream				on: #(#solid #dotted #dashed #longdash #dotdash #dash #dotdotdash #dotdotdashdash).	array := self tableForJGraph: thisNode.	lifeDico := self lifeStates.	minX := 1999999.	maxX := minX negated.	array keysAndValuesDo: 			[:index :values |			ws nextPutAll: '    newcurve pts '.			values do: 					[:val |					x := val first.					minX := minX min: x.					maxX := maxX max: x.					val first printOn: ws.					ws space.					val last printOn: ws.					ws space].			ws cr.			ws nextPutAll: ' marktype none  linetype  ' , linetypes next asString; space.			ws nextPutAll: 'label : '.			ws				nextPutAll: (lifeDico at: index) asString;				cr;				cr].	ws nextPutAll: ' xaxis  min '.	minX printOn: ws.	ws nextPutAll: ' max '.	maxX printOn: ws.	ws		nextPutAll: ' label : turns ';		cr.	ws		nextPutAll: ' yaxis   label : individuals ';		cr.	texte := ws contents.	self writeFile: thisNode</body><body package="PickCell">printJGraph: thisNode limit:limit	| ws array lifeDico minX maxX x marktypes linetypes nb |	ws := String new writeStream.	ws		nextPutAll: '            newgraph';		cr.	marktypes := #(#circle #box #diamond #triangle #x #cross #ellipse #xbar #ybar)				readStream.				 	linetypes := ReadStream				on: #(#solid #dotted #dashed #longdash #dotdash #dash #dotdotdash #dotdotdashdash).	array := self tableForJGraph: thisNode.	lifeDico := self lifeStates.	minX := 1999999.	maxX := minX negated. 	array keysAndValuesDo: 			[:index :values |			ws nextPutAll: '    newcurve pts '.			nb := 0.			values do: 					[:val |						nb :=nb +1.						nb &lt;= limit ifTrue:  [ 					x := val first.					minX := minX min: x.					maxX := maxX max: x.					val first printOn: ws.					ws space.					val last printOn: ws.					ws space ]].			ws cr.			ws nextPutAll: ' marktype none  linetype  ' , linetypes next asString; space.			ws nextPutAll: 'label : '.			ws				nextPutAll: (lifeDico at: index) asString;				cr;				cr].	ws nextPutAll: ' xaxis  min '.	minX printOn: ws.	ws nextPutAll: ' max '.	maxX printOn: ws.	ws		nextPutAll: ' label : turns ';		cr.	ws		nextPutAll: ' yaxis   label : individuals ';		cr.	texte := ws contents.	self writeFile: thisNode limit: limit</body><body package="PickCell">tableForJGraph: thisNode	| array indexDico collection state turn values somme index |	array := self byNodeAndTurns: thisNode.	indexDico := self lifeStatesDico.	collection := Array  new: self lifeStatesDico size.	collection := collection collect: [:y | OrderedCollection new].	array do: 			[:entry |			state := entry first.			turn := entry at: 2.			values := entry last.			somme := values inject: 0 into: [:x :sum | sum + x].			index := indexDico at: state.			(collection at: index) add: (Array with: turn with: somme)].	^collection</body></methods><methods><class-id>AlgoDis.TraceParserForCrickets</class-id> <category>accessing</category><body package="PickCell">dicoState	^dicoState</body><body package="PickCell">dicoState: anObject	dicoState := anObject</body><body package="PickCell">fileName	^fileName</body><body package="PickCell">fileName: anObject	fileName := anObject</body><body package="PickCell">texte	^texte</body><body package="PickCell">texte: anObject	texte := anObject</body></methods><methods><class-id>AlgoDis.TraceParserForCrickets</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***" 	dicoState := self readFile.	^self</body></methods><methods><class-id>AlgoDis.TraceParserForCrickets class</class-id> <category>testing</category><body package="PickCell">test1	^self new</body><body package="PickCell">test2	^self new byNode</body><body package="PickCell">testNode100	^self new byNode: 100</body><body package="PickCell">testNode100byTurns	^self new byNodeAndTurns: 100</body><body package="PickCell">testTable100byTurns	^self new printJGraph: 100</body><body package="PickCell">testTable101byTurns	^self new printJGraph: 101</body><body package="PickCell">testTable110byTurns	" TraceParserForCrickets  testTable110byTurns "	^self new printJGraph: 110</body><body package="PickCell">testTablebyTurns	" TraceParserForCrickets  testTable110byTurns "	self new printJGraph: 110 limit:5 .	self new printJGraph: 100 limit:5 .	self new printJGraph: 101 limit:5 .	self new printJGraph: 102 limit:5 .</body></methods><methods><class-id>AlgoDis.TraceParserForCrickets class</class-id> <category>instance creation</category><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileController</class-id> <category>accessing</category><body package="QuickMap">clicZoneCorner	^clicZoneCorner</body><body package="QuickMap">clicZoneCorner: anObject	clicZoneCorner := anObject</body><body package="QuickMap">clicZoneInProgress	^clicZoneInProgress</body><body package="QuickMap">clicZoneInProgress: anObject	clicZoneInProgress := anObject</body><body package="QuickMap">clicZoneOrigin	^clicZoneOrigin</body><body package="QuickMap">clicZoneOrigin: anObject	clicZoneOrigin := anObject</body><body package="QuickMap">forkAnim	^forkAnim</body><body package="QuickMap">forkAnim: anObject	forkAnim := anObject</body><body package="QuickMap">lineInProgress	^lineInProgress</body><body package="QuickMap">lineInProgress: anObject	lineInProgress := anObject</body><body package="QuickMap">pathInProgress	^pathInProgress</body><body package="QuickMap">pathInProgress: anObject	pathInProgress := anObject.	anObject		ifTrue: [self model value newTextCollector: TextCollector new]		ifFalse: [self model value textCollector: nil]</body></methods><methods><class-id>QuickTileController</class-id> <category>event driven</category><body package="QuickMap">handlerForMouseEvent: aMouseEvent	^self</body><body package="QuickMap">selectionTracker	^QuickTileTracker on: self</body></methods><methods><class-id>QuickTileController</class-id> <category>events</category><body package="QuickMap">desiresFocus	^true</body><body package="QuickMap">enterEvent: anEvent	isMoving := false.	"self currentTool enterEvent: anEvent"	self model value clicZone 		ifTrue: [Cursor crossHair show] 		ifFalse: [Cursor hand show.]</body><body package="QuickMap">exitEvent: anEvent	isMoving := false.	Cursor normal show.</body><body package="QuickMap">keyPressedEvent: anEvent	"[self selectEvent: anEvent. ^self] value."	"anEvent inspect."	anEvent inspect</body><body package="QuickMap">mouseMovedEvent: anEvent	"[super mouseMovedEvent: anEvent. ^self] value."	| thispoint origine newZoom |	self sensor shiftDown ifTrue: [Cursor crossHair show].	newZoom := self view mapZoom. 	self model value zoom: newZoom.	thispoint := anEvent point. 		"compute the origin of map as displayed"	origine := self view container container bounds origin.	"set a string to inform clients of this position"	self mouseGeocode: thispoint fromOrigin: origine.	isMoving		ifTrue: 			[| p |			p := anEvent globalPoint.			delta := previousPoint - p.			self view container scrollBy: delta.			previousPoint := p.			previousClock := currentClock.			currentClock := Time microsecondClock].	self model value clicZoneInProgress		ifTrue: 			[| oldBR new maxPoint minPoint |			clicZoneCorner := self sensor cursorPoint.			oldBR := self model value clicZoneRectangle bottomRight copy.			new := Rectangle origin: clicZoneOrigin corner: clicZoneCorner.			"new := self model value clicZoneRectangle bottomRight: clicZoneCorner."			self model value clicZoneRectangle: new.			maxPoint := clicZoneCorner max: oldBR.			minPoint := clicZoneCorner min: oldBR.			self view				invalidateRectangle: (Rectangle origin: clicZoneOrigin x @ minPoint y						corner: maxPoint + 1)				repairNow: true.			self view				invalidateRectangle: (Rectangle origin: minPoint x @ clicZoneOrigin y						corner: (maxPoint x + 1) @ minPoint y)]</body><body package="QuickMap">mouseWheelEvent: event	| clic offset clicWindow zoom newClic newZoom newOffset maxZoom | 	clic := self sensor cursorPoint copy.	offset := self view container scrollOffset copy.	maxZoom := self view proxy class maxZoom.	clicWindow := clic - offset.	zoom := self view mapZoom.	event up		ifTrue: 			["zoom in"			newClic := clic * 2.			newZoom := zoom + 1]		ifFalse: 			["zoom out"			newClic := (clic / 2) rounded.			newZoom := zoom - 1].	(newZoom &gt;= 0 and: [newZoom &lt;= maxZoom])		ifTrue: 			["Change zoom" "| gc |			gc := self view graphicsContext.			gc copyArea: (Rectangle origin: 0@0 corner: 256 @ 256) from: (gc copy scaleBy: 2) sourceOffset: 0@0 destinationOffset: 0@0 .			(Delay forSeconds: 1) wait."			"self halt."			newOffset := newClic - clicWindow.			self view container setOrigin: newOffset negated.			self model value zoom: newZoom.			self model value zoomChanged.			self view mapZoom: newZoom.			self view zoomChanged: newZoom.			"bis"			self view container setOrigin: newOffset negated.			self view invalidate]</body><body package="QuickMap">processKeyboardEvent: aKeyboardEvent	aKeyboardEvent inspect</body><body package="QuickMap">redButtonPressedEvent: anEvent	"[self selectEvent: anEvent. ^self] value."	"anEvent inspect."	"clicZone"	| origine relativePosition position qtm string |	position := anEvent point.	origine := self view container container bounds origin.	relativePosition := position - origine.	qtm := self model value.	string := qtm makeLatLonStringAt: relativePosition				fromOrigin: self mapOrigin.	self pathInProgress ifTrue: [qtm addLonLat: string].	self lineInProgress ifTrue: [qtm lineArray at: 1 put: relativePosition].	self sensor ctrlDown		ifTrue: [TextEditorController copySelection: string]		ifFalse: 			[qtm clicZone				ifTrue: 					["set the controller to draw a rectangle on the map"					qtm clicZoneInProgress						ifFalse: 							["Start the drawing"							Cursor crossHair show.							qtm clicZoneInProgress: true.							clicZoneOrigin := self sensor cursorPoint]						ifTrue: 							["Finish the rectangle"							Cursor normal show.							qtm clicZoneInProgress: false.							clicZoneCorner := self sensor cursorPoint.							qtm addZone: (Rectangle origin: clicZoneOrigin corner: clicZoneCorner).							self view topComponent model doBuildGraph].					^self].			"other actions"			self sensor shiftDown				ifTrue: 					[| point tileModel |					shifted := true.					point := self sensor cursorPoint.					Cursor crossHair show.					tileModel := self model value.					"tileModel sensorPositions add: point."					tileModel addPosition: point.					tileModel pickModel points add: point.					self model value: tileModel					"Saisie "					"self reverseGeocode: point"]				ifFalse: 					[isMoving := true.					previousPoint := anEvent globalPoint.					"self sensor cursorPoint"					"Cursor hand show."					UIQuickMap closedHand show.					currentClock := Time microsecondClock.					delta := 0 @ 0.					forkAnim isNil ifFalse: [forkAnim terminate]]]</body><body package="QuickMap">redButtonReleasedEvent: anEvent	| d ppms qtm position origine relativePosition |	delta isNil ifTrue: [delta := 0].	self model value clicZone ifTrue: [^self].	position := anEvent point.	origine := self view container container bounds origin.	relativePosition := position - origine.	qtm := self model value.	self lineInProgress		ifTrue: 			[qtm lineArray at: 2 put: relativePosition.			qtm addLonLatFromLineArrayDivision: 2 fromMapOrigin: self mapOrigin].	shifted		ifFalse: 			[isMoving := false.			Cursor hand show.			"p := anEvent globalPoint."			"diff := previous - p."			"diff inspect."			d := Time microsecondClock - previousClock.	"currentClock"			ppms := delta / d * 10000.	"Nombre de pixels Ã  dÃ©placer Ã  chaque itÃ©ration"			"ppms copy inspect."			ppms abs &lt; (2 @ 2) ifTrue: [^self].			ppms x &gt; 0				ifTrue: [ppms x: (ppms x min: 1.0e2)]				ifFalse: [ppms x: (ppms x max: -1.0e2)].			ppms y &gt; 0				ifTrue: [ppms y: (ppms y min: 1.0e2)]				ifFalse: [ppms y: (ppms y max: -1.0e2)].			forkAnim := 					["Deux paramÃ¨tres rÃ¨glent l'animation de la carte."					" *** ATTENTION, DANGER : si i &lt; 1, la carte accÃ©lÃ¨re ! *** "					| i |					i := 1.05.	"Coefficient de frottement initial : Ã  ajuster suivant la courbe choisie"					[ppms abs &lt; (1 @ 1)	"ppms rounded = Point zero"] whileFalse: 							[(Delay forMilliseconds: 10) wait.							self view container scrollBy: ppms rounded.							"Plusieurs courbes de frottement : "							"Sans : suit le mouvement, ralentissement trÃ¨s doux"							"i := i + 1.000002."	"ArrÃªt brutal"							"i := i + i."	"ArrÃªt trÃ¨s brutal"							i := i * 1.002.	"Ralentissement doux, conseillÃ©"							"i := i * i."	"Suit le mouvement, puis arrÃªt brutal"							ppms := ppms / i]]							forkAt: Processor activePriority - 1]		ifTrue: [shifted := false]</body></methods><methods><class-id>QuickTileController</class-id> <category>private</category><body package="QuickMap">makeLatLonStringAt:    aPixel	| mercator zoom lonlat latitude longitude qtm meter currentPoint |	qtm := self model value.	mercator := qtm mercator.	zoom := qtm zoom.	currentPoint := aPixel + self mapOrigin.	meter := mercator pixelToMeterNew: currentPoint zoom: zoom.	lonlat := mercator meterToLonLat: meter.	latitude := lonlat y printString readStream upTo: $d.	longitude := lonlat x printString readStream upTo: $d.	^ Array with: longitude with: latitude.</body><body package="QuickMap">mapOrigin	^self view container scrollOffset</body><body package="QuickMap">mouseGeocode: position fromOrigin: origine	| strings qtm relativePosition |	relativePosition := position - origine.	qtm := self model value.	strings := qtm makeLatLonArrayOfStringAt: relativePosition				fromOrigin: self mapOrigin.	qtm geoPositionVH value: strings</body><body package="QuickMap">reverseGeocode: aPixel	| projection zoom m lonlat latitude longitude url hr r s b t jr result |	projection := self model value mercator.	zoom := self model value zoom.	m := projection pixelToMeterNew: aPixel zoom: zoom.	lonlat := projection meterToLonLat: m.	latitude := lonlat y printString readStream upTo: $d.	longitude := lonlat x printString readStream upTo: $d.	url := 'http://maps.googleapis.com/maps/api/geocode/json?latlng='				, latitude, ',', longitude				, '&amp;sensor=false'.	hr := Net.HttpRequest get: url.	[r := hr execute] on: Net.HttpException do: [:ex | r := ex parameter].	s := r value byteSource.	b := s contents.	t := b asByteString. "copy changeClassTo: ByteString." "ISO8859L1String."	jr := JSON.JsonReader readFrom: t readStream.	result := (jr at: 'results') first at: 'formatted_address'.	(result "copy changeClassTo: ISO8859L1String") inspect</body></methods><methods><class-id>QuickTileController</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	isMoving := false.	previousClock := 0.	shifted := false.	clicZoneInProgress := false.	pathInProgress := false.	lineInProgress := false.	^self</body></methods><methods><class-id>AlgoDis.CellImage</class-id> <category>printing</category><body package="PickCell">cellImagePrint: anImage on: aStream	| index pixel blue green red |	self fileOutImageExtent: anImage extent onStream: aStream. 	aStream		nextPut: $,;		space.	aStream		nextPut: $[;		space.	index := anImage extent y * anImage extent x.	0 to: anImage extent y - 1		do: 			[:y |			0 to: anImage extent x - 1				do: 					[:x |					pixel := anImage atPoint: x @ y.					blue := pixel bitAnd: 255.					pixel := pixel bitShift: -8.					green := pixel bitAnd: 255.					pixel := pixel bitShift: -8.					red := pixel bitAnd: 255.					aStream nextPut: $[.					red printOn: aStream.					aStream nextPut: $,.					green printOn: aStream.					aStream nextPut: $,.					blue printOn: aStream.					aStream nextPut: $].					index := index - 1.					aStream						space;						nextPut: (index = 0 ifTrue: [$]] ifFalse: [$,]);						space]].	"	we also want this : self geoPosition printOn: aStream."	(aStream space)		nextPut: $];		space</body><body package="PickCell">cellImagePrintCuda: anImage on: aStream	| index pixel blue green red |	self fileOutImageExtentCuda: anImage extent onStream: aStream.	aStream		nextPut: $,;		space.	aStream		nextPut: ${;		space.	index := anImage extent y * anImage extent x.	0 to: anImage extent y - 1		do: 			[:y |			0 to: anImage extent x - 1				do: 					[:x |					pixel := anImage atPoint: x @ y.					blue := pixel bitAnd: 255.					pixel := pixel bitShift: -8.					green := pixel bitAnd: 255.					pixel := pixel bitShift: -8.					red := pixel bitAnd: 255.					aStream nextPut: ${.					red printOn: aStream.					aStream nextPut: $,.					green printOn: aStream.					aStream nextPut: $,.					blue printOn: aStream.					aStream nextPut: $}.					index := index - 1.					aStream						space;						nextPut: (index = 0 ifTrue: [$}] ifFalse: [$,]);						space]].	"	we also want this : self geoPosition printOn: aStream."	(aStream space)		nextPut: $};		space</body><body package="PickCell">fileOutImageExtent: extent onStream: aStream	aStream		nextPut: $[;		space.	extent x printOn: aStream.	aStream		nextPut: $,;		space.	extent y printOn: aStream.	aStream		nextPut: $];		space</body><body package="PickCell">fileOutImageExtentCuda: extent onStream: aStream	aStream		nextPut: ${;		space.	extent x printOn: aStream.	aStream		nextPut: $,;		space.	extent y printOn: aStream.	aStream		nextPut: $} ;		space</body><body package="PickCell">printCudaOn: aStream	aStream		nextPut: ${;		space.	self cellImagePrintCuda: cellImage on: aStream.	(aStream space)		nextPut: $};		space</body><body package="PickCell">printOn: aStream	aStream		nextPut: $[;		space.	self cellImagePrint: cellImage on: aStream.	"self cellImage storeOn: aStream."	(aStream space)		nextPut: $];		space."	aStream		nextPut: $[;		space.	self geoPosition printOn: aStream.	(aStream space)		nextPut: $];		space"</body></methods><methods><class-id>AlgoDis.CellImage</class-id> <category>accessing</category><body package="PickCell">cellImage	^cellImage</body><body package="PickCell">cellImage: anObject	cellImage := anObject</body><body package="PickCell">elevation	^elevation</body><body package="PickCell">elevation: anObject	elevation := anObject</body><body package="PickCell">geoPosition	^geoPosition</body><body package="PickCell">geoPosition: anObject	geoPosition := anObject</body><body package="PickCell">geoPositionCorner	^geoPositionCorner</body><body package="PickCell">geoPositionCorner: anObject	geoPositionCorner := anObject</body><body package="PickCell">name	^name</body><body package="PickCell">name: anObject	name := anObject</body><body package="PickCell">position	^position</body><body package="PickCell">position: anObject	position := anObject</body><body package="PickCell">signature	^signature</body><body package="PickCell">signature: anObject	signature := anObject</body></methods><methods><class-id>AlgoDis.CellImage</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	cellImage := nil.	signature := nil.	position := nil.	geoPosition := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.CellImage class</class-id> <category>instance creation</category><body package="PickCell">with: image	| cm |	cm := self basicNew.	cm cellImage: image.	^cm</body></methods><methods><class-id>QuickTileProxyOverlay</class-id> <category>accessing</category><body package="QuickMap">compositePart	^compositePart</body><body package="QuickMap">compositePart: anObject	compositePart := anObject</body><body package="QuickMap">container	^container</body><body package="QuickMap">container: anObject	container := anObject</body><body package="QuickMap">dicoCompositeAtZoom: zoom	^dicoComposite at: zoom ifAbsentPut: [self computeCompositeForZoom: zoom]</body><body package="QuickMap">dicoZoom	^dicoZoom</body><body package="QuickMap">x: xTile y: yTile zoom: zoom	| modulo x y dico |	modulo := 2 raisedTo: zoom.	x := xTile \\ modulo.	y := yTile \\ modulo.	dico := self dicoZoom at: zoom ifAbsentPut: [Dictionary new: 16].	^dico at: x @ y		ifAbsentPut: 			[(QuickTileOverlay x: x y: y zoom: zoom)				container: container;				prx: self;				yourself]</body></methods><methods><class-id>QuickTileProxyOverlay</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	dicoZoom := Dictionary new: 22.	"compositePart := CompositePart new add: (Circle center: -510941 @ -362480 radius: 128) asStroker."	"shxFilename := '/home/pyves/VW/batiment/bati-WGS84.shx'.	objects := ShapefileReader readAllObjectsFromShapefile: shxFilename."	dicoComposite := Dictionary new: 22.	objects := OrderedCollection new.	^self</body></methods><methods><class-id>QuickTileProxyOverlay</class-id> <category>computing</category><body package="QuickMap">computeCompositeForZoom: zoom	| cp |	cp := CompositePart new.	objects do: 			[:each |			| sw |			sw := StrokingWrapper on: (each convertWithZoom: zoom).			cp add: sw].	cp container: self container.	^cp</body><body package="QuickMap">updateObjects: o	objects := o.	dicoComposite := Dictionary new: 22.	dicoZoom := Dictionary new: 22</body></methods><methods><class-id>QuickTileProxyOverlay class</class-id> <category>instance creation</category><body package="QuickMap">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyMadagascar</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string :=super baseWsn, '/osm_madagascar/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>QuickTileProxyMadagascar</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.GDALReader</class-id> <category>processing</category><body package="PickCell">coordToPoint: lonLat	| lon lat x y deltaEnX deltaEnY |	lon := lonLat first.	lat := lonLat at: 2.	deltaEnX := lon - self xllcorner.	x := (deltaEnX / cellsize) rounded.	deltaEnY := lat - self yllcorner.	y := (deltaEnY / cellsize) rounded.	y := (self nrows - y) rounded.	^x @ y</body><body package="PickCell">getInfo	| rs scanner |	rs := self filename readStream.	rs upTo: Character space.	self ncols: (rs upTo: Character cr) asNumber.	rs upTo: Character space.	self nrows: (rs upTo: Character cr) asNumber.	rs upTo: Character space.	self xllcorner: (rs upTo: Character cr) asNumber.	rs upTo: Character space.	self yllcorner: (rs upTo: Character cr) asNumber.	rs upTo: Character space.	self cellsize: (rs upTo: Character cr) asNumber.	rs close</body><body package="PickCell">getLine: indexFromZero	| rs |	rs := self filename readStream.	5 + indexFromZero timesRepeat: [rs upTo: Character cr].	line := rs upTo: Character cr.	rs close.	^line</body><body package="PickCell">getValueAtCoord: lonLatArray	| rs pointFromZero token | 	"compute offset ingraphic window, origin at top lefts"	pointFromZero := self  coordToPoint: lonLatArray.	rs := self filename readStream. 	5 + pointFromZero y timesRepeat: [rs upTo: Character cr].	line := rs upTo: Character cr.	rs close.	rs := line readStream.	rs next. " discard a space, then skip x values"	pointFromZero x timesRepeat: [token := rs upTo: Character space].	token := rs upTo: Character space.	^token asNumber</body><body package="PickCell">getValueAtPoint: pointFromZero	| rs scanner |	rs := self filename readStream.	5 + pointFromZero y timesRepeat: [rs upTo: Character cr].	line := rs upTo: Character cr.	rs close.	rs := line readStream.	scanner := Parser new on: rs.	pointFromZero x timesRepeat: [scanner scanToken].	^scanner scanToken</body><body package="PickCell">pointToCoord: pointFromZero	| lon lat |	lon := self xllcorner + (pointFromZero x * self cellsize).	lat := self yllcorner+ ((self nrows - pointFromZero y) * self cellsize).	^Array with: lon with: lat</body></methods><methods><class-id>AlgoDis.GDALReader</class-id> <category>accessing</category><body package="PickCell">cellsize	^cellsize</body><body package="PickCell">cellsize: anObject	cellsize := anObject</body><body package="PickCell">filename	^filename</body><body package="PickCell">filename: anObject	filename := anObject</body><body package="PickCell">line	^line</body><body package="PickCell">line: anObject	line := anObject</body><body package="PickCell">ncols	^ncols</body><body package="PickCell">ncols: anObject	ncols := anObject</body><body package="PickCell">nrows	^nrows</body><body package="PickCell">nrows: anObject	nrows := anObject</body><body package="PickCell">xllcorner	^xllcorner</body><body package="PickCell">xllcorner: anObject	xllcorner := anObject</body><body package="PickCell">yllcorner	^yllcorner</body><body package="PickCell">yllcorner: anObject	yllcorner := anObject</body></methods><methods><class-id>AlgoDis.GDALReader</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	filename := nil.	ncols := nil.	nrows := nil.	xllcorner := nil.	yllcorner := nil.	cellsize := nil.	line := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.GDALReader class</class-id> <category>testing</category><body package="PickCell">test1	"GDALReader test1"	^self default getInfo</body><body package="PickCell">test2	"GDALReader test2"	| gdal |	gdal := self default getInfo.	^gdal getLine: 1500</body><body package="PickCell">test3	"GDALReader test3"	| gdal |	gdal := self default getInfo.	^gdal getValueAtPoint: 1500 @ 1500</body><body package="PickCell">test4	"GDALReader test4"	| gdal |	gdal := self default getInfo.	^gdal coordToPoint: (Array with: -4.9 with: 48.6)</body><body package="PickCell">test5	"GDALReader test5"	| gdal point |	gdal := self default getInfo.	point := gdal coordToPoint: (Array with: -4.9 with: 48.6).	^gdal getValueAtPoint: point</body><body package="PickCell">test6	"GDALReader test6"	| gdal coord |	gdal := self default getInfo.	coord := gdal pointToCoord: 2000 @ 2000.	^coord</body><body package="PickCell">test7	"GDALReader test7"	| gdal coord ws elevation |	gdal := self default getInfo.	ws := 'test.text' asFilename writeStream.	ws		nextPutAll: 'longitude, latitude, elevation';		cr.	3600 - 5 to: 3600		do: 			[:yPos |			3600 - 5 to: 3600				do: 					[:xPos |					coord := gdal pointToCoord: xPos @ yPos.					elevation := gdal getValueAtPoint: xPos @ yPos.					coord first printOn: ws.					ws nextPut: $,. 					coord last printOn: ws.					ws nextPut: $,. 					elevation printOn: ws.					ws						cr;						flush]].	ws close</body><body package="PickCell">test8	"GDALReader test8"	| array gdal |	array := #(#(-4.00153 48.0015 #, 50) #(-4.00125 48.0015 #, 48) #(-4.00097 48.0015 #, 45)).	gdal := self default getInfo.	^array collect: [:line | gdal getValueAtCoord: line]</body></methods><methods><class-id>AlgoDis.GDALReader class</class-id> <category>instance creation</category><body package="PickCell">default	| filename def |	filename := Filename				fromComponents: #('$(VISUALWORKS)' 'pickcell' 'ASTGTM2_N48W005_dem.txt').	def := self on: filename.	def getInfo.	^def</body><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="PickCell">on: filename	"Answer a newly created and initialized instance."	| gdar |	gdar := self new.	gdar filename: filename.	^gdar</body></methods><methods><class-id>AlgoDis.PickCellDBAccess</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.PickCellDBAccess class</class-id> <category>instance creation</category><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>AlgoDis.PickCellDBAccess class</class-id> <category>testing</category><body package="PickCell">test1	| conn sess |	conn := PostgresSocketConnection connectionForVietnam.	conn connect.	"Run a Simple Query (just a string--no binding)."	sess := conn getSession.	conn disconnect</body></methods><methods><class-id>ShapefileReader</class-id> <category>old testing</category><body package="MapAccess">testDumpSHP	| test |	test := ShapefileReader new.	(test dumpSHP: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_administrative.shx') inspect</body><body package="MapAccess">testEnsemblePoint	| shape tabShape nbShape |	shape := ShapefileReader new.	ShapefileReader unloadLibraries.	tabShape := OrderedCollection new.	nbShape := 200.	(0 to: nbShape - 1)		do: [:i | tabShape add: (shape oneSHP: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_administrative.shx' with: i)].	tabShape inspect</body><body package="MapAccess">testEnsemblePointNew	| shape tabShape nbShape |	shape := ShapefileReader new.	ShapefileReader unloadLibraries.	tabShape := OrderedCollection new.	nbShape := shape SHPSize: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_administrative.shx'.	(0 to: nbShape - 1)		do: [:i | tabShape add: (shape oneSHP: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_administrative.shx' with: i)].	tabShape inspect</body><body package="MapAccess">testGPSPositionTab	"  MyShapes new testGPSPositionTab inspect  "	^(ShapefileReader new toGPSPositionTab: '/export/users/wsn/Herry/Netgen/building.shx')</body><body package="MapAccess">testGpsPosition	"| shape shpFigure tabFigure size shpObject filename |	filename := '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_administrative.shx'.	shape := MyShapes new.	tabFigure := OrderedCollection new.	(0 to: 1) do: 			[:i |			shpObject := shape oneSHP: filename with: i.			size := shape nParts: shpObject.			(1 to: size) do: 					[:ix |					ix = size						ifTrue: 							[shpFigure := ShpFigure new.							shpFigure type: ((shape panPartTypeToTab: shpObject) at: size).							(((shape panPartStartToTab: shpObject) at: ix) to: (shape nVertices: shpObject)) do: 									[:j |									shpFigure x add: ((shape padfToTab: shpObject with: #padfX) at: j).									shpFigure y add: ((shape padfToTab: shpObject with: #padfY) at: j)									""shpFigure z add: ((shape padfToTab: shpObject with: #padfZ) at: j).									shpFigure m add: ((shape padfToTab: shpObject with: #padfM) at: j)""].							tabFigure add: shpFigure]						ifFalse: 							[shpFigure := ShpFigure new.							shpFigure type: ((shape panPartTypeToTab: shpObject) at: i).							(((shape panPartStartToTab: shpObject) at: i) to: ((shape panPartStartToTab: shpObject) at: i + 1)) do: 									[:j |									shpFigure x add: ((shape padfToTab: shpObject with: #padfX) at: j).									shpFigure y add: ((shape padfToTab: shpObject with: #padfY) at: j)									""shpFigure z add: ((shape padfToTab: shpObject with: #padfZ) at: j).									shpFigure m add: ((shape padfToTab: shpObject with: #padfM) at: j)""].							tabFigure add: shpFigure]]].	(tabFigure at:1) toGPSPosition inspect"</body><body package="MapAccess">testOneSHP	| test |	test := ShapefileReader new.	(test oneSHP: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_administrative.shx' with: 2) inspect</body><body package="MapAccess">testPartStartToTab	| shape tab |	shape := ShapefileReader new.	tab := shape toTab: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_water.shx'.	(shape panPartStartToTab: (tab at: 5)) inspect.</body><body package="MapAccess">testSize	| test |	test := ShapefileReader new.	(test SHPSize:'/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_water.shx') inspect.</body><body package="MapAccess">testTab	| shape tab |	shape := ShapefileReader new.	tab := shape toTab: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_water.shx'.	tab inspect</body><body package="MapAccess">testToShapeFigureTab	| shape tabFigure |	shape := ShapefileReader new.	tabFigure := shape toShapeFigureTab: '/export/users/wsn/Herry/legall/batiment/bati.shx'. 	^self adapt: tabFigure</body><body package="MapAccess">testToShapeFigureTabNew	| shape tabFigure |	shape := ShapefileReader new.	tabFigure := shape toShapeFigureTab: '/export/users/wsn/Herry/legall/batiment/bati.shx'.	tabFigure inspect</body><body package="MapAccess">testpadfXToTab	| shape tab |	shape := ShapefileReader new.	tab := shape toTab: '/export/users/wsn/Herry/Netgen/shapebuild/example/europe_western_europe_france_bretagne_water.shx'.	(shape padfToTab:(tab at: 1)with: #padfX) inspect.</body></methods><methods><class-id>ShapefileReader</class-id> <category>old computing</category><body package="MapAccess">GPSPositionTabOld:filename	"| shape tabGpsPos tabFigure |	shape := MyShapes new.	tabGpsPos := OrderedCollection new.	tabFigure := shape toShapeFigureTab: filename.	tabFigure do: [:figure | tabGpsPos add: figure toGPSPosition].	^tabGpsPos"</body><body package="MapAccess">adapt: tabFigure	"^tabFigure collect: [:fig | Polyline vertices: fig toPoint]"</body><body package="MapAccess">affichage:col	| win comp range wrapper points I |	range := 0 to: 500.	win := ScheduledWindow	model: nil	label: #UnclippedExample &lt;&lt; #labels &gt;&gt; 'unclipped'	minimumSize: range last @ range last.			points := col copyWith:col first.	"relie la derniere avec la premiere"			I := Polyline vertices: points.			comp := CompositePart new.			wrapper := I asFiller.			comp add: ((GraphicsAttributesWrapper on: wrapper) attributes: (GraphicsAttributes new paint: ColorValue green)).		comp add: I asStroker.	win component: (BoundedWrapper on: comp).	win openIn: (50 @ 50 extent: 500 @ 500)	"	|t point col point2 |			point := OrderedCollection new.			point add: 350.154d@100.2202d;			add:  150.524654d@150.15241d;			add:  50.456d@60.4564d;			add:  110.546d@100.46847d.	t := MyShapes new.	t affichage: point."</body><body package="MapAccess">nParts: aShape	^aShape memberAt: #nParts</body><body package="MapAccess">nVertices: aShape	^aShape memberAt: #nVertices</body><body package="MapAccess">padfToTab: aShape with: padf	| tab |	tab := OrderedCollection new.	(0 to: (aShape memberAt: #nVertices) - 1) do: [:i | tab add: ((aShape memberAt: padf) at: i)].	^tab.</body><body package="MapAccess">panPartStartToTab: aShape	| tab |	tab := OrderedCollection new.	(0 to: (aShape memberAt: #nParts) - 1) do: [:i | tab add: (((aShape memberAt: #panPartStart) at: i)+1)].	^tab</body><body package="MapAccess">panPartTypeToTab: aShape	| tab |	tab := OrderedCollection new.	(0 to: (aShape memberAt: #nParts) - 1) do: [:i | tab add: ((aShape memberAt: #panPartType) at: i)].	^tab</body><body package="MapAccess">tabShapeFigureToTabPoint: tabShpFigure	"| tabPoint |	tabPoint := OrderedCollection new.	tabShpFigure do: [:shpFigure | tabPoint add: shpFigure toPoint].	^tabPoint"</body><body package="MapAccess">toGPSPositionTab: filename	"| shape nbShape tabFigure size shpObject gps tabGps |	shape := MyShapes new.	nbShape := shape SHPSize: filename.	tabFigure := OrderedCollection new.	(0 to: nbShape - 1) do: 			[:i |			""shpObject := shape oneSHP: filename with: i.""			shpObject := ShapeCache new oneSHP: filename with: i.			size := shape nParts: shpObject.			(1 to: size) do: 					[:ix |					ix = size						ifTrue: 							[tabGps := OrderedCollection new.							(((shape panPartStartToTab: shpObject) at: ix) to: (shape nVertices: shpObject)) do: 									[:j |									gps := GPSPosition new.									gps										longitude: ((shape padfToTab: shpObject with: #padfX) at: j);										latitude: ((shape padfToTab: shpObject with: #padfY) at: j).									tabGps add: gps].							tabFigure add: tabGps]						ifFalse: 							[tabGps := OrderedCollection new.							(((shape panPartStartToTab: shpObject) at: ix) to: ((shape panPartStartToTab: shpObject) at: ix + 1)) do: 									[:j |									gps := GPSPosition new.									gps										longitude: ((shape padfToTab: shpObject with: #padfX) at: j);										latitude: ((shape padfToTab: shpObject with: #padfY) at: j).									tabGps add: gps].							tabFigure add: tabGps]]].	^tabFigure"</body><body package="MapAccess">toSHPPositionTab: filename origin:o scale:scale	"| shape nbShape tabFigure size shpObject gps tabGps |	shape := MyShapes new.	nbShape := shape SHPSize: filename.	tabFigure := OrderedCollection new.	(0 to: nbShape - 1) do: 			[:i |			shpObject := shape oneSHP: filename with: i.			size := shape nParts: shpObject.			(1 to: size) do: 					[:ix |					ix = size						ifTrue: 							[tabGps := OrderedCollection new.							(((shape panPartStartToTab: shpObject) at: ix) to: (shape nVertices: shpObject)) do: 									[:j |									gps := GPSPosition new.									gps										longitude: ((shape padfToTab: shpObject with: #padfX) at: j);										latitude: ((shape padfToTab: shpObject with: #padfY) at: j).									tabGps add: (gps convertFromOrigin:o scale:scale )].							tabFigure add: tabGps]						ifFalse: 							[tabGps := OrderedCollection new.							(((shape panPartStartToTab: shpObject) at: ix) to: ((shape panPartStartToTab: shpObject) at: ix + 1)) do: 									[:j |									gps := GPSPosition new.									gps										longitude: ((shape padfToTab: shpObject with: #padfX) at: j);										latitude: ((shape padfToTab: shpObject with: #padfY) at: j).									tabGps add: (gps convertFromOrigin:o scale:scale )].							tabFigure add: tabGps]]].	^tabFigure"</body><body package="MapAccess">toShapeFigureTab: filename	"| shape nbShape shpFigure tabFigure size shpObject |	shape := MyShapes new.	nbShape := shape SHPSize: filename.	tabFigure := OrderedCollection new.	(0 to: nbShape - 1) do: 			[:i |			shpObject := shape oneSHP: filename with: i.			size := shape nParts: shpObject.			(1 to: size) do: 					[:ix |					ix = size						ifTrue: 							[shpFigure := ShpFigure new.							shpFigure type: ((shape panPartTypeToTab: shpObject) at: size).							(((shape panPartStartToTab: shpObject) at: ix) to: (shape nVertices: shpObject)) do: 									[:j |									shpFigure x add: ((shape padfToTab: shpObject with: #padfX) at: j).									shpFigure y add: ((shape padfToTab: shpObject with: #padfY) at: j)									""shpFigure z add: ((shape padfToTab: shpObject with: #padfZ) at: j).									shpFigure m add: ((shape padfToTab: shpObject with: #padfM) at: j)""].							tabFigure add: shpFigure]						ifFalse: 							[shpFigure := ShpFigure new.							shpFigure type: ((shape panPartTypeToTab: shpObject) at: ix).							(((shape panPartStartToTab: shpObject) at: ix) to: ((shape panPartStartToTab: shpObject) at: ix + 1)) do: 									[:j |									shpFigure x add: ((shape padfToTab: shpObject with: #padfX) at: j).									shpFigure y add: ((shape padfToTab: shpObject with: #padfY) at: j)									""shpFigure z add: ((shape padfToTab: shpObject with: #padfZ) at: j).									shpFigure m add: ((shape padfToTab: shpObject with: #padfM) at: j)""].							tabFigure add: shpFigure]]].	^tabFigure"</body><body package="MapAccess">toTab:filename	| shape tab nbShape |	shape := ShapefileReader new.	tab := OrderedCollection new.	nbShape := shape SHPSize:filename.	(0 to: nbShape - 1) do: [:i | tab add: (shape oneSHP: filename with: i)].	^tab.</body></methods><methods><class-id>ShapefileReader</class-id> <category>accessing</category><body package="MapAccess">entities	entitiesPtr isNil ifFalse: [^entitiesPtr contents] ifTrue: [^nil]</body><body package="MapAccess">filename	^filename</body><body package="MapAccess">filename: anObject	filename := anObject</body><body package="MapAccess">maxBoundM	padfMaxBoundPtr isNil ifFalse: [^padfMaxBoundPtr at: 3] ifTrue: [^nil]</body><body package="MapAccess">maxBoundX	padfMaxBoundPtr isNil ifFalse: [^padfMaxBoundPtr at: 0] ifTrue: [^nil]</body><body package="MapAccess">maxBoundY	padfMaxBoundPtr isNil ifFalse: [^padfMaxBoundPtr at: 1] ifTrue: [^nil]</body><body package="MapAccess">maxBoundZ	padfMaxBoundPtr isNil ifFalse: [^padfMaxBoundPtr at: 2] ifTrue: [^nil]</body><body package="MapAccess">minBoundM	padfMinBoundPtr isNil ifFalse: [^padfMinBoundPtr at: 3] ifTrue: [^nil]</body><body package="MapAccess">minBoundX	padfMinBoundPtr isNil ifFalse: [^padfMinBoundPtr at: 0] ifTrue: [^nil]</body><body package="MapAccess">minBoundY	padfMinBoundPtr isNil ifFalse: [^padfMinBoundPtr at: 1] ifTrue: [^nil]</body><body package="MapAccess">minBoundZ	padfMinBoundPtr isNil ifFalse: [^padfMinBoundPtr at: 2] ifTrue: [^nil]</body><body package="MapAccess">shapeType	shapeTypePtr isNil ifFalse: [^shapeTypePtr contents] ifTrue: [^nil]</body></methods><methods><class-id>ShapefileReader</class-id> <category>api</category><body package="MapAccess">close	"Care must be taken when you free memory!"	handle isNil		ifFalse: 			[self SHPClose: handle.			handle := nil]</body><body package="MapAccess">destroyObject: psObjectPtr	psObjectPtr isNil ifFalse: [self SHPDestroyObject: psObjectPtr]</body><body package="MapAccess">getInfo	handle isNil		ifFalse: 			[entitiesPtr := CIntegerType int gcMalloc.			shapeTypePtr := CIntegerType int gcMalloc.			padfMinBoundPtr := CLimitedPrecisionRealType double gcMalloc: 4.			padfMaxBoundPtr := CLimitedPrecisionRealType double gcMalloc: 4.			self				SHPGetInfo: handle				with: entitiesPtr				with: shapeTypePtr				with: padfMinBoundPtr				with: padfMaxBoundPtr]</body><body package="MapAccess">open	handle := self SHPOpen: filename with: 'rb'</body><body package="MapAccess">readObject: anInteger	handle isNil ifFalse: [^self SHPReadObject: handle with: anInteger] ifTrue: [^nil]</body></methods><methods><class-id>ShapefileReader class</class-id> <category>old computing</category><body package="MapAccess">ShapeOriente: GPSPoint with: GPSPositionTabClose with:gf	"retourne les batiments en finction de la distance "	"| tabFinal tabNE tabNO tabSE tabSO |	tabFinal := Dictionary new.	tabNE := OrderedCollection new.	tabNO := OrderedCollection new.	tabSE := OrderedCollection new.	tabSO := OrderedCollection new.	GPSPositionTabClose do: 			[:tab |			| tabTest |			tabTest := OrderedCollection new.			tabTest				add: False;				add: False;				add: False;				add: False.			tab do: 					[:aGPSPosition |					| angle |					angle := Transmitter angle: GPSPoint with: (aGPSPosition convertFromOrigin: gf origin scale: gf scale).					(angle &gt;= 0) &amp; (angle &lt; 90) ifTrue: [tabTest at: 1 put: True].					(angle &gt;= 90) &amp; (angle &lt; 180) ifTrue: [tabTest at: 2 put: True].					(angle &gt;= 180) &amp; (angle &lt; 270) ifTrue: [tabTest at: 3 put: True].					(angle &gt;= 270) &amp; (angle &lt; 360) ifTrue: [tabTest at: 4 put: True]].			((tabTest at: 1) = True) | (((tabTest at: 2) = True)&amp;((tabTest at: 4) = True)) ifTrue: [tabSE add: tab].			((tabTest at: 2) = True)| (((tabTest at: 1) = True)&amp;((tabTest at: 3) = True)) ifTrue: [tabSO add: tab].			((tabTest at: 3) = True)| (((tabTest at: 2) = True)&amp;((tabTest at: 4) = True)) ifTrue: [tabNO add: tab].			((tabTest at: 4) = True)| (((tabTest at: 3) = True)&amp;((tabTest at: 1) = True)) ifTrue: [tabNE add: tab]].	tabFinal at:#SE put:tabSE;at:#SO put:tabSO;at:#NO put:tabNO;at:#NE put:tabNE.	^tabFinal"</body><body package="MapAccess">distance2Point: pointA with: pointB with:reference	"distance entre deux points"	"| a b |	a:=reference translateToGPSFromPoint:pointA.	b:=reference translateToGPSFromPoint:pointB.	^self distance2PointGps: a with: b."</body><body package="MapAccess">distance2PointGps: pointA with: pointB	"distance entre deux points"	| rlo1 rla1 rlo2 rla2 dlo dla a b earth_radius |	earth_radius := 6378137.	rlo1 := pointA longitude degreesToRadians.	rla1 := pointA latitude degreesToRadians.	rlo2 := pointB longitude degreesToRadians.	rla2 := pointB latitude degreesToRadians.	dlo := (rlo2 - rlo1) / 2.	dla := (rla2 - rla1) / 2.	a := dla sin * dla sin + (rla1 cos * rla2 cos * dlo sin * dlo sin).	b := 2 * (a sqrt / (1 - a) sqrt) arcTan.	^(earth_radius * b) asInteger</body><body package="MapAccess">getShapeClose: GPSPoint with: puis with: GPSPositionTab 	"retourne les batiments en finction de la distance "	| tabClose |	tabClose := OrderedCollection new.	GPSPositionTab do: 			[:tab |			| close |			close := False.			tab do: 					[:aGPSPosition |					| d |					d := ShapefileReader distance2PointGps: GPSPoint with: aGPSPosition .					d &lt; puis ifTrue: [close := True]].			close = True ifTrue: [tabClose add: tab]].	^tabClose</body><body package="MapAccess">pointGPSCircle	"En Cours"	"| point angle d pointB |	point := GPSPosition new.	point		latitude: 48.38793d;		longitude: -4.48192d.	angle := 10 degreesToRadians.	d := 200.	pointB := GPSPosition new." 	"pointB latitude:point latitude + d*angle cos;			longitude: "</body><body package="MapAccess">testDistance2GPSPosition	"  MyShapes testDistance2GPSPosition inspect "	"| pointC pointD d |	pointC := GPSPosition new.	pointC		latitude: 48.38793d;		longitude: -4.48192d.	pointD := GPSPosition new.	pointD		latitude: 48.38759d;		longitude: -4.48116d.	d := self distance2PointGps: pointC with: pointD.	^d"</body><body package="MapAccess">testGetShapeClose	"  MyShapes testGetShapeClose inspect.  "	"| tabGPSPosition point tabClose |	tabGPSPosition := MyShapes new testGPSPositionTab.	point := GPSPosition new.	point		latitude: 48.400431d;		longitude: -4.501357d.	tabClose:=self getShapeClose: point with: 200 with: tabGPSPosition.	^tabClose."</body><body package="MapAccess">testSHPPositionTab	" MyShapes testSHPPositionTab inspect "	"| origine |	origine:= GPSPosition new.	origine		latitude: 48.409666667s;		longitude: -4.520861111s.	^(MyShapes new toSHPPositionTab:'/export/users/wsn/Herry/Netgen/building.shx ' origin:origine scale: 0.000026096s @ -0.000017879s)"</body></methods><methods><class-id>ShapefileReader class</class-id> <category>instance creation</category><body package="MapAccess">checkFile: aFilenameOrString	"Both '.shp' and '.shx files must be in the same directory, with the same name"	| s f |	s := aFilenameOrString asFilename asString copy.	"Test if '.shp' file exists"	s at: s size put: $p.	f := s asFilename.	f exists ifFalse: [self error: 'file ' , s , ' is missing.'].	f isReadable ifFalse: [self error: 'file ' , s , ' is not readable.'].	"Test if '.shx' file exists"	s at: s size put: $x.	f := s asFilename.	f exists ifFalse: [self error: 'file ' , s , ' is missing.'].	f isReadable ifFalse: [self error: 'file ' , s , ' is not readable.']</body><body package="MapAccess">file: aFilenameOrString	self checkFile: aFilenameOrString.	^self new filename: aFilenameOrString asString</body></methods><methods><class-id>ShapefileReader class</class-id> <category>testing</category><body package="MapAccess">allBatimentsFromShapefile: aFilename	"self testAllBatiments"	| colShape |	colShape := self allSHPFromFile: aFilename.	^colShape collect: 			[:shape |			| b positions nVertices gp |			nVertices := shape memberAt: #nVertices.			positions := (0 to: nVertices - 1) collect: 							[:index |							| longitude latitude altitude |							longitude := (shape memberAt: #padfX) at: index.							latitude := (shape memberAt: #padfY) at: index.							altitude := (shape memberAt: #padfZ) at: index.							gp := GeoPosition lon: longitude lat: latitude elevation: altitude.							gp].			b := Batiment withPositions: positions.			b]</body><body package="MapAccess">allSHPFromFile: filename	"self testAllSHP"	| shape nbShape allShape colShape |	self unloadLibraries.	shape := self new.	nbShape := shape SHPSize: filename.	allShape := shape allSHP: filename.	colShape := (0 to: nbShape - 1) collect: 					[:i |					| oneShape |					oneShape := allShape at: i.					oneShape].	^colShape</body><body package="MapAccess">readAllObjectsFromShapefile: aFilenameOrString	"self readAllObjectsFromShapefile"	| sr nb objCol batCol |	sr := self file: aFilenameOrString asString.	sr open.	sr getInfo.	nb := sr entities.	objCol := (0 to: nb - 1) collect: 					[:i |					| obj |					obj := sr readObject: i.					obj].	batCol := objCol collect: 					[:shape |					| b positions nVertices |					nVertices := shape memberAt: #nVertices.					positions := (0 to: nVertices - 1) collect: 									[:index |									| longitude latitude altitude gp |									longitude := (shape memberAt: #padfX) at: index.									latitude := (shape memberAt: #padfY) at: index.									altitude := (shape memberAt: #padfZ) at: index.									gp := GeoPosition lon: longitude lat: latitude elevation: altitude.									gp].					b := Batiment withPositions: positions.					b].	objCol do: [:each | sr destroyObject: each].	sr close.	^batCol</body><body package="MapAccess">test1	"self test1"	| shape tabShape nbShape filename |	self unloadLibraries.	shape := self new.	tabShape := OrderedCollection new.	filename := Dialog				requestFileName: 'Open SHX file'				default: '*.shx'				version: #mustBeOld				ifFail: [^nil].	nbShape := shape SHPSize: filename.	(0 to: nbShape - 1) do: [:i | tabShape add: (shape oneSHP: filename with: i)].	^tabShape</body><body package="MapAccess">test1bis: aFilename	"self test1bis"	| shape tabShape nbShape |	self unloadLibraries.	shape := self new.	tabShape := OrderedCollection new.	nbShape := shape SHPSize: aFilename.	(0 to: nbShape - 1) do: [:i | tabShape add: (shape oneSHP: aFilename with: i)].	^tabShape</body><body package="MapAccess">test2	"self test2"	| tabShape nbShape colBat |	tabShape := self test1.	nbShape := tabShape size.	colBat := tabShape collect: 					[:shape |					| b positions nVertices gp |					nVertices := shape memberAt: #nVertices.					positions := (0 to: nVertices - 1) collect: 									[:index |									| longitude latitude altitude |									longitude := (shape memberAt: #padfX) at: index.									latitude := (shape memberAt: #padfY) at: index.									altitude := (shape memberAt: #padfZ) at: index.									gp := GeoPosition lon: longitude lat: latitude elevation: altitude.									gp].					b := Batiment withPositions: positions.					b].	^colBat</body><body package="MapAccess">test2bis: aFilename	"self test2"	| tabShape nbShape colBat |	tabShape := self test1bis: aFilename.	nbShape := tabShape size.	colBat := tabShape collect: 					[:shape |					| b positions nVertices gp |					nVertices := shape memberAt: #nVertices.					positions := (0 to: nVertices - 1) collect: 									[:index |									| longitude latitude altitude |									longitude := (shape memberAt: #padfX) at: index.									latitude := (shape memberAt: #padfY) at: index.									altitude := (shape memberAt: #padfZ) at: index.									gp := GeoPosition lon: longitude lat: latitude elevation: altitude.									gp].					b := Batiment withPositions: positions.					b].	^colBat</body><body package="MapAccess">testAllBatiments	"self testAllBatiments"	| colShape |	colShape := self testAllSHP.	^colShape collect: 					[:shape |					| b positions nVertices gp |					nVertices := shape memberAt: #nVertices.					positions := (0 to: nVertices - 1) collect: 									[:index |									| longitude latitude altitude |									longitude := (shape memberAt: #padfX) at: index.									latitude := (shape memberAt: #padfY) at: index.									altitude := (shape memberAt: #padfZ) at: index.									gp := GeoPosition lon: longitude lat: latitude elevation: altitude.									gp].					b := Batiment withPositions: positions.					b].</body><body package="MapAccess">testAllSHP	"self testAllSHP"	| shape nbShape filename allShape colShape |	self unloadLibraries.	shape := self new.	filename := Dialog				requestFileName: 'Open SHX file'				default: '*.shx'				version: #mustBeOld				ifFail: [^nil].	nbShape := shape SHPSize: filename.	allShape := shape allSHP: filename.	colShape := (0 to: nbShape - 1) collect: 					[:i |					| oneShape |					oneShape := allShape at: i.					oneShape].	^colShape</body><body package="MapAccess">testGetInfo	"self testGetInfo"	| sr |	sr := self testOpen.	sr getInfo.	^sr</body><body package="MapAccess">testOpen	"self testOpen"	| filename sr |	filename := Dialog				requestFileName: 'Open SHX file'				default: '*.shx'				version: #mustBeOld				ifFail: [^nil].	sr := self file: filename.	sr open.	^sr</body><body package="MapAccess">testReadAllObjects	"self testReadAllObjects"	| sr nb objCol b |	sr := self testGetInfo.	nb := sr entities.	objCol := (0 to: nb - 1) collect: 					[:i |					| obj |					obj := sr readObject: i.					obj].	self halt.	b := Bag new.	objCol do: 			[:each |			"p := each memberAt: #nSHPType."			| p |			p := each memberAt: #nParts.			b add: p].	b inspect.	objCol do: [:each | sr destroyObject: each].	^sr close</body><body package="MapAccess">testReadAllObjectsMultiPart	"self testReadAllObjectsMultiPart"	| sr nb objCol objColMultiPart |	sr := self testGetInfo.	nb := sr entities.	objCol := (0 to: nb - 1) collect: 					[:i |					| obj |					obj := sr readObject: i.					obj].	objColMultiPart := objCol select: 					[:each |					| p |					p := each memberAt: #nParts.					p &gt; 1].	objColMultiPart inspect.	self halt.	objCol do: [:each | sr destroyObject: each].	^sr close</body><body package="MapAccess">testReadAllObjectsMultiPart2	"self testReadAllObjectsMultiPart2"	| sr nb objCol objColMultiPart |	sr := self testGetInfo.	nb := sr entities.	objCol := (0 to: nb - 1) collect: 					[:i |					| obj |					obj := sr readObject: i.					obj].	objColMultiPart := objCol select: 					[:each |					| parts startVertex nVertices verticesX |					parts := each memberAt: #nParts.					nVertices := each memberAt: #nVertices.					verticesX := (0 to: nVertices - 1) collect: [:v | each memberAt: #padfX at: v].					parts &gt; 1 ifTrue: [startVertex := (0 to: parts - 1) collect: [:i | each memberAt: #panPartStart at: i]] ifFalse: [startVertex := #(0)].					parts &gt; 1].	objColMultiPart inspect.	self halt.	objCol do: [:each | sr destroyObject: each].	^sr close</body><body package="MapAccess">testReadObject	"self testReadObject"	| sr obj |	sr := self testGetInfo.	obj := sr readObject: 0.	self halt.	sr destroyObject: obj.	^sr close</body></methods><methods><class-id>MapAccess</class-id> <category>accessing</category><body package="MapAccess">clicPointVH	^clicPointVH</body><body package="MapAccess">clicPointVH: anObject	clicPointVH := anObject</body><body package="MapAccess">component	^component</body><body package="MapAccess">component: anObject	component := anObject</body><body package="MapAccess">mapTileCache	^mapTileCache</body><body package="MapAccess">mapTileCache: anObject	mapTileCache := anObject</body><body package="MapAccess">x: x y: y zoom: z	xTile := x.	yTile := y.	zoom := z</body><body package="MapAccess">xTile	^xTile</body><body package="MapAccess">yTile	^yTile</body><body package="MapAccess">zoom	^zoom</body></methods><methods><class-id>MapAccess</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	mapTileCache := MapTileCache new.	clicPointVH := (0 @ 0) asValue.	^self</body></methods><methods><class-id>MapAccess</class-id> <category>constants</category><body package="MapAccess">tileHeight	^256</body><body package="MapAccess">tileWidth	^256</body></methods><methods><class-id>MapAccess</class-id> <category>displaying</category><body package="MapAccess">displayOn: aGraphicsContext	| cp origin corner startX startY endX endY tileWidth tileHeight |	tileWidth := self tileWidth.	tileHeight := self tileHeight.	cp := aGraphicsContext clippingBounds.	origin := cp origin.	corner := cp corner.	startX := origin x // tileWidth.	startY := origin y // tileHeight.	endX := corner x // tileWidth.	endY := corner y // tileHeight.	startX to: endX		do: 			[:x |			startY to: endY				do: 					[:y |					| currentTileX currentTileY mapTile |					currentTileX := xTile + x.					currentTileY := yTile + y.					mapTile := mapTileCache x: currentTileX y: currentTileY zoom: zoom.					mapTile displayOn: aGraphicsContext at: (x * tileWidth) @ (y * tileHeight)]]</body></methods><methods><class-id>MapAccess class</class-id> <category>instance creation</category><body package="MapAccess">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyOSM</class-id> <category>private</category><body package="QuickMap">getUri1: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://tile.openstreetmap.org/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri2: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://tile.openstreetmap.fr/osmfr' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://tile.openstreetmap.org/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body></methods><methods><class-id>QuickTileProxyOSM</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyOSM class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	^'Open Street Map'</body><body package="QuickMap">maxSocket	^6</body><body package="QuickMap">maxZoom	^19</body></methods><methods><class-id>GPSTrackingInterface</class-id> <category>interface opening</category><body package="PickCell">postOpenWith: aSPec	(self builder componentAt: #startTrackingLog) enable.	(self builder componentAt: #startTrackingDB) enable.	(self builder componentAt: #stopTracking) disable</body></methods><methods><class-id>GPSTrackingInterface</class-id> <category>actions</category><body package="PickCell">doUpload	| aName filename rs line ls pm gpsValue sqlCmd |	pm := UIPickCellNodes new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[line := rs upTo: Character cr.							ls := line readStream.							gpsValue := ls upToEnd.							gpsValue isEmpty								ifFalse: 									[sqlCmd := 'INSERT INTO May182017(recocoData) VALUES(''' , gpsValue , ''')'.									pm										appendData: 'osm'										password: 'fare&amp;bali'										environment: 'wsn.univ-brest.fr:8080_vietnamTuyen'										strSql: sqlCmd]]].			rs close].	^self</body><body package="PickCell">parseLatLon: aString	| ls n ch entier decimal number numberString north |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	north := ls last = $N.	north ifFalse: [number := number negated].	numberString:= number printString.	number:= numberString copyFrom: 1 to: numberString size - 1.	^number</body><body package="PickCell">startTracking	| bufferPointer numChar ws buffer portOk trackPoint name filename wf |	self		getData: 			[USBSerial unloadLibraries.			usb := USBSerial new.			usb initialize.			"Create a new file for logging data if it does not exist"			"name := '/Users/monmac/Documents/trackGPSPoints.txt'.			filename := name asFilename.			wf := filename writeStream.			wf close."			usb RS232_CloseComport: 27.			Transcript				show: Time now printString;				cr.			buffer := String new: 4096.			bufferPointer := buffer gcCopyToHeap.			portOk := usb						setReadBuf: bufferPointer						with: 4095						with: 27						with: 115200.			usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 115200.			portOk = 0				ifFalse: 					[Transcript						show: 'open error';						cr]				ifTrue: 					[[true] whileTrue: 							[numChar := usb										readBuf: bufferPointer										with: 4095										with: 27										with: 115200.							ws := String new writeStream.							0 to: numChar - 1								do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].							Transcript								show: numChar printString;								tab;								show: ws contents.							trackPoint := TrackPoint from: ws contents.							trackPoint isNil								ifFalse: 									[APoint := trackPoint.									name := 'points.txt'.									filename := name asFilename.									wf := filename readAppendStream.									wf isWritable										ifTrue: 											[wf nextPutAll: ws contents.											wf close]].							(Delay forSeconds: 1) wait].					usb RS232_CloseComport: 27]]					fork.	(self builder componentAt: #startTrackingLog) disable.	(self builder componentAt: #startTrackingDB) disable.	(self builder componentAt: #stopTracking) enable</body><body package="PickCell">startTracking1	| bufferPointer numChar ws buffer portOk trackPoint name filename wf pm gpsValue sqlCmd |	self		getData: 			[USBSerial unloadLibraries.			usb := USBSerial new.			usb initialize.			"Create a new file for logging data if it does not exist"			"name := 'trackGPSPoints.txt'.			filename := name asFilename.			wf := filename writeStream.			wf close."			pm := UIPickCellNodes new.			usb RS232_CloseComport: 27.			Transcript				show: Time now printString;				cr.			buffer := String new: 4096.			bufferPointer := buffer gcCopyToHeap.			portOk := usb						setReadBuf: bufferPointer						with: 4095						with: 27						with: 115200.			usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 115200.			portOk = 0				ifFalse: 					[Transcript						show: 'open error';						cr]				ifTrue: 					[[true] whileTrue: 							[numChar := usb										readBuf: bufferPointer										with: 4095										with: 27										with: 115200.							ws := String new writeStream.							0 to: numChar - 1								do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].							Transcript								show: numChar printString;								tab;								show: ws contents.							trackPoint := TrackPoint from: ws contents.							trackPoint isNil								ifFalse: 									[APoint := trackPoint.									name := 'trackGPSPoints.txt'.									filename := name asFilename.									wf := filename readAppendStream.									wf isWritable										ifTrue: 											[wf nextPutAll: ws contents.											wf close].									gpsValue := ws contents.									"sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES( ''ID3, 01:02:03, 48.1234N, 004.5987W, 70.1, -91'')'."									gpsValue last = Character lf										ifTrue: [gpsValue := gpsValue copyFrom: 1 to: gpsValue size - 1].									gpsValue last = Character cr										ifTrue: [gpsValue := gpsValue copyFrom: 1 to: gpsValue size - 1].									sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES(''' , gpsValue , ''')'.									pm										appendData: 'osm'										password: 'fare&amp;bali'										environment: '172.12.18.159:5432_vietnamTuyen'										strSql: sqlCmd									"environment: 'wsn.univ-brest.fr:8080_vietnamTuyen'"].							(Delay forSeconds: 1) wait].					usb RS232_CloseComport: 27]]					fork.	(self builder componentAt: #startTracking2) disable.	(self builder componentAt: #stopTracking) enable</body><body package="PickCell">startTracking2	| bufferPointer numChar ws buffer portOk trackPoint name filename wf pm gpsValue sqlCmd aName |	self		getData: 			[USBSerial unloadLibraries.			usb := USBSerial new.			usb initialize.			pm := UIPickCellNodes new.			aName := Dialog						requestFileName: 'Give file name of log file??'						default: 'trackGPSPoints.txt'						for: nil.			aName isEmpty				ifFalse: 					[filename := aName asFilename.					filename exists						ifTrue: [wf := filename readAppendStream]						ifFalse: [wf := filename writeStream]].			wf close.			pm := UIPickCellNodes new.			usb RS232_CloseComport: 27.			Transcript				show: Time now printString;				cr.			buffer := String new: 4096.			bufferPointer := buffer gcCopyToHeap.			portOk := usb						setReadBuf: bufferPointer						with: 4095						with: 27						with: 115200.			usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 115200.			portOk = 0				ifFalse: 					[Transcript						show: 'open error';						cr]				ifTrue: 					[[true] whileTrue: 							[numChar := usb										readBuf: bufferPointer										with: 4095										with: 27										with: 115200.							ws := String new writeStream.							0 to: numChar - 1								do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].							Transcript								show: numChar printString;								tab;								show: ws contents.							trackPoint := TrackPoint from: ws contents.							trackPoint isNil								ifFalse: 									[APoint := trackPoint.									name := 'trackGPSPoints.txt'.									filename := name asFilename.									wf := filename readAppendStream.									wf isWritable										ifTrue: 											[wf nextPutAll: ws contents.											wf close].									gpsValue := ws contents.									[gpsValue atEnd] = Character lf										ifTrue: [gpsValue copyFrom: 1 to: gpsValue size - 1].									[gpsValue atEnd] = Character cr										ifTrue: [gpsValue := gpsValue copyFrom: 1 to: gpsValue size - 1].									"sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES( ''ID3, 01:02:03, 48.1234N, 004.5987W, 70.1, -91'')'."									sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES(''' , gpsValue , ''')'.									pm										appendData: 'osm'										password: 'fare&amp;bali'										environment: '172.12.18.159:5432_vietnamTuyen'										strSql: sqlCmd									"environment: 'wsn.univ-brest.fr:8080_vietnamTuyen'"].							(Delay forSeconds: 1) wait].					usb RS232_CloseComport: 27]]					fork.	(self builder componentAt: #startTracking2) disable.	(self builder componentAt: #stopTracking) enable</body><body package="PickCell">startTracking3	| bufferPointer numChar ws buffer portOk trackPoint aName filename wf pm gpsValue sqlCmd |	self		getData: 			[USBSerial unloadLibraries.			usb := USBSerial new.			usb initialize.			self halt.			aName := Dialog requestFileName: 'Give name of log file?'						default: 'trackingData.txt'  for: nil.			aName isEmpty ifTrue: [aName := 'trackingData.txt'].			filename := aName asFilename.			filename exists				ifTrue: [wf := filename asFilename readAppendStream]				ifFalse: [wf := filename asFilename writeStream].			wf flush; close.			pm := UIPickCellNodes new.			usb RS232_CloseComport: 27.			Transcript				show: Time now printString;				cr.			buffer := String new: 4096.			bufferPointer := buffer gcCopyToHeap.			portOk := usb						setReadBuf: bufferPointer						with: 4095						with: 27						with: 115200.			usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 115200.			portOk = 0				ifFalse: 					[Transcript						show: 'open error';						cr]				ifTrue: 					[[true] whileTrue: 							[numChar := usb										readBuf: bufferPointer										with: 4095										with: 27										with: 115200.							ws := String new writeStream.							0 to: numChar - 1								do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].							Transcript								show: numChar printString;								tab;								show: ws contents.							trackPoint := TrackPoint from: ws contents.							trackPoint isNil								ifFalse: 									[APoint := trackPoint.									wf := filename asFilename readAppendStream.									wf isWritable										ifTrue: 											[wf nextPutAll: ws contents.											wf close].									gpsValue := ws contents.									gpsValue last = Character lf										ifTrue: [gpsValue := gpsValue copyFrom: 1 to: gpsValue size - 1].									gpsValue last = Character cr										ifTrue: [gpsValue := gpsValue copyFrom: 1 to: gpsValue size - 1].									self halt.									"sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES( ''ID3, 01:02:03, 48.1234N, 004.5987W, 70.1, -91'')'."									sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES(''' , gpsValue , ''')'.									pm										appendData: 'osm'										password: 'fare&amp;bali'										environment: '172.12.18.159:5432_vietnamTuyen'										strSql: sqlCmd									"environment: 'wsn.univ-brest.fr:8080_vietnamTuyen'"].							(Delay forSeconds: 1) wait].					usb RS232_CloseComport: 27]]					fork.	(self builder componentAt: #startTracking2) disable.	(self builder componentAt: #stopTracking) enable</body><body package="PickCell">startTrackingDB	| bufferPointer numChar ws buffer portOk trackPoint aName filename wf pm gpsValue sqlCmd |	self		getData: 			[USBSerial unloadLibraries.			usb := USBSerial new.			usb initialize.			aName := Dialog requestFileName: 'Give name of log file?'						default: 'trackingData.txt'  for: nil.			aName isEmpty ifTrue: [aName := 'trackingData.txt'].			filename := aName asFilename.			filename exists				ifTrue: [wf := filename asFilename readAppendStream]				ifFalse: [wf := filename asFilename writeStream].			wf flush; close.			pm := UIPickCellNodes new.			usb RS232_CloseComport: 27.			Transcript				show: Time now printString;				cr.			buffer := String new: 4096.			bufferPointer := buffer gcCopyToHeap.			portOk := usb						setReadBuf: bufferPointer						with: 4095						with: 27						with: 115200.			usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 115200.			portOk = 0				ifFalse: 					[Transcript						show: 'open error';						cr]				ifTrue: 					[[true] whileTrue: 							[numChar := usb										readBuf: bufferPointer										with: 4095										with: 27										with: 115200.							ws := String new writeStream.							0 to: numChar - 1								do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].							Transcript								show: numChar printString;								tab;								show: ws contents.							trackPoint := TrackPoint from: ws contents.							trackPoint isNil								ifFalse: 									[APoint := trackPoint.									wf := filename asFilename readAppendStream.									wf isWritable										ifTrue: 											[wf nextPutAll: ws contents.											wf close].									gpsValue := ws contents.									gpsValue last = Character lf										ifTrue: [gpsValue := gpsValue copyFrom: 1 to: gpsValue size - 1].									gpsValue last = Character cr										ifTrue: [gpsValue := gpsValue copyFrom: 1 to: gpsValue size - 1].									"sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES( ''ID3, 01:02:03, 48.1234N, 004.5987W, 70.1, -91'')'."									sqlCmd := 'INSERT INTO RECOCO9(gpsdata) VALUES(''' , gpsValue , ''')'.									pm										appendData: 'osm'										password: 'fare&amp;bali'										environment: '172.12.18.159:5432_vietnamTuyen'										strSql: sqlCmd									"environment: 'wsn.univ-brest.fr:8080_vietnamTuyen'"].							(Delay forSeconds: 1) wait].					usb RS232_CloseComport: 27]]					fork.	(self builder componentAt: #startTrackingLog) disable.	(self builder componentAt: #startTrackingDB) disable.	(self builder componentAt: #stopTracking) enable</body><body package="PickCell">startTrackingLog	| bufferPointer numChar ws buffer portOk trackPoint name filename wf |	self		getData: 			[USBSerial unloadLibraries.			usb := USBSerial new.			usb initialize.			"Create a new file for logging data if it does not exist"			"name := '/Users/monmac/Documents/trackGPSPoints.txt'.			filename := name asFilename.			wf := filename writeStream.			wf close."			usb RS232_CloseComport: 27.			Transcript				show: Time now printString;				cr.			buffer := String new: 4096.			bufferPointer := buffer gcCopyToHeap.			portOk := usb						setReadBuf: bufferPointer						with: 4095						with: 27						with: 115200.			usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 115200.			portOk = 0				ifFalse: 					[Transcript						show: 'open error';						cr]				ifTrue: 					[[true] whileTrue: 							[numChar := usb										readBuf: bufferPointer										with: 4095										with: 27										with: 115200.							ws := String new writeStream.							0 to: numChar - 1								do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].							Transcript								show: numChar printString;								tab;								show: ws contents.							trackPoint := TrackPoint from: ws contents.							trackPoint isNil								ifFalse: 									[APoint := trackPoint.									name := '/Users/monmac/Documents/trackGPSPoints.txt'.									filename := name asFilename.									wf := filename readAppendStream.									wf isWritable										ifTrue: 											[wf nextPutAll: ws contents.											wf close]].							(Delay forSeconds: 1) wait].					usb RS232_CloseComport: 27]]					fork.	(self builder componentAt: #startTrackingLog) disable.	(self builder componentAt: #startTrackingDB) disable.	(self builder componentAt: #stopTracking) enable</body><body package="PickCell">stopTracking	usb RS232_CloseComport: 27.	self getData terminate.	self getData: nil.	(self builder componentAt: #startTrackingLog) enable.	(self builder componentAt: #startTrackingDB) enable.	(self builder componentAt: #stopTracking) disable</body></methods><methods><class-id>GPSTrackingInterface</class-id> <category>accessing</category><body package="PickCell">getData	^getData</body><body package="PickCell">getData: anObject	getData := anObject</body></methods><methods><class-id>GPSTrackingInterface class</class-id> <category>testing</category><body package="PickCell">doUploadFields	| aName filename rs pm sqlCmd nodeid time lat lon rssi latString lonString alt |	pm := UIPickCellNodes new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							time := rs upTo: $,.							latString := rs upTo: $,.							lat := (self parseLat: latString) asNumber.							lonString := rs upTo: $,.							lon := (self parseLon: lonString) asNumber.							alt:= (rs upTo: $,) asNumber.							rssi := (rs upTo: Character lf) asNumber.							sqlCmd := 'INSERT INTO recoco4(nodeid, time, lat, lon, alt, rssi) VALUES('''										, nodeid , ''', '''										, time , ''',   lat										,lon , alt , rssi)'.							pm								appendData: 'osm'								password: 'fare&amp;bali'								environment: '172.12.18.159:5432_vietnamTuyen'								"environment: 'wsn.univ-brest.fr:8080_vietnamTuyen'"								strSql: sqlCmd]							].			rs close].	^nil</body><body package="PickCell">doUploadFields1	| aName filename rs pm sqlCmd nodeid time lat lon rssi alt gpsValue latString lonString |	pm := UIPickCellNodes new.	aName := Dialog				requestFileName: 'Give file name of log file??'				default: 'trackGPSPoints.txt'				for: nil.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[gpsValue := rs upTo: Character cr.					gpsValue isEmpty						ifFalse: 							[[rs atEnd] whileFalse: 									[nodeid := rs upTo: $,.									time := rs upTo: $,.									latString := rs upTo: $,.									lat:= self parseLat: latString.									lonString := rs upTo: $,.									lon:= self parseLon: lonString.									alt := rs upTo: $,.									rssi := rs upTo: Character cr.									sqlCmd := 'INSERT INTO recoco6(nodeid, time, lat, lon, alt, rssi) VALUES('''												, nodeid , ''', '''												, time , ''', '''												, lat , ''', '''												, lon , ''', ''', alt, ''', ''', rssi,''')'.									pm										appendData: 'osm'										password: 'fare&amp;bali'										environment: '172.12.18.159:5432_vietnamTuyen'										strSql: sqlCmd]]].			rs close].	^nil</body><body package="PickCell">parseLat: aString	| ls n ch entier decimal number numberString north |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	north := aString last = $N.	north ifFalse: [number := number negated].	numberString:= number printString.	number:= numberString copyFrom: 1 to: numberString size - 1.	^number</body><body package="PickCell">parseLon: aString	| ls n ch entier decimal number numberString west |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	west := aString last = $W.	west ifTrue: [number := number negated].	numberString:= number printString.	number:= numberString copyFrom: 1 to: numberString size - 1.	^number</body><body package="PickCell">testParseLatLon	| latString latValue |	latString := '4823.0159N'.	latValue := self  new parseLatLon: latString.	^latValue</body></methods><methods><class-id>Mapsv0Utilities</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Mapsv0Utilities class</class-id> <category>utilities</category><body package="Mapsv0">bashForGPX	^'#!/bin/bash# Smartsantander.sh# date=`date +%F_%H-%M-%S`date="web"dateTime=`date +%FT%H:%M:%S`echo $dateecho $dateTimegpxName=smartsantander_$date.gpxecho "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;gpx version=\"1.0\" creator=\"ed\"&gt;  &lt;metadata&gt;    &lt;name&gt;SmartSantander''s sensors&lt;/name&gt;    &lt;desc&gt;Sensors in city: Santander, Spain&lt;/desc&gt;    &lt;link&gt;http://smartsantander.eu/&lt;/link&gt;    &lt;time&gt;$dateTime&lt;/time&gt;  &lt;/metadata&gt;" &gt; $gpxNamecurl http://www.smartsantander.eu/map --output-document=map_$date.htmed map_$date.htm &lt; smartsantander.edcat smartsantander.gpx.part &gt;&gt; $gpxNameecho $gpxName'</body><body package="Mapsv0">defaultFileNetName	" GMapUtilities  defaultFileNetName "	^'smartsantander.net'</body><body package="Mapsv0">defaultGPXName	^'smartsantander.gpx'</body><body package="Mapsv0">defaultGpxPartName	^'smartsantander.gpx.part'</body><body package="Mapsv0">defaultHtmlName	^'smartsantander.html'</body><body package="Mapsv0">htmlForSantander	"self htmlForSantander "	| fn url req resp contents |	url := 'http://www.smartsantander.eu/map/'.	req := Net.HttpRequest get: url.	resp := req execute.	contents := resp value byteSource.	contents isNil		ifFalse: 			[| text |			text := contents						reset;						contents.			fn := self defaultHtmlName asFilename writeStream.			fn nextPutAll: text.			fn close].	^contents</body><body package="Mapsv0">scriptForGPX	^'H/Latlng=/1,.-1d/&lt;\/script&gt;/.,$d1,$s/.*LatLng(\(.*\), \(.*\));/\&lt;wpt lat=\"\1\" lon=\"\2\"\&gt;/gg/Marker/dg/map:map,/dg/position:/dg/addListener/dg/});/d1,$s/.*icon:/\&lt;sym\&gt;/g1,$s/\(image.*\),/\1\&lt;\/sym\&gt;/g1,$s/&lt;div.*Last update:/\&lt;time\&gt;/g1,$s/&lt;\/br&gt;&lt;br&gt;\(Node: [0-9]*\)/&lt;\/time&gt;&lt;name&gt;\1&lt;\/name&gt;/g1,$s/&lt;\/br&gt;\(.*\)&lt;\/br&gt;/&lt;desc&gt;\1&lt;\/desc&gt;/g1,$s/&lt;\/font&gt;&lt;\/div&gt;\";/&lt;\/wpt&gt;/g1,$s/&lt;br&gt;//g1,$s/&lt;\/br&gt;/; /g1,$s/var\(.*\)=\"/&lt;cmt&gt;\1&lt;\/cmt&gt;/g1,$s/	//g1,$g/^$/d1,$s/&lt;sym&gt;/  &lt;sym&gt;/g1,$g/^ $/d1,$g/^image/.-1,.j1,$s/&lt;div.*&gt;\(.*\);/&lt;name&gt;\1&lt;\/name&gt;/g1,$s/&gt; /&gt;/g1,$s/?/Â°/g$,$s/}/&lt;\/gpx&gt;/1,$s/image10/meshlium_2/g1,$s/image1/air/g1,$s/image3/parking/g1,$s/image6/parking_off/g1,$s/image7/temperature/g1,$s/image8/sound/g1,$s/image9/light/gw smartsantander.gpx.partq'</body><body package="Mapsv0">testForGPX	"GMapUtilities testForGPX"	| command fn return date |	fn := 'smartsantander.ed' asFilename writeStream.	fn nextPutAll: self scriptForGPX.	fn close.	"date := UnixProcess cshOne: 'date'."	date := UnixProcess cshOne: 'date +%FT%H:%M:%S'.	date := date copyFrom: 1 to: date size - 1.	fn := self defaultGPXName asFilename writeStream.	fn		nextPutAll: '&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;gpx version="1.0" creator="NetGen for Santander"&gt;  &lt;metadata&gt;    &lt;name&gt;SmartSantander''s sensors&lt;/name&gt;    &lt;desc&gt;Sensors in city: Santander, Spain&lt;/desc&gt;    &lt;link&gt;http://smartsantander.eu/&lt;/link&gt;    &lt;time&gt;'					, date , '&lt;/time&gt;  &lt;/metadata&gt;';		cr.	fn close.	command := 'ed ' , self defaultHtmlName , ' &lt; smartsantander.ed'.	return := UnixProcess cshOne: command.	UnixProcess cshOne: 'cat ' , self defaultGpxPartName , '&gt;&gt; ' , self defaultGPXName.	^return</body><body package="Mapsv0">textForSantander	" self textForSantander "	| fn return |	return := UnixProcess cshOne: 'curl -s  http://www.smartsantander.eu/map/'.	fn := self defaultHtmlName asFilename writeStream.	fn nextPutAll: return.	fn close.	^return</body></methods><methods><class-id>Mapsv0Utilities class</class-id> <category>instance creation</category><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyQuest1</class-id> <category>private</category><body package="QuickMap">getUri1: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://otile2.mqcdn.com/tiles/1.0.0/map/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri2: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://otile1.mqcdn.com/tiles/1.0.0/map/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| url |	url := ('http://otile1.mqcdn.com/tiles/1.0.0/map/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png').	Transcript show: url; cr.	^ url	asURI</body></methods><methods><class-id>QuickTileProxyQuest1</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyQuest1</class-id> <category>networking</category><body package="QuickMap">getPng: anIndex x: x y: y zoom: zoom	| httpResponse imageStream url qhr idxc cli sem baseDirName fn fnis fnos reader image ws |	baseDirName := self pickCellDir.	fn := baseDirName , self class name , '-' , x printString , '-'				, y printString.	fnis := fn , '.jpeg'.	fnos := fn , '.png'.	fnos asFilename exists		ifTrue: 			[reader := ImageReader fromFile: fnos.			reader readImage.			image := reader image.			^image]		ifFalse: 			[idxc := self semIndexClient.			cli := self clientAt: idxc.			sem := self semaphoreAt: idxc.			url := self						getUri: anIndex						x: x						y: y						zoom: zoom.			qhr := QuickHttpRequest get: url.			qhr fieldValueAt: 'User-Agent'				put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.			qhr mapClients: cli.			sem critical: [httpResponse := qhr execute].			imageStream := httpResponse value byteSource.			ws := (fnis asFilename withEncoding: #binary) writeStream.			imageStream reset.			ws setBinary: true.			ws nextPutAll: imageStream contents.			ws				flush;				close.			"UnixProcess cshOne: 'jpegtopnm ' , fnis , '| pnmtopng ' , '&gt; ' , fnos."			UnixProcess cshOne: 'convert ' , fnis , '  ' , fnos.			reader := ImageReader fromFile: fnos.			reader readImage.			image := reader image.			^image].	^imageStream</body></methods><methods><class-id>QuickTileProxyQuest1 class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	^'Quest Map'</body><body package="QuickMap">maxSocket	^6</body><body package="QuickMap">maxZoom	^19</body></methods><methods><class-id>QuickTileTracker</class-id> <category>private</category><body package="QuickMap">cursorPointFor: aMouseEvent	^aMouseEvent globalPoint</body><body package="QuickMap">finishSelectionFor: aPoint	| d ppms my |	Cursor hand show.	"p := anEvent globalPoint."	"diff := previous - p."	"diff inspect."	d := Time microsecondClock - previousClock.	"currentClock"	ppms := "delta"(previousPoint - aPoint) / d * 10000.	"Nombre de pixels Ã  dÃ©placer Ã  chaque itÃ©ration"	"ppms copy inspect."	ppms abs &lt; (2 @ 2) ifTrue: [^self].	ppms x &gt; 0		ifTrue: [ppms x: (ppms x min: 1.0e2)]		ifFalse: [ppms x: (ppms x max: -1.0e2)].	ppms y &gt; 0		ifTrue: [ppms y: (ppms y min: 1.0e2)]		ifFalse: [ppms y: (ppms y max: -1.0e2)].	my := controller.	controller		forkAnim: (			["Deux paramÃ¨tres rÃ¨glent l'animation de la carte."			" *** ATTENTION, DANGER : si i &lt; 1, la carte accÃ©lÃ¨re ! *** "			| i |			i := 1.05.	"Coefficient de frottement initial : Ã  ajuster suivant la courbe choisie"			[ppms abs &lt; (1 @ 1)	"ppms rounded = Point zero"] whileFalse: 					[(Delay forMilliseconds: 10) wait.					my view container scrollBy: ppms rounded.					"Plusieurs courbes de frottement : "					"Sans : suit le mouvement, ralentissement trÃ¨s doux"					"i := i + 1.000002."	"ArrÃªt brutal"					"i := i + i."	"ArrÃªt trÃ¨s brutal"					i := i * 1.002.	"Ralentissement doux, conseillÃ©"					"i := i * i."	"Suit le mouvement, puis arrÃªt brutal"					ppms := ppms / i]] 					forkAt: Processor activePriority - 1).	super finishSelectionFor: aPoint</body><body package="QuickMap">setUpFor: aMouseButtonEvent	super setUpFor: aMouseButtonEvent.	UIQuickMap closedHand show. 	lastPoint := self cursorPointFor: aMouseButtonEvent.	previousPoint := aMouseButtonEvent globalPoint.	currentPoint := previousPoint.	controller forkAnim isNil ifFalse: [controller forkAnim terminate].	currentClock := Time microsecondClock.	previousClock := currentClock</body><body package="QuickMap">trackSelectionFor: aPoint	controller view container scrollBy: lastPoint - aPoint.	lastPoint := aPoint.	previousPoint := currentPoint.	currentPoint := aPoint.	previousClock := currentClock.	currentClock := Time microsecondClock	"aPoint inspect."</body></methods><methods><class-id>QuickTileTracker</class-id> <category>events</category><body package="QuickMap">mouseMovedEvent0: aMouseMovedEvent 	"self halt."	[super mouseMovedEvent: aMouseMovedEvent. ^nil] value.	controller view isOpen 		ifTrue: [| p "c" |		aMouseMovedEvent inspect.			p := aMouseMovedEvent globalPoint.			delta := previousPoint - p.			controller view container scrollBy: delta.			"c := self view container.			(c instVarNamed: 'origin') value: (c translation - diff)."			previousPoint := p.			previousClock := currentClock.			currentClock := Time microsecondClock].	^nil</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>accessing</category><body package="QuickMap">masterWindow	^masterWindow</body><body package="QuickMap">masterWindow: anObject	masterWindow := anObject</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>aspects</category><body package="QuickMap">basemap	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^basemap isNil		ifTrue:			[basemap := String new asValue]		ifFalse:			[basemap]</body><body package="QuickMap">basemapChoices	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^basemapChoices isNil		ifTrue:			[basemapChoices := ((List new) addAll: QuickTileProxy subclasses; sorted) asValue]		ifFalse:			[basemapChoices]</body><body package="QuickMap">friendlyName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^friendlyName isNil		ifTrue:			[friendlyName := String new asValue]		ifFalse:			[friendlyName]</body><body package="QuickMap">getUriMethod	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getUriMethod isNil		ifTrue:			[getUriMethod := String new asValue]		ifFalse:			[getUriMethod]</body><body package="QuickMap">isAnimated	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^isAnimated isNil		ifTrue:			[isAnimated := true asValue]		ifFalse:			[isAnimated]</body><body package="QuickMap">isPrefetching	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^isPrefetching isNil		ifTrue:			[isPrefetching := true asValue]		ifFalse:			[isPrefetching]</body><body package="QuickMap">libraryDirectories	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^libraryDirectories isNil		ifTrue:			[libraryDirectories := SelectionInList new]		ifFalse:			[libraryDirectories]</body><body package="QuickMap">libraryFile	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^libraryFile isNil		ifTrue:			[libraryFile := String new asValue]		ifFalse:			[libraryFile]</body><body package="QuickMap">libraryFiles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^libraryFiles isNil		ifTrue:			[libraryFiles := SelectionInList new]		ifFalse:			[libraryFiles]</body><body package="QuickMap">libraryPath	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^libraryPath isNil		ifTrue:			[libraryPath := String new asValue]		ifFalse:			[libraryPath]</body><body package="QuickMap">maxSocket	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^maxSocket isNil		ifTrue:			[maxSocket := 0 asValue]		ifFalse:			[maxSocket]</body><body package="QuickMap">maxZoom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^maxZoom isNil		ifTrue:			[maxZoom := 0 asValue]		ifFalse:			[maxZoom]</body><body package="QuickMap">proxyHostname	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^proxyHostname isNil		ifTrue:			[proxyHostname := String new asValue]		ifFalse:			[proxyHostname]</body><body package="QuickMap">proxyPort	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^proxyPort isNil		ifTrue:			[proxyPort := 0 asValue]		ifFalse:			[proxyPort]</body><body package="QuickMap">tabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tabs isNil		ifTrue: 			[(tabs := SelectionInList with: self labelArray) selectionIndex: 1.			tabs selectionIndexHolder onChangeSend: #tabsChanged to: self.			tabs]		ifFalse: [tabs]</body><body package="QuickMap">useProxy	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^useProxy isNil		ifTrue:			[useProxy := false asValue]		ifFalse:			[useProxy]</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>private</category><body package="QuickMap">labelArray	"Private - The list of tab names (and/or icons). See also #specArray."	^Array		with: (OpaqueImage figure: self class net16x16				shape: self class net16x16mask) -&gt; 'Network'		with: self class colorsImage -&gt; 'Tile cache'		with: 'Base map'		with: 'Library settings'		"with: 'Display'"		"with: self class printerImage -&gt; ''"</body><body package="QuickMap">specArray	"Private - The list of associated sub canvaes. See also #labelArray."	^#(#networkSpec #tileCacheSpec #basemapSpec #librarySpec #displaySpec)</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>changing</category><body package="QuickMap">changeBasemap	| bm |	bm := self basemap value.	self friendlyName value: bm friendlyName.	self maxZoom value: bm maxZoom.	self maxSocket value: bm maxSocket.	self getUriMethod		value: (bm compiledMethodAt: #getUri:x:y:zoom:) getSource</body><body package="QuickMap">changeHostname	NetworkProxyBackup at: #hostname put: proxyHostname value</body><body package="QuickMap">changePort	NetworkProxyBackup at: #port put: proxyPort value</body><body package="QuickMap">tabsChanged	"Every time, a tab is changed, a new sub canvas gets installed."	| index |	index := self tabs selectionIndex.	(self builder componentAt: #tabbing) widget client: self spec: (self specArray at: index)</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>actions</category><body package="QuickMap">doApply	| proxyHostnamePort hs mw |	Net.HttpSettings useProxy: useProxy value.	proxyHostnamePort := proxyHostname value , ':'				, proxyPort value printString.	hs := Net.HostSpec http: proxyHostnamePort user: nil.	useProxy value		ifTrue: [Net.HttpSettings proxyHost: hs]		ifFalse: 			[Net.HttpSettings proxyHost: Net.HostSpec new.			Net.HttpSettings instVarNamed: 'proxyHost' put: nil].	mw := self masterWindow.	mw isNil ifFalse: [ mw  resetAll "disconnectAll"]</body><body package="QuickMap">doClose	self closeRequest</body><body package="QuickMap">doEmptyCache	self masterWindow quickTileMap component dicoProxy do: [:p | p emptyCache]</body><body package="QuickMap">doOpenLibraryFile	"This stub method was generated by UIDefiner"	| default file |	default := self libraryPath value.	default isEmpty		ifTrue: [default := nil]		ifFalse: [default := default , '/*.*'].	file := Dialog				requestFileName: 'Select library file...'				default: default				version: #mustBeOld.	file isEmpty ifFalse: [self libraryFile value: file asFilename tail]</body><body package="QuickMap">doOpenLibraryPath	"This stub method was generated by UIDefiner"	| path default |	default := self libraryPath value.	default isEmpty		ifTrue: [default := Filename defaultDirectoryName , '/*']		"ifFalse: [default := default , '/.']".	path := Dialog				requestDirectoryName: 'Select library directory...'				default: default				version: #mustBeOld.	path isEmpty ifFalse: [self libraryPath value: path]</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>interface opening</category><body package="QuickMap">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self tabsChanged</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>interface closing</category><body package="QuickMap">requestForWindowClose	self builder window "collapse" unmap.	^false</body></methods><methods><class-id>UIQuickMapConfig</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	NetworkProxyBackup isNil		ifTrue: 			[NetworkProxyBackup := Dictionary						withKeysAndValues: #(#hostname '' #port 0)].	hostSpec := Net.HttpSettings proxyHost.	hostSpec isNil		ifFalse: 			[self proxyHostname value: hostSpec name.			self proxyPort value: hostSpec port]		ifTrue: 			[self proxyHostname value: (NetworkProxyBackup at: #hostname).			self proxyPort value: (NetworkProxyBackup at: #port)].	self useProxy value: Net.HttpSettings useProxy.	self proxyHostname onChangeSend: #changeHostname to: self.	self proxyPort onChangeSend: #changePort to: self.	"Base map"	self basemap onChangeSend: #changeBasemap to: self.	"Library"	self libraryPath value: ShapefileReader libraryDirectories first.	self libraryFile value: ShapefileReader libraryFiles first name.	self libraryDirectories list: ShapefileReader libraryDirectories asList.	self libraryFiles list: ShapefileReader libraryFiles asList.	^self</body></methods><methods><class-id>UIQuickMapConfig class</class-id> <category>debugging</category><body package="QuickMap">unStuck	"When you open directly a tab interface spec, your window can not be closed! "	"You may execute the code below to release and unschedule windows! "	WindowManager allInstances do: 			[:inst |			inst scheduledWindows do: 					[:win |					win isNil						ifFalse: [win model class = self ifTrue: [inst unscheduleWindow: win]]]].	^self commentOnly</body></methods><methods><class-id>QuickTileProxyVietnam</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyVietnam</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string := super baseWsn, '/osm_vietnam/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>Mapsv0TileCache</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	dicoZoom := Dictionary new.	^self</body></methods><methods><class-id>Mapsv0TileCache</class-id> <category>accessing</category><body package="Mapsv0">dicoZoom	^dicoZoom</body><body package="Mapsv0">dicoZoom: anObject	dicoZoom := anObject</body></methods><methods><class-id>Mapsv0TileCache</class-id> <category>retrieving</category><body package="Mapsv0">x: x y: y zoom: zoom	| dicoPos gt modulo xm ym |	modulo := 2 raisedTo: zoom.	xm := x \\ modulo.	ym := y \\ modulo.	dicoPos := self dicoZoom at: zoom ifAbsent: [self dicoZoom at: zoom put: Dictionary new].	dicoPos isNil ifFalse: [gt := dicoPos at: xm @ ym ifAbsent: [dicoPos at: xm @ ym put: (Mapsv0Tile x: xm y: ym zoom: zoom)]].	^gt</body></methods><methods><class-id>Mapsv0TileCache class</class-id> <category>instance creation</category><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>AlgoDis.BGPickCell</class-id> <category>initialize</category><body package="PickCell">initialize	"Create a list of uneSeries, and convert it into a ValueHolder."	super initialize.	uneSerie := List new.	self initializeData.	uneSerie := uneSerie asValue</body></methods><methods><class-id>AlgoDis.BGPickCell</class-id> <category>accessing</category><body package="PickCell">uneSerie	^uneSerie</body><body package="PickCell">uneSerie: anObject	uneSerie := anObject</body></methods><methods><class-id>AlgoDis.BGPickCell</class-id> <category>initializeData</category><body package="PickCell">initializeData	"Initalize the uneSeries collection."	| cellData |	cellData := BGPickCellData new.	cellData		xyzRef: #(1 1 1);		code: 50;		nbElements: 40.	self uneSerie add: cellData.	cellData := BGPickCellData new.	cellData		xyzRef: #(1 2 1);		code: 25;		nbElements: 32.	self uneSerie add: cellData.	cellData := BGPickCellData new.	cellData		xyzRef: #(1 1 2);		code: 36;		nbElements: 33.	self uneSerie add: cellData</body></methods><methods><class-id>SystemOrganization</class-id> <category>accessing</category><body package="PickCell">cellSize	^cellSize</body><body package="PickCell">cellSize: anObject	cellSize := anObject</body><body package="PickCell">elevation	^elevation</body><body package="PickCell">elevation: anObject	elevation := anObject</body><body package="PickCell">height	^height</body><body package="PickCell">height: anObject	height := anObject</body><body package="PickCell">latitude	^latitude</body><body package="PickCell">latitude: anObject	latitude := anObject</body><body package="PickCell">longitude	^longitude</body><body package="PickCell">longitude: anObject	longitude := anObject</body><body package="PickCell">mapOrigin	^mapOrigin</body><body package="PickCell">mapOrigin: anObject	mapOrigin := anObject</body><body package="PickCell">width	^width</body><body package="PickCell">width: anObject	width := anObject</body><body package="PickCell">zoom	^zoom</body><body package="PickCell">zoom: anObject	zoom := anObject</body></methods><methods><class-id>SystemOrganization</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	width := nil.	height := nil.	longitude := nil.	latitude := nil.	elevation := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>MapTile</class-id> <category>accessing</category><body package="MapAccess">getTile	| httpResponse imageStream readerClass reader |	httpResponse := MapServerConnection x: x y: y zoom: zoom.	imageStream := httpResponse value byteSource.		[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream] ensure: [imageStream ifNotNil: [:stream | stream close]].	image := reader image.	tile := image asRetainedMedium.	^tile</body><body package="MapAccess">tile	^tile isNil ifFalse: [tile] ifTrue: [self getTile]</body><body package="MapAccess">x	^x</body><body package="MapAccess">x: anObject	x := anObject</body><body package="MapAccess">y	^y</body><body package="MapAccess">y: anObject	y := anObject</body><body package="MapAccess">zoom	^zoom</body><body package="MapAccess">zoom: anObject	zoom := anObject</body></methods><methods><class-id>MapTile</class-id> <category>displaying</category><body package="MapAccess">displayOn: aGraphicsContext	self tile displayOn: aGraphicsContext</body><body package="MapAccess">displayOn: aGraphicsContext at: position	self tile displayOn: aGraphicsContext at: position</body></methods><methods><class-id>MapTile</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MapTile class</class-id> <category>instance creation</category><body package="MapAccess">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="MapAccess">x: x y: y zoom: zoom	^(self new)		x: x;		y: y;		zoom: zoom;		yourself</body></methods><methods><class-id>QuickTileComposite</class-id> <category>accessing</category><body package="QuickMap">mapZoom	^mapZoom</body><body package="QuickMap">mapZoom: anObject	mapZoom := anObject</body><body package="QuickMap">model	^model</body><body package="QuickMap">model: anObject	model := anObject</body><body package="QuickMap">overlay	^overlay</body><body package="QuickMap">overlay: anObject	overlay := anObject</body><body package="QuickMap">proxy	^proxy</body><body package="QuickMap">proxy: anObject	proxy := anObject</body></methods><methods><class-id>QuickTileComposite</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	"proxy := QuickTileProxy new.	proxy container: self."	overlay := QuickTileProxyOverlay new container: self.	^self</body></methods><methods><class-id>QuickTileComposite</class-id> <category>bounds accessing</category><body package="QuickMap">preferredBounds	" *** This method was defined by VisualComponent as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| z tileSize maxTile maxPixel |	tileSize := 256.	z := self mapZoom.	maxTile := 2 raisedTo: z.	maxPixel := maxTile * tileSize.	^0 @ 0 corner: maxPixel @ maxPixel</body></methods><methods><class-id>QuickTileComposite</class-id> <category>displaying</category><body package="QuickMap">displayOn: aGraphicsContext	| clipBox tileSize origin corner tileOrigin tileCorner yp1 yp2 xp1 xp2 |	clipBox := aGraphicsContext clippingBounds.	tileSize := 256.	origin := clipBox origin.	corner := clipBox corner.	tileOrigin := origin // tileSize.	tileCorner := corner // tileSize.	tileOrigin x to: tileCorner x		do: 			[:tx |			tileOrigin y to: tileCorner y				do: 					[:ty |					"tileCurrent"					"tileCurrent := x @ y."					"pt := PseudoTile id: tileCurrent."					| pt |					pt := proxy x: tx y: ty zoom: mapZoom.					pt displayOn: aGraphicsContext copy.					pt := overlay x: tx y: ty zoom: mapZoom.					pt displayOn: aGraphicsContext copy.]].	"Prefetching : "	yp1 := tileOrigin y - 1.	yp2 := tileCorner y + 1.	tileOrigin x to: tileCorner x		do: 			[:tx |			| pt |			pt := proxy x: tx y: yp1 zoom: mapZoom.			pt prefetch.			pt := proxy x: tx y: yp2 zoom: mapZoom.			pt prefetch].	xp1 := tileOrigin x - 1.	xp2 := tileCorner x + 1.	tileOrigin y - 1 to: tileCorner y + 1		do: 			[:ty |			| pt |			pt := proxy x: xp1 y: ty zoom: mapZoom.			pt prefetch.			pt := proxy x: xp2 y: ty zoom: mapZoom.			pt prefetch]</body></methods><methods><class-id>Mapsv0</class-id> <category>accessing</category><body package="Mapsv0">colNodes	^colNodes</body><body package="Mapsv0">colNodes: anObject	colNodes := anObject</body><body package="Mapsv0">colPickedNodesVH	colPickedNodesVH isNil ifTrue: [colPickedNodesVH := OrderedCollection new asValue].	^colPickedNodesVH</body><body package="Mapsv0">colPickedNodesVH: anObject	colPickedNodesVH := anObject</body><body package="Mapsv0">dicoNodeDistance	^dicoNodeDistance</body><body package="Mapsv0">dicoNodeDistance: anObject	dicoNodeDistance := anObject</body><body package="Mapsv0">dicoReachedNodes	^dicoReachedNodes</body><body package="Mapsv0">dicoReachedNodes: anObject	dicoReachedNodes := anObject</body><body package="Mapsv0">distanceSet	^distanceSet</body><body package="Mapsv0">distanceSet: anObject	distanceSet := anObject</body><body package="Mapsv0">matrixTile	^matrixTile</body><body package="Mapsv0">matrixTile: anObject	matrixTile := anObject</body><body package="Mapsv0">networkGraph	^networkGraph</body><body package="Mapsv0">networkGraph: anObject	networkGraph := anObject</body><body package="Mapsv0">nodesGPS	^nodesGPS</body><body package="Mapsv0">nodesGPS: anObject	nodesGPS := anObject</body><body package="Mapsv0">nodesPx	^nodesPx</body><body package="Mapsv0">nodesPx: anObject	nodesPx := anObject</body><body package="Mapsv0">pickModelTmp	^pickModelTmp</body><body package="Mapsv0">pickModelTmp: anObject	pickModelTmp := anObject</body><body package="Mapsv0">pixelPerKm	^pixelPerKm</body><body package="Mapsv0">pixelPerKm: anObject	pixelPerKm := anObject</body><body package="Mapsv0">pixelPerKmAt: aZoom	^self pixelPerKm at: aZoom ifAbsent: [100]</body><body package="Mapsv0">pixelRange	^(self pixelPerKmAt: (self matrixTile at: #zoom)) * range / 1000</body><body package="Mapsv0">range	^range</body><body package="Mapsv0">range: anObject	range := anObject</body><body package="Mapsv0">xmlMetadata	^xmlMetadata</body><body package="Mapsv0">xmlMetadata: anObject	xmlMetadata := anObject</body></methods><methods><class-id>Mapsv0</class-id> <category>fileIn/Out</category><body package="Mapsv0">asGpxDocument	| nodesKml xmlDoc xmlRoot |	nodesKml := self colNodes collect: [:node | node asXmlElement].	nodesKml addFirst: self xmlMetadata.	"xmlDocType := XML.DocumentType new."	xmlDoc := XML.Document new.	xmlRoot := XML.Element				tag: 'gpx'				attributes: (Array with: (XML.Attribute name: 'creator' value: 'Smalltalk Map') with: (XML.Attribute name: 'version' value: '1.0'))				elements: nodesKml asArray.	xmlDoc addNode: xmlRoot.	^xmlDoc</body><body package="Mapsv0">fileOutAsGpxFile: aFilenameOrStringself colNodes do: [:node | ]</body></methods><methods><class-id>Mapsv0</class-id> <category>computing</category><body package="Mapsv0">computeDistance	| size s |	size := colNodes size.	s := OrderedCollection new: size * (size - 1) / 2.	size isNil ifTrue: [^self].	colNodes keysAndValuesDo: 			[:key :value |			key + 1 to: size				do: 					[:i |					| nd |					nd := NetworkDistance distanceNode: value withNode: (colNodes at: i).					s add: nd]].	distanceSet := s</body><body package="Mapsv0">originOffset	^(matrixTile at: #x) @ (matrixTile at: #y) scaledBy: 256@256</body><body package="Mapsv0">selectReachedNodes	dicoReachedNodes := Dictionary new: colNodes size.	dicoNodeDistance keysAndValuesDo: 			[:node :sortedDist |			| r |			r := sortedDist select: [:n | n &lt;= node range].			dicoReachedNodes at: node put: r]</body><body package="Mapsv0">sortDistanceByNode	dicoNodeDistance := Dictionary new: colNodes size.	"colNodes do: 			[:node |			| dist |			dist := distanceSet select: [:n | n includes: node].			dist := dist asSortedCollection.			dicoNodeDistance at: node put: dist]"	distanceSet do: 			[:dist |			(dicoNodeDistance at: dist nodeA ifAbsentPut: [SortedCollection new: colNodes size]) add: dist.			(dicoNodeDistance at: dist nodeB ifAbsentPut: [SortedCollection new: colNodes size]) add: dist]</body><body package="Mapsv0">titleSize	^256</body><body package="Mapsv0">updateGeneratorsWith: net	| uiGenerators connectivity fName ws cocoResteLa aGenerator |	uiGenerators := AlgoDis.UINetworkGeometry allInstances.	uiGenerators isEmpty		ifTrue: 			[cocoResteLa := AlgoDis.UINetworkGeometry new.			uiGenerators := Array with: cocoResteLa].	aGenerator := uiGenerators first.	connectivity := net buildNetworkLocalized.	aGenerator doOccam value: true.	aGenerator doBuildDotFile value: true.	aGenerator forCuda value: true.	aGenerator theNbSystems value: net points size.	aGenerator theRadius value: self pickModelTmp portee value.	aGenerator theSize value: self pickModelTmp bounds width.	aGenerator doGraphic value: false.	aGenerator leCode value: connectivity printString.	fName := Mapsv0Utilities defaultFileNetName asFilename.	fName exists ifTrue: [fName isWritable ifFalse: [^Dialog warn: 'cannot write ' , fName]].	ws := fName asFilename writeStream.	ws nextPutAll: aGenerator leCode value.	ws close.	aGenerator doGenerate: false</body></methods><methods><class-id>Mapsv0</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	matrixTile := Dictionary withKeysAndValues: #(#x 0 #y 0 #zoom 0).	self nodesPx: OrderedCollection new.	self nodesGPS: OrderedCollection new.	"self pickModelTmp: AlgoDis.PickModel new."	self pickModelTmp: AlgoDis.PickMobileModel new.	self pixelPerKm: (Dictionary				withKeysAndValues: #(0 0.0078125 1 0.015625 2 0.03125 3 0.0625 4 0.125 5 0.25 6 0.5 7 1 8 2 9 5 10 9 11 18 12 36 13 72 14 144 15 288 16 575 17 1150 18 2300 19 4600 20 9200 21 18400)).	distanceSet := OrderedCollection new.	dicoNodeDistance := Dictionary new.	colNodes := OrderedCollection new.	^self</body></methods><methods><class-id>Mapsv0 class</class-id> <category>instance creation</category><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Batiment</class-id> <category>computing</category><body package="MapAccess">convertWithZoom: zoom	| points |	points := self contour collect: [:geopos | geopos toPixelWithZoom: zoom].	^Polyline vertices: points</body><body package="MapAccess">convertWithZoomShift: zoom	| points |	points := self contour collect: [:geopos | geopos toPixelWithZoomShift: zoom].	^Polyline vertices: points</body></methods><methods><class-id>Batiment</class-id> <category>accessing</category><body package="MapAccess">contour	^contour</body><body package="MapAccess">contour: anObject	contour := anObject</body></methods><methods><class-id>Batiment</class-id> <category>adding</category><body package="MapAccess">addPosition: position	contour add: position</body></methods><methods><class-id>Batiment</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Batiment class</class-id> <category>instance creation</category><body package="MapAccess">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="MapAccess">withPositions: anArray	^self new contour: anArray</body></methods><methods><class-id>QuickTileProxyGapiv3</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://mt' , anInteger printString		, '.googleapis.com/vt?src=apiv3&amp;hl=en&amp;x=' , x printString		, '&amp;y=' , y printString		, '&amp;z=' , zoom printString)		asURI</body></methods><methods><class-id>QuickTileProxyGapiv3</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyGapiv3 class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^'Google api v3'</body><body package="QuickMap">maxSocket	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^22</body><body package="QuickMap">maxZoom	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^22</body></methods><methods><class-id>QuickConnection</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickConnection class</class-id> <category>instance creation</category><body package="QuickMap">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyGreatBritain</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string :=super baseWsn, '/osm_tiles/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>QuickTileProxyGreatBritain</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>UICellShow</class-id> <category>AHSWHC mods</category><body package="PickCell">postOpenWith: aSpec	"self uiLocation isNil		ifTrue: 			[uiLocation := UILocation new.			uiLocation open]."		[(Delay forSeconds: 1) wait.	self leNbDeClasses value: 1] fork</body></methods><methods><class-id>UICellShow</class-id> <category>fileIn/Out Occam</category><body package="PickCell">declareOccamSystemOrganizationOn: fileStream	fileStream		cr;		nextPutAll: 'DATA TYPE SystemOrganization  RECORD    INT width, height:    INT cellWidth, cellHeight:    REAL64 longitude, latitude:    INT zoom::'</body><body package="PickCell">fileOutCellIndex: index position: key elevation: elevation lat: latitude lon: longitude onStream: aStream	| z x y |	x := longitude.	y := latitude.	z := elevation.	x isNil ifTrue: [x := 0.0d].	y isNil ifTrue: [y := 0.0d].	z isNil ifTrue: [z := 0.0d].	aStream		nextPut: $[;		space.	index printOn: aStream.	aStream		nextPut: $,;		space.	key x printOn: aStream.	aStream		nextPut: $,;		space.	key y printOn: aStream.	aStream		nextPut: $,;		space.	self printDouble: x onOccamStream: aStream.	aStream		nextPut: $,;		space.	self printDouble: y onOccamStream: aStream.	aStream		nextPut: $,;		space.	self printDouble: z onOccamStream: aStream.	aStream		nextPut: $];		space</body><body package="PickCell">fileOutCellIndex: index position: key elevation: elevation lat: latitude lon: longitude uwind: ugrd vwind:vgrd onStream: aStream	| z x y u v|	x := longitude.	y := latitude.	z := elevation.	u:= ugrd.	v:= vgrd.	x isNil ifTrue: [x := 0.0d].	y isNil ifTrue: [y := 0.0d].	z isNil ifTrue: [z := 0.0d].	u isNil ifTrue: [u := 0.0d].	v isNil ifTrue: [v := 0.0d].	aStream		nextPut: $[;		space.	index printOn: aStream.	aStream		nextPut: $,;		space.	key x printOn: aStream.	aStream		nextPut: $,;		space.	key y printOn: aStream.	aStream		nextPut: $,;		space.	self printDouble: x onOccamStream: aStream.	aStream		nextPut: $,;		space.	self printDouble: y onOccamStream: aStream.	aStream		nextPut: $,;		space.	self printDouble: z onOccamStream: aStream.	aStream		nextPut: $];	"fin record CellPosition"		nextPut: $,;		space;	"debut record WindArray"		nextPut: $[;		space.	self printDouble: u onOccamStream: aStream.	aStream		nextPut: $,;		space.	self printDouble: v onOccamStream: aStream.	aStream		nextPut: $];		space	"fin record WindArray"</body><body package="PickCell">fileOutCellPosition: key elevation: elevation lat: latitude lon: longitude onStream: aStream	| z x y |	x := longitude.	y := latitude.	z := elevation.	x isNil ifTrue: [x := 0.0d].	y isNil ifTrue: [y := 0.0d].	z isNil ifTrue: [z := 0.0d].	aStream		nextPut: $[;		space.	1 printOn: aStream.	aStream		nextPut: $,;		space.		key x printOn: aStream.	aStream		nextPut: $,;		space.	key y printOn: aStream.	aStream		nextPut: $,;		space.	self printDouble: x onOccamStream: aStream.	aStream		nextPut: $,;		space.	self printDouble: y onOccamStream: aStream.	aStream		nextPut: $,;		space.	self printDouble: z onOccamStream: aStream.	aStream		nextPut: $];		space</body><body package="PickCell">fileOutCellPosition: key elevation: z onStream: aStream	| elevation |	aStream		nextPut: $[;		space.	key x printOn: aStream.	aStream		nextPut: $,;		space. 	key y printOn: aStream.	aStream		nextPut: $,;		space.	elevation := z.	z isNil ifTrue: [elevation := 0].	elevation printOn: aStream.	aStream		nextPut: $];		space</body><body package="PickCell">fileOutCellPosition: key onStream: aStream	aStream		nextPut: $[;		space.	key x printOn: aStream.	aStream		nextPut: $,;		space.	key y printOn: aStream.	aStream		nextPut: $];		space</body><body package="PickCell">fileOutDataOccamOrganizationOnStream: aStream	| orga |	orga := self systemOrganization.	aStream nextPutAll: 'VAL SystemOrganization systemOrganization IS ['.	orga width printOn: aStream.	aStream nextPutAll: ' , '.	orga height printOn: aStream.	aStream nextPutAll: ' , '.	orga cellSize x printOn: aStream.	aStream nextPutAll: ' , '.	orga cellSize y printOn: aStream.	aStream nextPutAll: ' , '.	self printDouble: orga longitude onOccamStream: aStream.	aStream nextPutAll: ' , '.	self printDouble: orga latitude onOccamStream: aStream.	aStream nextPutAll: ' , '.	orga zoom printOn: aStream.	aStream nextPutAll: ' ]: '.	aStream		cr;		cr</body><body package="PickCell">fileOutImageExtent: extent onStream: aStream	aStream		nextPut: $[;		space.	extent width printOn: aStream.	aStream		nextPut: $,;		space.	extent height printOn: aStream.	aStream		nextPut: $];		space</body><body package="PickCell">fileOutOccamClassDataForNet: net	| fileStream refClass fileName ref code nbc fileString directory |	self lesClasses selectionIndex = 0  		ifFalse: 			[refClass := self selectClassAt: self lesClasses selection.			ref := refClass values first last.			ref isNil				ifTrue: [code := '']				ifFalse: 					[nbc := self leNbDeClasses value.					code := (self codeFrom: ref radix: nbc) printString].			fileString := self guessedName , 'Data' , code , '.occ'.			directory := self guessedDirectory.			fileString := directory , '/' , fileString.			fileName := fileString asFilename.			fileStream := fileName writeStream. 			self fileOutOccamHeaderGeoData: refClass onStream: fileStream forNet: net.			self fileOutClassReferenced: refClass onStream: fileStream forNet: net.			fileStream flush.			fileStream close.			^fileString].	^nil</body><body package="PickCell">fileOutOccamHeaderGeoData: refClass onStream: fileStream	| nbCells aCell extent |	nbCells := self cellSystemSize: refClass.   	aCell := refClass values first at: 2.	extent := aCell cellImage extent.	fileStream		nextPutAll: 'DATA TYPE ImageExtent  RECORD    INT width:    INT height: :DATA TYPE CellPosition  RECORD    INT identity: -- self reference    INT x,y: -- cell position    REAL64  longitude,latitude,elevation: -- geo loc:'.	self declareOccamSystemOrganizationOn: fileStream.	fileStream		nextPutAll: 'DATA TYPE Wind  RECORD    REAL32 ugrd: --composante u du vent    REAL32 vgrd: --composante v du vent:DATA TYPE RGBPixel  RECORD    BYTE red, green, blue: :DATA TYPE Depth24ByteArray  IS [ '				, (extent x * extent y) printString.	fileStream		nextPutAll: '] RGBPixel:';		cr.	fileStream		nextPutAll: 'DATA TYPE CellImage  RECORD    ImageExtent  extent:    Depth24ByteArray pixelArray: :';		cr.	fileStream		nextPutAll: 'DATA TYPE CellArray  RECORD    CellPosition position:    Wind windArray:    CellImage image::';		cr.	self fileOutDataOccamOrganizationOnStream: fileStream.	fileStream		nextPutAll: 'VAL [   ' , nbCells printString , '] CellArray  Cells IS '</body><body package="PickCell">fileOutOccamHeaderGeoData: refClass onStream: fileStream forNet: aNet	| nbCells aCell extent |	nbCells := self cellSystemSize: refClass forNet: aNet.   	aCell := refClass values first at: 2.	extent := aCell cellImage extent.	fileStream		nextPutAll: 'DATA TYPE ImageExtent  RECORD    INT width:    INT height: :DATA TYPE CellPosition  RECORD    INT identity: -- self reference    INT x,y: -- cell position    REAL64  longitude,latitude,elevation: -- geo loc:'.	self declareOccamSystemOrganizationOn: fileStream.	fileStream		nextPutAll: 'DATA TYPE Wind  RECORD    REAL32 ugrd: --composante u du vent    REAL32 vgrd: --composante v du vent:DATA TYPE RGBPixel  RECORD    BYTE red, green, blue: :DATA TYPE Depth24ByteArray  IS [ '				, (extent x * extent y) printString.	fileStream		nextPutAll: '] RGBPixel:';		cr.	fileStream		nextPutAll: 'DATA TYPE CellImage  RECORD    ImageExtent  extent:    Depth24ByteArray pixelArray: :';		cr.	fileStream		nextPutAll: 'DATA TYPE CellArray  RECORD    CellPosition position:    Wind windArray:    CellImage image::';		cr.	self fileOutDataOccamOrganizationOnStream: fileStream.	fileStream		nextPutAll: 'VAL [   ' , nbCells printString , '] CellArray  Cells IS '</body></methods><methods><class-id>UICellShow</class-id> <category>actions</category><body package="PickCell">buildNetworkOn: thisClass	| keys dicoNeighborhood nb nodeDic netConnectivity accessibles key uipcn portee xyzRef code nbc attributes pickModel name |	keys := thisClass keys.	uipcn := self uiPickCellNodes.	uipcn isNil ifFalse: [portee := uipcn portee value asNumber].	dicoNeighborhood := Dictionary new.	keys do: 			[:point |			nb := self computeNeightboursForPoint: point from: keys.			dicoNeighborhood at: point put: nb].	nodeDic := Dictionary new. 	netConnectivity := AlgoDis.NetworkConnectivity new.	xyzRef := self lesClasses selection.	xyzRef isNil		ifTrue: [code := '']		ifFalse: 			[nbc := self leNbDeClasses value.			code := (self codeFrom: xyzRef radix: nbc) printString].	pickModel := uipcn pickModel value.	name := pickModel guessedName asFilename tail.	netConnectivity name: name    , code.	netConnectivity communications: #('none' 'defined').	dicoNeighborhood keysAndValuesDo: 			[:point :pointNb |			accessibles := pointNb collect: [:acc | self makeNameFromPoint: acc].			key := self makeNameFromPoint: point.			accessibles isEmpty				ifFalse: 					[attributes := NetworkNodeAttributes								nodeName: key asString								fanOutNodes: accessibles asArray								procedureName: 'CellNode'								point: point								range: portee.					nodeDic at: key put: attributes]].	netConnectivity nodeDictionary: nodeDic.	netConnectivity buildGraph.	^netConnectivity</body><body package="PickCell">changeIndication	| uipcn model status  gmenu item | 	uipcn := self uiPickCellNodes.	model := uipcn pickModel value. 	status := model getElevation. 	^status</body><body package="PickCell">codeFrom: xyzRef radix: nbc	| code |	code := (xyzRef at: 3) - 1.	code := code + (nbc * ((xyzRef at: 2) - 1)).	code := code + (nbc * nbc * ((xyzRef at: 1) - 1)).	^code</body><body package="PickCell">colorAtReal: position logicPosition: logPos	| array bounds x y cellImage image |	logPos isNil ifTrue: [^nil].	array := self classToCells at: logPos.	cellImage := array at: 2.	image :=  cellImage cellImage.	bounds :=image  bounds.	x := (position x \\ bounds width) truncated.	y := (position y \\ bounds height) truncated.	self lastPixel: (image  valueAtPoint: x @ y).	^self lastPixel</body><body package="PickCell">computeGlobalSignature	| nb minRed maxRed sumRed minGreen maxGreen sumGreen minBlue maxBlue sumBlue globalSignature minColour maxColour meanColour |	minRed := minGreen := minBlue := 2 raisedTo: 16.	maxRed := maxGreen := maxBlue := 0.	sumRed := sumGreen := sumBlue := 0.	self signaturesToCellMapDictionary keys do: 			[:signature |			minRed := minRed min: signature min red.			maxRed := maxRed max: signature max red.			sumRed := sumRed + signature mean red.			minGreen := minGreen min: signature min green.			maxGreen := maxGreen max: signature max green.			sumGreen := sumGreen + signature mean green.			minBlue := minBlue min: signature min blue.			maxBlue := maxBlue max: signature max blue.			sumBlue := sumBlue + signature mean blue].	nb := self signaturesToCellMapDictionary size.	minColour := ColorValue red: minRed green: minGreen blue: minBlue.	maxColour := ColorValue red: maxRed green: maxGreen blue: maxBlue.	meanColour := ColorValue				red: sumRed / nb				green: sumGreen / nb				blue: sumBlue / nb.	globalSignature := CellSignature				min: minColour				max: maxColour				mean: meanColour.	^globalSignature</body><body package="PickCell">doAccept	| text method | 	text := self lEditeur value.	method := self class compile: text classified: 'dynamic'.	self perform: method</body><body package="PickCell">doAddSource	self lesClasses selectionIndex = 0		ifFalse: 			[self selectedClasses isNil				ifFalse: [self selectedClasses add: self lesClasses selection]]</body><body package="PickCell">doAwakeLocation	| locWindows |	locWindows := UILocation allInstances				select: [:uiloc | uiloc = self uiLocation].	locWindows isEmpty		ifFalse: 			[locWindows do: 					[:win |					win						open;						closeRequest]].	self uiLocation: UILocation new.	self uiLocation open</body><body package="PickCell">doFetchElevation	| uipcn model status menu gmenu item |	uipcn := self uiPickCellNodes.	model := uipcn pickModel value.	model getElevation: model getElevation not.	status := model getElevation.	gmenu := self builder menuAt: #globalMenu.	item := gmenu menuItemLabeled: 'View'.	item := item submenu menuItemLabeled: 'fetch elevation'.	status ifTrue: [item beOn] ifFalse: [item beOff]</body><body package="PickCell">doFusion	self targetClass isNil		ifFalse: 			[self fusionDest: self targetClass selected: self selectedClasses.			"self lesClasses selection: self targetClass"]</body><body package="PickCell">doInspect	| thisClass |	self lesClasses selectionIndex = 0		ifFalse: 			[thisClass := self selectClassAt: self lesClasses selection.			thisClass inspect]</body><body package="PickCell">doLoadWind	self halt</body><body package="PickCell">doNetwork	| thisClass net |	self lesClasses selectionIndex = 0		ifFalse: 			[thisClass := self selectClassAt: self lesClasses selection.			net := self buildNetworkOn: thisClass.			self uiPickCellNodes updateGeneratorsWithCellNet: net]</body><body package="PickCell">doNetworkWithData	| thisClass net dataFileName |	self lesClasses selectionIndex = 0		ifFalse: 			[thisClass := self selectClassAt: self lesClasses selection.			net := self buildNetworkOn: thisClass.			dataFileName := self fileOutSelectedClassDataForNet: net.			self uiPickCellNodes updateGeneratorsWithCellNet: net withDataFile: dataFileName]</body><body package="PickCell">doNetworkWithDataForCuda	| thisClass net dataFileName |	self lesClasses selectionIndex = 0		ifFalse: 			[thisClass := self selectClassAt: self lesClasses selection.			net := self buildNetworkOn: thisClass.			dataFileName := self fileOutCudaClassDataForNet: net. 			self uiPickCellNodes updateGeneratorsWithCellNet: net				withDataFile: dataFileName]</body><body package="PickCell">doNetworkWithDataForOccam	| thisClass net dataFileName |	self lesClasses selectionIndex = 0  		ifFalse: 			[thisClass := self selectClassAt: self lesClasses selection.			net := self buildNetworkOn: thisClass.			dataFileName := self fileOutOccamClassDataForNet: net.			self uiPickCellNodes updateGeneratorsWithCellNet: net				withDataFile: dataFileName]</body><body package="PickCell">doTarget	self lesClasses selectionIndex = 0		ifFalse: 			[self targetClass: self lesClasses selection.			self selectedClasses: OrderedCollection new]</body><body package="PickCell">doTerminateReader	ElevationReader reader terminate</body><body package="PickCell">dumpClasse	| max x y |	max := self pointToCells keys inject: 0 @ 0				into: 					[:val :elt |					x := val x max: elt x.					y := val y max: elt y.					x @ y].	self dumpClasse: (0 @ 0 extent: max)</body><body package="PickCell">dumpClasse: bounds	| xyzRef displayed point array h w index ws allPoints fName |	self halt.	h := bounds height.	w := bounds width.	xyzRef := self lesClasses selection.	xyzRef isNil		ifFalse: 			[fName := self leMaskName value.			fName isEmpty ifTrue: [fName := 'trace.bin'].			array := Array new: h * w withAll: 0.			displayed := self laVue model value.			ws := fName asFilename writeStream.			ws isWritable ifFalse: [^Dialog warn: 'cannot write ' , fName].			self laVue model value first.			allPoints := displayed at: 2.			allPoints do: 					[:pointAsso |					point := pointAsso.					index := (point y - 1) * w + (point x - 1).					array at: index put: 1]].	w printOn: ws.	ws space.	h printOn: ws.	ws space.	array		do: [:elt | elt = 0 ifTrue: [ws nextPut: 0] ifFalse: [ws nextPut: 1]].	ws close</body><body package="PickCell">fusionDest: first selected: selected	"selected := #(#(1 1 3) #(1 1 4)   #(1 2 3) #(1 3 2) #(1 4 1) #(1 4 2) #(2 2 3) #(2 2 4))."	" 2 3 6 9 12 13 22 23 "	| firstClass classe modelArray allPoints allAssocPoints stream nbPart code |	firstClass := (self selectClassAt: first) copy.	stream := String new writeStream.	selected do: 			[:part |			nbPart := self leNbDeClasses value.			code := self codeFrom: part radix: nbPart.			stream				nextPutAll: code printString;				space.			classe := self selectClassAt: part.			firstClass addAll: classe associations].	modelArray := self laVue model value.	modelArray isNil		ifFalse: 			[allPoints := OrderedCollection new.			allAssocPoints := OrderedCollection new.			firstClass keysAndValuesDo: 					[:key :val |					allPoints add: key.					allAssocPoints add: key -&gt; (val at: 2)].			modelArray at: 2 put: allPoints.			modelArray at: 3 put: allAssocPoints.			self laVue model value: modelArray].	Transcript		show: stream contents;		cr</body><body package="PickCell">makeNameFromPoint: point	| stream |	stream := String new writeStream.	stream nextPutAll: 'Px'.	point x printOn: stream.	stream nextPutAll: 'y'.	point y printOn: stream.	^stream contents</body><body package="PickCell">openCellView: networkConnectivity doDraw: doDraw	| win comp ng stream portee points |	ng := AlgoDis.NetworkGeometry new.	portee := self uiPickCellNodes portee value asNumber. 	ng portee: portee. 	ng windowSize: self uiPickCellNodes laVue bounds width. 	win := ScheduledWindow				model: nil				label: 'cell array'				minimumSize: self uiPickCellNodes laVue  bounds corner.	comp := CompositePart new.	points := (networkConnectivity nodeDictionary values) collect: [ :pointName | pointName at: 3 ] .	ng points: points.	stream := Random new.	doDraw		ifTrue: 			[ng drawCirclesOnComposite: comp.			ng drawColorsOnComposite: comp randomStream: stream.			win component: (BoundedWrapper on: comp).			win open].	^ng</body><body package="PickCell">selectClassAt: anRGBClass	| cellDico xyz ctc |	cellDico := Dictionary new.	ctc := self classToCells.	anRGBClass isNil		ifTrue: [nil]		ifFalse: 			[ctc isNil				ifFalse: 					[ctc keysAndValuesDo: 							[:point :array |							xyz := array at: 3.							anRGBClass = xyz ifTrue: [cellDico at: point put: array]]]].	^cellDico</body><body package="PickCell">setClassToCell: nbPart	| cellDico xyzRGBCode imageSignature point cellImage |	cellDico := Dictionary new.	imageSignature := self computeGlobalSignature.	self signaturesToCellMapDictionary keysAndValuesDo: 			[:signature :pointsAndImages |			pointsAndImages do: 					[:association | 					point := association key.					cellImage := association value.					xyzRGBCode := imageSignature								rgbCoordinateFor: (signature perform: self laSignature value)								partitions: nbPart.					cellDico at: point						put: (Array with: signature with: cellImage with: xyzRGBCode)]].	^classToCells := cellDico</body><body package="PickCell">setupNbClasses	| nb coll |	nb := self leNbDeClasses value.	coll := OrderedCollection new.	1 to: nb		do: 			[:red |			1 to: nb				do: 					[:green |					1 to: nb do: [:blue | coll add: (Array with: red with: green with: blue)]]].	^coll</body></methods><methods><class-id>UICellShow</class-id> <category>printing</category><body package="PickCell">printAllView	| selection liste indices fileNamed cle nbc code name names |	selection := self lesClasses selectionIndex.	liste := self lesClasses list.	selection = 0		ifTrue: [liste isEmpty ifTrue: [^nil] ifFalse: [selection := 1]].	fileNamed := Dialog requestNewFileName: 'name for files' default: 'pattern'.	fileNamed isEmpty		ifFalse: 			[indices := (selection to: liste size) asArray						, (1 to: selection - 1) asArray.			nbc := self leNbDeClasses value.			names := OrderedCollection new: indices size.			indices do: 					[:i |					cle := liste at: i.					code := self codeFrom: cle radix: nbc.					self lesClasses selectionIndex: i.					name := fileNamed , code printString.					self savePostscriptOnFile: name.					UnixProcess cshOne: 'epspdf -b  ' , name , '.ps'.					names add: name].			self lesClasses selectionIndex: selection.			^names].	^nil</body><body package="PickCell">printDouble: double onCStream: stream	| string |	string := double asDouble printString.	string := string copyFrom: 1 to: string size - 1.	stream nextPutAll: string</body><body package="PickCell">printDouble: double onOccamStream: stream	| string |	string := double asDouble printString.	string := string copyFrom: 1 to: string size - 1.	stream nextPutAll: string</body><body package="PickCell">printLatexPage	| names ws |	names := self printAllView.	ws := 'page.tex' asFilename writeStream.	ws		nextPutAll: '\documentclass{article}%\special{landscape}\special{! /landplus90 true store} \usepackage[T1]{fontenc}\usepackage[frenchb]{babel}\usepackage{epsf} \usepackage{graphicx} \title{\textbf{From Pickcell}} \date{\today}\begin{document}\maketitle'.	names do: 			[:name |			ws				nextPutAll: '\begin{figure}';				cr.			ws nextPutAll: '\includegraphics[angle=180,width=7cm]{'.			ws nextPutAll: name.			ws				nextPutAll: '.pdf}';				cr.			ws				nextPutAll: ' \caption{' , name , '}';				cr.			ws				nextPutAll: '\end{figure}';				cr].	ws nextPutAll: '\end{document}'.	ws close.	UnixProcess cshOne: 'pdflatex page.tex'.</body><body package="PickCell">printView	self savePostscript</body><body package="PickCell">savePostscript	| box image filename drawingBounds file gc |	box := (self builder componentAt: #ViewHolder1) bounds.	image := Screen default completeContentsOfArea: box.	filename := Dialog requestNewFileName: 'Enter filename for output:'				default: 'drawing.ps'.	filename isEmpty ifTrue: [^self].	drawingBounds := image bounds.	file := PostScriptFile named: filename.	file setLandscape: drawingBounds extent x &gt; drawingBounds extent y.	gc := file graphicsContext. 	gc scaleBy: 1.	self laVue   displayOn: gc.	file close</body><body package="PickCell">savePostscriptOnFile: fileNamed	| box image filename drawingBounds file gc |	fileNamed isEmpty ifTrue: [^self].	box := (self builder componentAt: #ViewHolder1) bounds.	image := Screen default completeContentsOfArea: box.	filename := fileNamed , '.ps'.	drawingBounds := image bounds.	file := PostScriptFile named: filename.	file setLandscape: drawingBounds extent x &gt; drawingBounds extent y.	gc := file graphicsContext.	gc scaleBy: 1.	self laVue displayOn: gc.	file close</body></methods><methods><class-id>UICellShow</class-id> <category>dynamic</category><body package="PickCell">VisualLauncher open</body><body package="PickCell">kikiself uiLocation isNil		ifTrue: 			[uiLocation := UILocation new.			uiLocation open].uiLocation := UILocation new.uiLocation open</body><body package="PickCell">ps 	| box image filename drawingBounds file gc |	box := (self builder componentAt: #ViewHolder1) bounds.self halt.	image := Screen default completeContentsOfArea: box.	filename := Dialog requestNewFileName: 'Enter filename for output:'				default: 'drawing.ps'.	filename isEmpty ifTrue: [^self].	drawingBounds := image bounds.	file := PostScriptFile named: filename.	file setLandscape: drawingBounds extent x &gt; drawingBounds extent y.	gc := file graphicsContext. 	gc scaleBy: 1.	image displayOn: gc.	file close</body><body package="PickCell">self inspect.self halt.</body><body package="PickCell">testself   testBG</body><body package="PickCell">test1	| position color sel classes |	position := self lastPixel value first.	color := self lastPixel value last.	self lastPixel inspect.	sel := self lesClasses selection.sel inspect.	sel isNil		ifFalse: 			[classes := self selectClassAt:  sel.			classes values do: [:v | (v at: 2) inspect ]].</body><body package="PickCell">testAllSize	| position color sel classes list dico size nbPart code |	list := self lesClasses list.	dico := Dictionary new.	list do: 			[:partition |			classes := self selectClassAt: partition.			size := classes keys size.			nbPart := self leNbDeClasses value.			code := self codeFrom: partition radix: nbPart.			dico add: code -&gt; size].	dico inspect</body><body package="PickCell">testBG	| classes list dico size nbPart code e bg |	2 to: 4		do: 			[:i |			self leNbDeClasses value: i.			list := self lesClasses list.			dico := List new.			list do: 					[:partition |					classes := self selectClassAt: partition.					size := classes keys size.					nbPart := self leNbDeClasses value.					code := self codeFrom: partition radix: nbPart.					e := BGPickCellData new.					e						xyzRef: partition;						nbElements: size;						code: code.					dico add: e].			bg := BGPickCell new.			bg uneSerie value: dico.			bg open]</body><body package="PickCell">testFusion	| selected first firstClass classe modelArray allPoints allAssocPoints nbPart code |	selected := #(#(1 1 3) #(1 1 4) #(1 2 3) #(1 3 2) #(1 4 1) #(1 4 2) #(2 2 3) #(2 2 4)).	" 2 3 6 9 12 13 22 23 "	first := selected first.	firstClass := (self selectClassAt: first) copy.	selected do: 			[:part |			nbPart := self leNbDeClasses value.			code := self codeFrom: part radix: nbPart.			Transcript				show: code printString;				space.			classe := self selectClassAt: part.			firstClass addAll: classe associations].	modelArray := self laVue model value.	allPoints := OrderedCollection new.	allAssocPoints := OrderedCollection new.	firstClass keysAndValuesDo: 			[:key :val |			allPoints add: key.			allAssocPoints add: key -&gt; (val at: 2)].	modelArray at: 2 put: allPoints.	modelArray at: 3 put: allAssocPoints.	self laVue model value: modelArray</body><body package="PickCell">testFusion2	| selected first |	selected := #(#(1 1 3) #(1 1 4) #(1 2 3) #(1 3 2) #(1 4 1) #(1 4 2) #(2 2 3) #(2 2 4)).	" 2 3 6 9 12 13 22 23 "	first := selected first.	self fusionDest: first selected: selected</body><body package="PickCell">testSize	| position color sel classes |	position := self lastPixel value first.	color := self lastPixel value last.	self lastPixel inspect.	sel := self lesClasses selection.sel inspect.	sel isNil		ifFalse: 			[classes := self selectClassAt:  sel.Dialog warn: 'size ' , classes keys size printString.			"classes values do: [:v | (v at: 2) inspect ]"].</body></methods><methods><class-id>UICellShow</class-id> <category>accessing</category><body package="PickCell">classToCells	^classToCells</body><body package="PickCell">classToCells: anObject	classToCells := anObject</body><body package="PickCell">grid	| model |	model := self laVue model value.	model isNil ifTrue: [^nil] ifFalse: [^model first extent]</body><body package="PickCell">laVue 	^laVue</body><body package="PickCell">laVue: t1  	laVue := t1.	^self</body><body package="PickCell">lastPixel	^lastPixel</body><body package="PickCell">lastPixel: anObject	lastPixel := anObject</body><body package="PickCell">listToCell: ltc 	signaturesToCellMapDictionary := ltc.	^self</body><body package="PickCell">masterPickCellNodes: anUI	uiPickCellNodes := anUI.	self showCellSystemName</body><body package="PickCell">positionVH	^positionVH</body><body package="PickCell">positionVH: anObject	positionVH := anObject</body><body package="PickCell">selectedClasses	^selectedClasses</body><body package="PickCell">selectedClasses: anObject	selectedClasses := anObject</body><body package="PickCell">signaturesToCellMapDictionary 	^signaturesToCellMapDictionary</body><body package="PickCell">signaturesToCellMapDictionary: ltc	signaturesToCellMapDictionary := ltc.</body><body package="PickCell">systemOrganization	systemOrganization isNil ifTrue: [self setOrganization].	^systemOrganization</body><body package="PickCell">systemOrganization: anObject	systemOrganization := anObject</body><body package="PickCell">targetClass	^targetClass</body><body package="PickCell">targetClass: anObject	targetClass := anObject</body><body package="PickCell">uiLocation	uiLocation isNil		ifTrue: 			[uiLocation := UILocation new.			uiLocation open].	^uiLocation</body><body package="PickCell">uiLocation: anObject	self uiLocation isNil		ifFalse: 			[self uiLocation closeRequest.			uiLocation := nil].	uiLocation := anObject</body><body package="PickCell">uiPickCellNodes	^uiPickCellNodes</body><body package="PickCell">uiPickCellNodes: anObject	uiPickCellNodes := anObject</body></methods><methods><class-id>UICellShow</class-id> <category>fileIn/Out CUDA</category><body package="PickCell">declareCUDASystemOrganizationOn: fileStream	fileStream		cr;		nextPutAll: 'typedef struct SystemOrganization  {    int width, height;    int cellWidth, cellHeight;    double longitude, latitude;    int zoom;} SystemOrganization ; '</body><body package="PickCell">fileOutCUDACellPosition: key elevation: elevation lat: latitude lon: longitude onStream: aStream	| z x y |	x := longitude.	y := latitude.	z := elevation.	x isNil ifTrue: [x := 0.0d].	y isNil ifTrue: [y := 0.0d].	z isNil ifTrue: [z := 0.0d].	aStream		nextPut: ${;		space.	key x printOn: aStream.	aStream		nextPut: $,;		space.	key y printOn: aStream.	aStream		nextPut: $,;		space.	self printDouble: x onCStream: aStream. 	aStream		nextPut: $,;		space.	self printDouble: y onCStream: aStream. 	aStream		nextPut: $,;		space.	self printDouble: z onCStream: aStream. 	aStream		nextPut: $};		space</body><body package="PickCell">fileOutCellPositionCuda: key onStream: aStream	aStream		nextPut: ${;		space.	key x printOn: aStream.	aStream		nextPut: $,;		space.	key y printOn: aStream.				aStream		nextPut: $};		space</body><body package="PickCell">fileOutCudaClassDataForNet: net	| fileStream refClass fileName ref code nbc fileString directory |	self lesClasses selectionIndex = 0		ifFalse: 			[refClass := self selectClassAt: self lesClasses selection.			ref := refClass values first last.			ref isNil				ifTrue: [code := '']				ifFalse: 					[nbc := self leNbDeClasses value.					code := (self codeFrom: ref radix: nbc) printString].			fileString := self guessedName , 'Data' , code , '.cu'.			directory := self guessedDirectory.			fileString := directory , '/' , fileString.			fileName := fileString asFilename.			fileStream := fileName writeStream.			self fileOutCudaHeaderData: refClass onStream: fileStream.			self fileOutCudaClassReferenced: refClass onStream: fileStream.			fileStream close.			^fileString].	^nil</body><body package="PickCell">fileOutCudaClassReferenced: xyzRef onStream: aStream	| uipcn portee code nbc thisClass ref index cellImage elevation geoPosition latitude longitude |	thisClass := xyzRef.	uipcn := self uiPickCellNodes.	uipcn isNil ifFalse: [portee := uipcn portee value asNumber].	ref := xyzRef values first last.	ref isNil		ifTrue: [code := '']		ifFalse: 			[nbc := self leNbDeClasses value.			code := (self codeFrom: ref radix: nbc) printString].	index := thisClass keys size.	aStream		nextPut: ${;		space.	" start the array "	thisClass keysAndValuesDo: 			[:key :value |			aStream				"nextPut: ${;nextPut: $P;"				space.									cellImage := value at: 2.			elevation := cellImage elevation.			geoPosition := cellImage geoPosition.			latitude := geoPosition y.			longitude := geoPosition x.			aStream				nextPut: ${;				space.			self				fileOutCUDACellPosition: key				elevation: elevation				lat: latitude				lon: longitude				onStream: aStream.								 			aStream				space;				nextPut: $,;				space.			cellImage := value at: 2.			cellImage printCudaOn: aStream.			aStream space.			index := index - 1.			index = 0				ifTrue: 					[aStream						nextPutAll: '};';						cr]				ifFalse: 					[aStream						nextPut: $,;						cr;						nextPutAll: '  ']].	aStream cr</body><body package="PickCell">fileOutCudaHeaderData: refClass onStream: fileStream	| nbCells aCell extent |	nbCells := refClass keys size.	aCell := refClass values first at: 2.	extent := aCell cellImage extent. 	fileStream		nextPutAll: ' 		struct ImageExtent {      int width, height;};typedef struct CellPosition {    int x,y; /* cell geometric position */   double longitude, latitude, elevation; /* geo position */} CellPosition;struct RGBPixel {    unsigned char red, green, blue;};typedef struct RGBPixel  Depth24ByteArray  ['				, (extent x * extent y) printString , ' ] ;'.	fileStream cr.	fileStream		nextPutAll: 'typedef struct CellImage {  		       struct ImageExtent  extent;                     Depth24ByteArray pixelArray;    } CellImage; ';		cr.	fileStream		nextPutAll: 'typedef struct  CellArray{     CellPosition position;    CellImage image; }  CellArray ; ';		cr.		self declareCUDASystemOrganizationOn: fileStream.	self fileOutDataCUDAOrganizationOnStream: fileStream.		fileStream		nextPutAll: 'CellArray  Cells [   ' , nbCells printString , '] =  '</body><body package="PickCell">fileOutDataCUDAOrganizationOnStream: aStream	| orga |	orga := self systemOrganization.	aStream nextPutAll: 'SystemOrganization systemOrganization = {'.	orga width printOn: aStream.	aStream nextPutAll: ' , '.	orga height printOn: aStream.	aStream nextPutAll: ' , '.	orga cellSize x printOn: aStream.	aStream nextPutAll: ' , '.	orga cellSize y printOn: aStream.	aStream nextPutAll: ' , '.	self printDouble: orga longitude onOccamStream: aStream.	aStream nextPutAll: ' , '.	self printDouble: orga latitude onOccamStream: aStream.	aStream nextPutAll: ' , '.	orga zoom printOn: aStream.	aStream nextPutAll: ' }; '.	aStream		cr;		cr</body></methods><methods><class-id>UICellShow</class-id> <category>neighborhood</category><body package="PickCell">computeMoore1NeightboursForPoint: point from: keys	"cellular automata Von Neumann neighborhood 1 "	| sameRow neighbourgs nb |	nb := Set new.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = point y].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs = 1].	nb addAll: neighbourgs.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = (point y - 1)].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs &lt;= 1].	nb addAll: neighbourgs.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = (point y + 1)].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs &lt;= 1].	nb addAll: neighbourgs.	^nb</body><body package="PickCell">computeMoore2NeightboursForPoint: point from: keys	"cellular automata Von Neumann neighborhood 1 "	| sameRow neighbourgs nb |	nb := Set new.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = point y].	neighbourgs := sameRow				select: [:aKeyPoint | #(1 2) includes: (aKeyPoint x - point x) abs].	nb addAll: neighbourgs.	sameRow := keys				select: [:aKeyPoint | #(1 2) includes: (aKeyPoint y - point y) abs].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs &lt;= 2].	nb addAll: neighbourgs.	^nb</body><body package="PickCell">computeNeightboursForPoint: point from: keys	"cellular automata neighborhood"	self neighborhood value = #vn1Neighborhood		ifTrue: [^self computeVN1NeightboursForPoint: point from: keys].	self neighborhood value = #vn2Neighborhood		ifTrue: [^self computeVN2NeightboursForPoint: point from: keys].	self neighborhood value = #moore1Neighborhood		ifTrue: [^self computeMoore1NeightboursForPoint: point from: keys].	self neighborhood value = #moore2Neighborhood		ifTrue: [^self computeMoore2NeightboursForPoint: point from: keys]</body><body package="PickCell">computeVN1NeightboursForPoint: point from: keys	"cellular automata Von Neumann neighborhood 1 "	| sameRow neighbourgs nb |	nb := Set new.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = point y].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs = 1].	nb addAll: neighbourgs.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = (point y - 1)].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs =0 ].	nb addAll: neighbourgs.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = (point y + 1)].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs =0].	nb addAll: neighbourgs.	^nb</body><body package="PickCell">computeVN2NeightboursForPoint: point from: keys	"cellular automata Von Neumann neighborhood 1 "	| sameRow neighbourgs nb |	nb := Set new.	sameRow := keys select: [:aKeyPoint | aKeyPoint y = point y].	neighbourgs := sameRow				select: [:aKeyPoint | #(1 2) includes: (aKeyPoint x - point x) abs].	nb addAll: neighbourgs.	sameRow := keys select: [:aKeyPoint | (aKeyPoint y - point y) abs = 1].	neighbourgs := sameRow				select: [:aKeyPoint | (aKeyPoint x - point x) abs &lt;= 1].	nb addAll: neighbourgs.	sameRow := keys select: [:aKeyPoint | (aKeyPoint y - point y) abs = 2].	neighbourgs := sameRow select: [:aKeyPoint | aKeyPoint x = point x].	nb addAll: neighbourgs.	^nb</body></methods><methods><class-id>UICellShow</class-id> <category>changing</category><body package="PickCell">changeAloneClasse	"self setClassToCell: 1."	| cellImage image assocPoints ws allPoints uipcn pickModel cellArray cellDico signature position xPos yPos doGround doSea seaLevel elevation test |	(self builder componentAt: #LabelCode) labelString: 'code : 0'.	uipcn := self uiPickCellNodes.	pickModel := uipcn pickModel value.	cellArray := pickModel newCellArray.	cellDico := Dictionary new.	allPoints := OrderedCollection new.	assocPoints := OrderedCollection new.	doGround := self showGround value.	doSea := self showSea value.	seaLevel := self theSeaLevel value.	xPos := 0.	yPos := 0.	cellArray do: 			[:eachRow |			yPos := yPos + 1.			xPos := 0.			eachRow do: 					[:array3Elem |					xPos := xPos + 1.					image := array3Elem first.					signature := array3Elem at: 2.					cellImage := array3Elem at: 3. 					position := cellImage position.					elevation := cellImage elevation.					test := self checkElevation: elevation inGround: doGround inSea: doSea seaLevel: seaLevel.					position := xPos @ yPos.					test ifTrue: [					allPoints add: position.					assocPoints add: position -&gt; cellImage. 					cellDico at: position put: (Array with: signature with: cellImage with: #(1 1 1))]]].	classToCells := cellDico.	ws := (Array new: 5) writeStream.	ws nextPut: image.	"#1"	ws nextPut: allPoints.	"#2"	ws nextPut: assocPoints.	"#3"	ws nextPut: positionVH.	"#4"	ws nextPut: 0.	"#5"	ws nextPut: self.	"#6"	ws nextPut: self uiPickCellNodes.	"#7"	self laVue model value: ws contents	"			stats := self computeStats: self signaturesToCellMapDictionary.			self lesStats value: stats"</body><body package="PickCell">changeAloneClasseSaved	"self setClassToCell: 1."	| cellImage image assocPoints ws allPoints uipcn pickModel cellArray cellDico signature position xPos yPos doGround doSea seaLevel |	(self builder componentAt: #LabelCode) labelString: 'code : 0'.	uipcn := self uiPickCellNodes.	pickModel := uipcn pickModel value.	cellArray := pickModel newCellArray.	cellDico := Dictionary new.	allPoints := OrderedCollection new.	assocPoints := OrderedCollection new.	doGround := self showGround value.	doSea := self showSea value.	seaLevel := self theSeaLevel value.	xPos := 0.	yPos := 0.	cellArray do: 			[:eachRow |			yPos := yPos + 1.			xPos := 0.			eachRow do: 					[:array3Elem |					xPos := xPos + 1.					image := array3Elem first.					signature := array3Elem at: 2.					cellImage := array3Elem at: 3.					position := cellImage position.					position := xPos @ yPos.					allPoints add: position.					assocPoints add: position -&gt; cellImage.					" in setClassToCell 					cellDico at: point						put: (Array with: signature with: cellImage with: xyzRGBCode)"					cellDico at: position put: (Array with: signature with: cellImage with: #(1 1 1))]].	classToCells := cellDico.	ws := (Array new: 5) writeStream.	ws nextPut: image.	"#1"	ws nextPut: allPoints.	"#2"	ws nextPut: assocPoints.	"#3"	ws nextPut: positionVH.	"#4"	ws nextPut: 0.	"#5"	ws nextPut: self.	"#6"	ws nextPut: self uiPickCellNodes.	"#7"	self laVue model value: ws contents	"			stats := self computeStats: self signaturesToCellMapDictionary.			self lesStats value: stats"</body><body package="PickCell">changeLaVue	| xyzRef array widget position cellIndex str stream indexValues signature color | 	xyzRef := self lesClasses selection.    	xyzRef isNil		ifFalse: 			[array := self laVue model value.			widget := self builder componentAt: #LabelControl.			array isNil				ifTrue: [widget labelString: '']				ifFalse: 					[position := (array at: 4) value.					position isNil						ifFalse: 							[cellIndex := self mapIndexFor: position.							color := self colorAtReal: position logicPosition: cellIndex.							self lastPixel: position -&gt; (Array with: cellIndex with: color).							cellIndex isNil not								ifTrue: 									[stream := String new writeStream.									stream nextPutAll: (str := cellIndex printString).									indexValues := self classToCells at: cellIndex.									signature := indexValues first.									stream										cr;										nextPutAll: signature min printString.									stream										cr;										nextPutAll: signature mean printString.									stream										cr;										nextPutAll: signature max printString.									stream										cr;										nextPutAll: signature mean2 printString.									stream										cr;										nextPutAll: self lastPixel printString.									self lesStats value: stream contents]								ifFalse: [str := ''].							widget labelString: str]]]</body><body package="PickCell">changeNbClasses	| nbClasses oc dicoEquiv |	nbClasses := self setupNbClasses.	self setClassToCell: self leNbDeClasses value.	oc := OrderedCollection new.	nbClasses do: 			[:cla |			dicoEquiv := self selectClassAt: cla.			dicoEquiv isEmpty ifFalse: [oc add: cla]].	self lesClasses list: oc</body><body package="PickCell">changePerformer	| perf ltc |	perf := self lePerformer value.	ltc := signaturesToCellMapDictionary.	ltc keys do: [:aKey | aKey performer: perf].	self load: ltc.	self laListe selection: nil.	self lesClasses selectionIndex: 1 self changeSelClasse</body><body package="PickCell">changePosition	| position uipcn gm mapOrigin mousePoint mouseCell gridAspect |	uipcn := self uiPickCellNodes.	position := self positionVH value.	self uiLocation leX value: position x printString.	self uiLocation leY value: position y printString.	uipcn isNil		ifFalse: 			[gm := uipcn pickModel value mercator.			gridAspect := uipcn gridAspect.			mapOrigin := uipcn pickModel value mapOrigin.			mousePoint := self positionVH value.			uipcn pickModel value computeMouseCellAtPoint: mousePoint.			mouseCell := uipcn pickModel value mouseCell.			self uiLocation leX value: mouseCell x printString.			self uiLocation leY value: mouseCell y printString.			mapOrigin isNil				ifFalse: 					[self updateLocFromMouse: mapOrigin mousePoint: mousePoint mercator: gm.					self updateLocForCell: mapOrigin cellPoint: mouseCell mercator: gm]]</body><body package="PickCell">changeSel	| key image stats allPoints sigAndCells assocPoints allImages nbPart xyz cellDico xyzRef dicoEquiv point cellImage signature |	self laListe selection isNil		ifFalse: 			[key := self laListe selection.			cellDico := Dictionary new.			self setClassToCell: self leNbDeClasses value.			self signaturesToCellMapDictionary keysAndValuesDo: 					[:cellSignature :pointsToCellImage |					pointsToCellImage do: 							[:association |							point := association key.							cellImage := association value.							cellDico at: point put: (Array with: cellSignature with: cellImage)]]. 			sigAndCells := self pointToCells at: key.			signature := self computeGlobalSignature.			nbPart := self leNbDeClasses value.			xyzRef := signature						rgbCoordinateFor: (signature perform: self laSignature value)						partitions: nbPart.			dicoEquiv := self selectClassAt: xyzRef.			self lIndexClasses value: xyzRef printString.			image := sigAndCells last first value.			assocPoints := OrderedCollection new.			allPoints := OrderedCollection new.			allImages := OrderedCollection new.			cellDico keysAndValuesDo: 					[:keyPt :valueArray |					xyz := signature								rgbCoordinateFor: (valueArray first perform: self laSignature value)								partitions: nbPart. 					xyz = xyzRef						ifTrue: 							[allPoints add: keyPt.							allImages add: valueArray last.							assocPoints add: keyPt -&gt; valueArray last]]. 			self lesPoints value: dicoEquiv keys asSortedCollection printString.			self lesCouleurs				value: (signature perform: self laSignature value) printString. 			self laVue model				value: (Array with: image with: allPoints with: assocPoints).			stats := self computeStats: self signaturesToCellMapDictionary.			self lesStats value: stats]</body><body package="PickCell">changeSelClasse	| xyzRef nbDeClasses |	xyzRef := self lesClasses selection.	nbDeClasses := self leNbDeClasses value. 	xyzRef isNil		ifFalse: 			[nbDeClasses &gt; 1				ifTrue: [self changeSelClasse: xyzRef from: nbDeClasses]				ifFalse: [self changeAloneClasse]]</body><body package="PickCell">changeSelClasse: xyzRef from: nbDeClasses	| dicoEquivalents nbc code unePosition arraySigCellClass cellImage image allPoints allImages assocPoints label animationRegion ws stats |	self setClassToCell: nbDeClasses.	dicoEquivalents := self selectClassAt: xyzRef.	self lIndexClasses value: xyzRef printString.	nbc := self leNbDeClasses value.	code := self codeFrom: xyzRef radix: nbc.	(self builder componentAt: #LabelCode)		labelString: 'code : ' , code printString.	dicoEquivalents isEmpty		ifTrue: 			[" ca serait Ã©tonnant"			self lesPoints value: ' '.			self lesCouleurs value: ' ']		ifFalse: 			[unePosition := dicoEquivalents keys asArray first.			arraySigCellClass := dicoEquivalents at: unePosition.			cellImage := arraySigCellClass at: 2.			image := cellImage cellImage.			allPoints := dicoEquivalents keys asOrderedCollection.			allImages := dicoEquivalents values collect: [:array | array last].			"assocPoints := dicoEquivalents values collect: [ :array | array at: 2]."			assocPoints := OrderedCollection new.			dicoEquivalents keysAndValuesDo: 					[:keyPt :valueArray |					"							allPoints add: keyPt.							allImages add: valueArray last."					assocPoints add: keyPt -&gt; (valueArray at: 2)].			"			self lesPoints value: allPoints asSortedCollection asArray printString."			self lesPoints				value: dicoEquivalents keys asSortedCollection asArray printString.			self lesCouleurs				value: (arraySigCellClass first perform: self laSignature value)						printString.			label := self builder componentAt: #CellView.			animationRegion := label bounds.			view := self builder composite.			2 to: 1				by: -1				do: 					[:factor |					(Delay forMilliseconds: 100) wait.					label label: (image shrunkenBy: factor @ factor).					view invalidateRectangle: animationRegion repairNow: true].			ws := (Array new: 5) writeStream.			ws nextPut: image.	"#1"			ws nextPut: allPoints.	"#2"			ws nextPut: assocPoints.	"#3"			ws nextPut: positionVH.	"#4"			ws nextPut: 0.	"#5"			ws nextPut: self.	"#6"			ws nextPut: self uiPickCellNodes.	"#7"			self laVue model value: ws contents.			stats := self computeStats: self signaturesToCellMapDictionary.			self lesStats value: stats]</body><body package="PickCell">changeSelOld	| key image stats allPoints sigAndCells signature assocPoints allImages label animationRegion view nbPart xyz |	self signaturesToCellMapDictionary.	self laListe selection isNil		ifFalse: 			[key := self laListe selection.			sigAndCells := self pointToCells at: key.			signature := sigAndCells first.			nbPart := self leNbDeClasses value.			xyz := signature indexFor: (signature perform: self laSignature value)						partition: nbPart.			self lIndexClasses value: xyz printString.			assocPoints := sigAndCells last.			image := assocPoints first value.			allPoints := OrderedCollection new.			allImages := OrderedCollection new.			assocPoints do: 					[:asso |					allPoints add: asso key.					allImages add: asso value].			self lesPoints value: allPoints asSortedCollection asArray printString.			self lesCouleurs				value: (signature perform: self laSignature value) printString.			label := self builder componentAt: #CellView.			animationRegion := label bounds.			view := self builder composite.			5 to: 1				by: -1				do: 					[:factor |					(Delay forMilliseconds: 100) wait.					label label: (image shrunkenBy: factor @ factor).					view invalidateRectangle: animationRegion repairNow: true].			self laVue model				value: (Array with: image with: allPoints with: assocPoints).			stats := self computeStats: self signaturesToCellMapDictionary.			self lesStats value: stats]</body><body package="PickCell">changeSeuil	| ltc seuil |	self halt.	ltc := self signaturesToCellMapDictionary.	seuil := self leSeuil value asNumber.	ltc keys do: [:aKey | aKey seuil: seuil].	self load: ltc.	self laListe selection: nil</body><body package="PickCell">changeShowSensors		self laVue invalidate</body><body package="PickCell">changeSig	"	ltc := self listToCell .	self load: ltc."	| dicoEquiv xyzRef nbc code anEntry laValeur assocPoints allPoints allImages label animationRegion view stats ws cellImage |	self setClassToCell: self leNbDeClasses value.	xyzRef := #(1 1 1).	dicoEquiv := self selectClassAt: xyzRef.	self lIndexClasses value: xyzRef printString.	nbc := self leNbDeClasses value.	code := (xyzRef at: 3) - 1.	code := code + (nbc * ((xyzRef at: 2) - 1)).	code := code + (nbc * nbc * ((xyzRef at: 1) - 1)).	(self builder componentAt: #LabelCode)		labelString: 'code  ' , code printString.	dicoEquiv isEmpty		ifTrue: 			[self lesPoints value: ' '.			self lesCouleurs value: ' ']		ifFalse: 			[anEntry := dicoEquiv keys asArray first.			laValeur := dicoEquiv at: anEntry.			cellImage := laValeur at: 2.			assocPoints := OrderedCollection new.			allPoints := OrderedCollection new.			allImages := OrderedCollection new.			dicoEquiv keysAndValuesDo: 					[:keyPt :valueArray |					allPoints add: keyPt.					allImages add: valueArray last.					assocPoints add: keyPt -&gt; (valueArray at: 2)].			"			self lesPoints value: allPoints asSortedCollection asws printString."			self lesPoints				value: dicoEquiv keys asSortedCollection asArray printString.			self lesCouleurs				value: (laValeur first perform: self laSignature value) printString.			label := self builder componentAt: #CellView.			animationRegion := label bounds.			view := self builder composite.			1 to: 1				by: -1				do: 					[:factor |					(Delay forMilliseconds: 100) wait.					label label: (cellImage cellImage shrunkenBy: factor @ factor).					view invalidateRectangle: animationRegion repairNow: true].			ws := (Array new: 7) writeStream.			ws nextPut: cellImage cellImage.			ws nextPut: allPoints.			ws nextPut: assocPoints.			ws nextPut: positionVH.			ws nextPut: 0.			ws nextPut: self.	"#6"			ws nextPut: self uiPickCellNodes.	"#7"			self laVue model value: ws contents.			stats := self computeStats: self signaturesToCellMapDictionary.			self lesStats value: stats.			self leNbDeClasses value: self leNbDeClasses value]</body><body package="PickCell">load: signatures	| stats dico sc ltc |	ltc := signatures.	self signaturesToCellMapDictionary: ltc.	dico := self pointToCells: ltc.	sc := SortedCollection				sortBlock: [:p1 :p2 | p1 x = p2 x ifTrue: [p1 y &lt; p2 y] ifFalse: [p1 x &lt; p2 x]].	sc addAll: dico keys.	self laListe list: sc asOrderedCollection.	(self builder componentAt: #RadioButton2) enable.	(self builder componentAt: #RadioButton3) enable.	(self builder componentAt: #RadioButton4) enable.	stats := self computeStats: signatures.	self lesStats value: stats</body><body package="PickCell">mapIndexFor: position	| array rs image allPoints view viewBounds bounds hPos vPos point pointsToCellImage |	array := self laVue model value.	view := self builder componentAt: #ViewHolder1. 	viewBounds := view bounds.	rs := array readStream.	image := rs next.	bounds := image bounds.	allPoints := rs next.	pointsToCellImage := rs next.	view := self builder componentAt: #ViewHolder1.	viewBounds := view bounds.	viewBounds width.	viewBounds height.	hPos := (position x / bounds width) truncated.	vPos := (position y / bounds height) truncated.	point := hPos @ vPos.	point := point + (1 @ 1).	(allPoints includes: point) ifTrue: [^point] ifFalse: [^nil]</body><body package="PickCell">mapIndexIn: vue for: position	| array rs image allPoints view viewBounds bounds hPos vPos point pointsToCellImage |	array := self laVue model value.	view := self builder componentAt: #ViewHolder1.	self halt.	viewBounds := view bounds. 	rs := array readStream.	image := rs next.	bounds := image bounds.	allPoints := rs next.	pointsToCellImage  := rs next.	view := self builder componentAt: #ViewHolder1.	viewBounds := view bounds.	viewBounds width.	viewBounds height.	hPos := (position x / bounds width) truncated.	vPos := (position y / bounds height) truncated.	point := hPos @ vPos.	point :=  point +( 1  @ 1) .	(allPoints includes: point) ifTrue: [^point] ifFalse: [^point]</body><body package="PickCell">obtainLocFromMouse: mapOrigin mercator: gm	| origin zoom m lonLatMap |	origin := mapOrigin at: 1.	zoom := mapOrigin at: 2.	m := gm pixelToMeterNew: origin zoom: zoom.	lonLatMap := gm meterToLonLat: m.	^lonLatMap</body><body package="PickCell">obtainLocFromMouse: mapOrigin mousePoint: mousePoint mercator: gm	| origin zoom cp m lonLatMap |	origin := mapOrigin at: 1.	zoom := mapOrigin at: 2.	cp := origin.	m := gm pixelToMeterNew: cp zoom: zoom.	lonLatMap := gm meterToLonLat: m.	^lonLatMap</body><body package="PickCell">pointToCells	^pointToCells</body><body package="PickCell">pointToCells: signatures	| dico sc p1 p2 firstEntry | 	dico := Dictionary new.	signatures keysAndValuesDo: 			[:key :collection |			sc := SortedCollection sortBlock: 							[:ass1 :ass2 |							p1 := ass1 key.							p2 := ass2 key.							p1 x &lt; p2 x and: [p1 y &lt; p2 y]].			sc addAll: collection.			firstEntry := sc first.			dico at: firstEntry key put: (Array with: key with: collection)].	^pointToCells := dico</body><body package="PickCell">updateLocForCell: mapOrigin cellPoint: cellPoint mercator: gm	| origin zoom cp m uipcn lonLatOrigin lonLatCorner | 	uipcn := self uiPickCellNodes.	origin := mapOrigin at: 1.	zoom := mapOrigin at: 2.	cp := origin + (cellPoint * uipcn gridAspectPoint).	m := gm pixelToMeterNew: cp zoom: zoom.	lonLatOrigin := gm meterToLonLat: m.	uipcn isNil		ifTrue: 			[cp := origin + (cellPoint * uipcn gridAspectPoint).			m := gm pixelToMeterNew: cp zoom: zoom.			lonLatOrigin := gm meterToLonLat: m.			self uiLocation updateOrigin: lonLatOrigin corner: lonLatOrigin]		ifFalse: 			[cp := origin + uipcn gridAspectPoint + (cellPoint * uipcn gridAspectPoint).			m := gm pixelToMeterNew: cp zoom: zoom.			lonLatCorner := gm meterToLonLat: m.			self uiLocation updateOrigin: lonLatOrigin corner: lonLatCorner]</body><body package="PickCell">updateLocFromMouse: mapOrigin mousePoint: mousePoint mercator: gm	| origin zoom cp m lonLatMap |	origin := mapOrigin at: 1.	zoom := mapOrigin at: 2.	cp := origin + mousePoint.	m := gm pixelToMeterNew: cp zoom: zoom.	lonLatMap := gm meterToLonLat: m.	self uiLocation leXGeo value: lonLatMap x printString.	self uiLocation leYGeo value: lonLatMap y printString</body><body package="PickCell">updateModelWith: dico	| modelArray allPoints |	modelArray := self laVue model value.	allPoints := dico keys collect: [:assoc | assoc].	modelArray at: 2 put: allPoints.	modelArray at: 3 put: dico."	self cellView model value: modelArray"</body></methods><methods><class-id>UICellShow</class-id> <category>fileIn/Out</category><body package="PickCell">fileOutClassReferenced: xyzRef onStream: aStream	| uipcn portee code nbc thisClass ref index cellImage elevation geoPosition latitude longitude array position |	thisClass := xyzRef.	uipcn := self uiPickCellNodes.	uipcn isNil ifFalse: [portee := uipcn portee value asNumber]. uipcn := self uiPickCellNodes.array := uipcn pickModel value newCellArray.	ref := xyzRef values first last.	ref isNil		ifTrue: [code := '']		ifFalse: 			[nbc := self leNbDeClasses value.			code := (self codeFrom: ref radix: nbc) printString].	index := thisClass keys size.	aStream		nextPut: $[;		space.	" start the array "	array keysAndValuesDo: [ :i :triplet|		position := (triplet at: 3) position ]	thisClass keysAndValuesDo: 			[:key :value |			cellImage := value at: 2.			elevation := cellImage elevation.			geoPosition := cellImage geoPosition.			latitude := geoPosition y.			longitude := geoPosition x.			aStream				nextPut: $[;				space.			self				fileOutCellPosition: key				elevation: elevation				lat: latitude				lon: longitude				onStream: aStream.			aStream				space;				nextPut: $,;				space.			cellImage printOn: aStream.			aStream space.			"nextPut: $];nextPut: $x;"			index := index - 1.			index = 0				ifTrue: 					[aStream						nextPutAll: ']:';						cr]				ifFalse: 					[aStream						nextPut: $,;						cr;						nextPutAll: '  ']].	aStream cr</body><body package="PickCell">fileOutClassReferenced: xyzRef onStream: aStream forNet: net	| uipcn portee code nbc thisClass ref index cellImage elevation geoPosition latitude longitude nodes sort value uwind vwind windArray windDict doWind |	thisClass := xyzRef.	uipcn := self uiPickCellNodes.	uipcn isNil ifFalse: [portee := uipcn portee value asNumber].	uipcn := self uiPickCellNodes.	windArray := uipcn pickModel value windArray.	doWind := windArray isNil not.	doWind		ifTrue: 			[windDict := Dictionary new.			windArray do: 					[:elt |					| pos |					pos := elt at: 1.					windDict at: pos put: elt]].	nodes := net nodeDictionary.	sort := SortedCollection sortBlock: 					[:asso1 :asso2 |					asso1 value point  x = asso2 value point x  ifTrue: [asso1 value point  y &lt; asso2 value point  y]						ifFalse: [asso1 value point  x &lt; asso2 value point  x]].	sort addAll: nodes associations. 	ref := xyzRef values first last.	ref isNil		ifTrue: [code := '']		ifFalse: 			[nbc := self leNbDeClasses value.			code := (self codeFrom: ref radix: nbc) printString]. 	index := self cellSystemSize: thisClass forNet: net. 	aStream		nextPut: $[;		space.	" start the array "	sort keysAndValuesDo: 			[:numberKey :anAssoc |			| wind aNetworkNodeAttributes name position cellFromClass|			aNetworkNodeAttributes :=anAssoc value.			name := anAssoc key.			position := aNetworkNodeAttributes point.			cellFromClass := thisClass at: position.			cellImage := cellFromClass at: 2.			elevation := cellImage elevation.			geoPosition := cellImage geoPosition.			latitude := geoPosition y.			longitude := geoPosition x.			doWind				ifTrue: 					[wind := windDict at: position.					uwind := wind at: 3.					vwind := wind at: 4]				ifFalse: 					[uwind := 0.					vwind := 0].			aStream				nextPut: $[;				space.			self				fileOutCellIndex: numberKey				position: position				elevation: elevation				lat: latitude				lon: longitude				uwind: uwind				vwind: vwind				onStream: aStream.			aStream				space;				nextPut: $,;				space.			cellImage printOn: aStream.			aStream space.			"nextPut: $];nextPut: $x;"			index := index - 1.			index = 0				ifTrue: 					[aStream						nextPutAll: ']:';						cr]				ifFalse: 					[aStream						nextPut: $,;						cr;						nextPutAll: '  ']].	aStream cr</body><body package="PickCell">fileOutSelectedClassData	| fileStream refClass fileName ref code nbc fileString |	self lesClasses selectionIndex = 0		ifFalse: 			[refClass := self selectClassAt: self lesClasses selection.			ref := refClass values first last.			ref isNil				ifTrue: [code := '']				ifFalse: 					[nbc := self leNbDeClasses value.					code := (self codeFrom: ref radix: nbc) printString].			fileString := Dialog						requestNewFileName: 'File data .occ or .cu'						default: self guessedName , code.			fileString isNil				ifTrue: 					[Dialog warn: 'no name'.					self halt.					^nil].			fileName := fileString asFilename.			fileName extension = '.st'				ifTrue: 					[fileString := fileString copyFrom: 1 to: fileString size - 3.					fileName := (fileString , '.cu') asFilename.					Dialog warn: '.st replaced by .cu, Sorry'].			fileName extension = '.occ'				ifTrue: 					[fileStream := fileName writeStream.					self fileOutOccamHeaderGeoData: refClass onStream: fileStream.					self fileOutClassReferenced: refClass onStream: fileStream.					fileStream close.					^fileString].			(#('.cu' '.c') includes: fileName extension)				ifTrue: 					[fileStream := fileName writeStream.					self fileOutCudaHeaderData: refClass onStream: fileStream.					self fileOutCudaClassReferenced: refClass onStream: fileStream.					fileStream close.					^fileString]].	^nil</body><body package="PickCell">fileOutSelectedClassDataForCuda	| fileStream refClass fileName ref code nbc fileString directory |	self lesClasses selectionIndex = 0		ifFalse: 			[refClass := self selectClassAt: self lesClasses selection.			ref := refClass values first last.			ref isNil				ifTrue: [code := '']				ifFalse: 					[nbc := self leNbDeClasses value.					code := (self codeFrom: ref radix: nbc) printString].			fileString := self guessedName , code , 'Data.cu'.			directory := self guessedDirectory.			fileString := directory , '/' , fileString.			fileName := fileString asFilename. 			fileStream := fileName writeStream.			self fileOutCudaHeaderData: refClass onStream: fileStream.			self fileOutCudaClassReferenced: refClass onStream: fileStream.			fileStream close.			^fileString].	^nil</body><body package="PickCell">fileOutSelectedClassDataForNet: net	| fileStream refClass fileName ref code nbc fileString |	self lesClasses selectionIndex = 0		ifFalse: 			[refClass := self selectClassAt: self lesClasses selection.			ref := refClass values first last.			ref isNil				ifTrue: [code := '']				ifFalse: 					[nbc := self leNbDeClasses value.					code := (self codeFrom: ref radix: nbc) printString].			fileString := Dialog requestNewFileName: 'Cell data file (.occ or .cu)'						default: self guessedName , code.			(fileString isNil or: [fileString isEmpty])				ifTrue: 					[Dialog warn: 'no name'.					^nil].			fileName := fileString asFilename.			fileName extension = '.st'				ifTrue: 					[fileString := fileString copyFrom: 1 to: fileString size - 3.					fileName := fileString asFilename.					Dialog warn: 'removed .st , Sorry'].			fileName extension = '.occ'				ifTrue: 					[fileStream := fileName writeStream.					self fileOutOccamHeaderGeoData: refClass onStream: fileStream.					self fileOutClassReferenced: refClass onStream: fileStream forNet: net.					fileStream close.					^fileString].			(#('.cu' '.c') includes: fileName extension)				ifTrue: 					[fileStream := fileName writeStream.					self fileOutCudaHeaderData: refClass onStream: fileStream.					self fileOutCudaClassReferenced: refClass onStream: fileStream.					fileStream close.					^fileString]].	Dialog warn: 'must use .occ or .cu extension'.	^nil</body><body package="PickCell">fileOutSelectedClassDataForOccam	| fileStream refClass fileName ref code nbc fileString directory |	self lesClasses selectionIndex = 0		ifFalse: 			[refClass := self selectClassAt: self lesClasses selection.			ref := refClass values first last.			ref isNil				ifTrue: [code := '']				ifFalse: 					[nbc := self leNbDeClasses value.					code := (self codeFrom: ref radix: nbc) printString].			fileString := self guessedName , code , 'Data.occ'.			directory := self guessedDirectory.			fileString := directory , '/' , fileString.			fileName := fileString asFilename.			fileStream := fileName writeStream.			self fileOutOccamHeaderGeoData: refClass onStream: fileStream.			self fileOutClassReferenced: refClass onStream: fileStream.			fileStream close].	^fileString</body><body package="PickCell">setOrganization	| uipcn gm mapOrigin gridAspect lonLatPoint organization maVue monImage |	organization := SystemOrganization new.	uipcn := self uiPickCellNodes.	uipcn isNil		ifFalse: 			[gm := uipcn pickModel value mercator.			gridAspect := uipcn pickModel value grid.			organization cellSize: gridAspect value.			mapOrigin := uipcn pickModel value mapOrigin.			organization mapOrigin: mapOrigin first.			organization zoom: mapOrigin last.			maVue := uipcn laVue.			monImage := maVue image.			organization width: monImage width.			organization height: monImage height.			mapOrigin isNil				ifFalse: 					[lonLatPoint := self obtainLocFromMouse: mapOrigin mercator: gm.					organization longitude: lonLatPoint x.					organization latitude: lonLatPoint y]].	self systemOrganization: organization.	^organization</body></methods><methods><class-id>UICellShow</class-id> <category>aspects</category><body package="PickCell">computeStats: signatures	| keys textStream max points sign1 |	textStream := String new writeStream.	keys := signatures keys.	sign1 := keys asArray first.	textStream		nextPutAll: 'signatures  ' , keys size printString;		cr.	textStream		nextPutAll: 'seuil  ' , keys asArray first seuil printString;		cr.	max := 0.	points := nil.	signatures values do: 			[:val |			val size &gt; max				ifTrue: 					[max := val size.					points := val collect: [:each | each key]]].	textStream		nextPutAll: 'largest  ' , max printString;		cr.	points do: 			[:pt |			pt printOn: textStream.			textStream space].	textStream cr.	Transcript		cr;		show: textStream contents;		cr.	textStream		cr;		nextPutAll: 'min ' , sign1 min printString;		cr.	textStream		nextPutAll: 'max ' , sign1 max printString;		cr.	textStream		nextPutAll: 'mean ' , sign1 mean printString;		cr;		cr.	^textStream contents</body><body package="PickCell">lEditeur	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lEditeur isNil		ifTrue:			[lEditeur := String new asValue]		ifFalse:			[lEditeur]</body><body package="PickCell">lIndexClasses	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lIndexClasses isNil		ifTrue:			[lIndexClasses := String new asValue]		ifFalse:			[lIndexClasses]</body><body package="PickCell">laListe	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laListe isNil		ifTrue:			[laListe := SelectionInList new]		ifFalse:			[laListe]</body><body package="PickCell">laSignature	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laSignature isNil		ifTrue:			[laSignature := #min asValue]		ifFalse:			[laSignature]</body><body package="PickCell">leMaskName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leMaskName isNil		ifTrue:			[leMaskName := String new asValue]		ifFalse:			[leMaskName]</body><body package="PickCell">leNbDeClasses	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leNbDeClasses isNil		ifTrue: [leNbDeClasses := 1 asValue]		ifFalse: [leNbDeClasses]</body><body package="PickCell">lePerformer	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lePerformer isNil		ifTrue:			[lePerformer := nil asValue]		ifFalse:			[lePerformer]</body><body package="PickCell">leSeuil	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leSeuil isNil		ifTrue:			[leSeuil := 0.00s asValue]		ifFalse:			[leSeuil]</body><body package="PickCell">lesClasses	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lesClasses isNil		ifTrue:			[lesClasses := SelectionInList new]		ifFalse:			[lesClasses]</body><body package="PickCell">lesCouleurs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lesCouleurs isNil		ifTrue:			[lesCouleurs := String new asValue]		ifFalse:			[lesCouleurs]</body><body package="PickCell">lesPoints	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lesPoints isNil		ifTrue:			[lesPoints := String new asValue]		ifFalse:			[lesPoints]</body><body package="PickCell">lesStats	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lesStats isNil		ifTrue:			[lesStats := String new asValue]		ifFalse:			[lesStats]</body><body package="PickCell">neighborhood	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^neighborhood isNil		ifTrue:			[neighborhood :=#vn1Neighborhood  asValue]		ifFalse:			[neighborhood]</body><body package="PickCell">showGround	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showGround isNil		ifTrue:			[showGround := false asValue]		ifFalse:			[showGround]</body><body package="PickCell">showSea	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showSea isNil		ifTrue:			[showSea := false asValue]		ifFalse:			[showSea]</body><body package="PickCell">showSensors	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showSensors isNil		ifTrue:			[showSensors := false asValue]		ifFalse:			[showSensors]</body><body package="PickCell">theSeaLevel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^theSeaLevel isNil		ifTrue:			[theSeaLevel := 0 asValue]		ifFalse:			[theSeaLevel]</body></methods><methods><class-id>UICellShow</class-id> <category>initialize-release</category><body package="PickCell">initialize	super initialize.	laVue := CellView new.	laVue model: nil asValue.	self laListe selectionIndexHolder onChangeSend: #changeSel to: self.	self lesClasses selectionIndexHolder onChangeSend: #changeSelClasse		to: self.	self laSignature onChangeSend: #changeSig to: self.	self lePerformer onChangeSend: #changePerformer to: self.	self leSeuil onChangeSend: #changeSeuil to: self.	self leNbDeClasses onChangeSend: #changeNbClasses to: self.	self laVue model onChangeSend: #changeLaVue to: self.	positionVH := nil asValue.	positionVH onChangeSend: #changePosition to: self.	self showSensors onChangeSend: #changeShowSensors to: self.	self showCellSystemName.	self showSea value: true.	self showGround value: true.	self showSea onChangeSend: #changeSelClasse to: self.	self showGround onChangeSend: #changeSelClasse to: self.	self theSeaLevel onChangeSend: #changeSelClasse to: self</body><body package="PickCell">showCellSystemName	| pm name winTitle uipcn |	uipcn := self uiPickCellNodes.	uipcn isNil		ifFalse: 			[pm := uipcn pickModel value.			name := pm guessedName.			name isNil ifTrue: [name := 'no name'''].			winTitle := 'Cell browser - ' , name.			self builder window label: winTitle]</body></methods><methods><class-id>UICellShow</class-id> <category>parsing</category><body package="PickCell">guessedDirectory	| dd pm uipcn |	uipcn := self uiPickCellNodes.	uipcn isNil ifFalse:  [	pm := uipcn  pickModel value. 	pm isNil		ifTrue: 			[dd := Filename defaultDirectory.			dd := dd , '/Generated/'.			dd asFilename ensureDirectory.			^dd]		ifFalse: [^pm guessedDirectory]]</body><body package="PickCell">guessedName	| uipcn pm name |	uipcn := self uiPickCellNodes.	pm := uipcn pickModel.	pm isNil		ifFalse: 			[name := pm value guessedName.			^name].	^'aNoNameCellSystem'</body></methods><methods><class-id>UICellShow</class-id> <category>utilities</category><body package="PickCell">cellSystemSize: refClass	| nbCells |	nbCells := refClass keys size.	^nbCells</body><body package="PickCell">cellSystemSize: refClass forNet: aNet	| nbCells |	nbCells := aNet nodeDictionary keys size.	^nbCells</body><body package="PickCell">checkElevation: elevation inGround: doGround inSea: doSea seaLevel: seaLevel	(doGround and: [doSea]) ifTrue: [^true].	doSea ifFalse: [^elevation &gt; seaLevel].	doGround ifFalse: [^elevation &lt;= seaLevel].	^false</body></methods><methods><class-id>UICellShow class</class-id> <category>testing</category><body package="PickCell">test1	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."	self on: #(1 2 3).	^self</body></methods><methods><class-id>NetworkPosition</class-id> <category>accessing</category><body package="Mapsv0">altitude	^altitude</body><body package="Mapsv0">altitude: anObject	altitude := anObject</body><body package="Mapsv0">calculatePixelForZoom: zoom	metre isNil ifTrue:[metre := self mercator latLonToMeter: latitude lon: longitude].	^self mercator meterToPixelNew: metre zoom: self currentZoom</body><body package="Mapsv0">currentTile	^model value matrixTile</body><body package="Mapsv0">currentTile: anObject	currentTile := anObject</body><body package="Mapsv0">currentZoom	^self currentTile at: #zoom</body><body package="Mapsv0">latitude	^latitude</body><body package="Mapsv0">latitude: anObject	latitude := anObject</body><body package="Mapsv0">longitude	^longitude</body><body package="Mapsv0">longitude: anObject	longitude := anObject</body><body package="Mapsv0">mercator	^mercator</body><body package="Mapsv0">mercator: anObject	mercator := anObject</body><body package="Mapsv0">metre	^metre</body><body package="Mapsv0">metre: anObject	metre := anObject</body><body package="Mapsv0">model	^model</body><body package="Mapsv0">model: anObject	model := anObject</body><body package="Mapsv0">pixel	| zoom |	zoom := self currentZoom.	^pixelDico at: zoom ifAbsentPut: [self calculatePixelForZoom: zoom]</body><body package="Mapsv0">pixelDico	^pixelDico</body><body package="Mapsv0">pixelDico: anObject	pixelDico := anObject</body></methods><methods><class-id>NetworkPosition</class-id> <category>printing</category><body package="Mapsv0">printOn: aStream	aStream nextPutAll: 'Lon: '.	longitude printOn: aStream.	aStream nextPutAll: ' lat: '.	latitude printOn: aStream.	altitude isNil		ifFalse: 			[aStream nextPutAll: ' alt: '.			altitude printOn: aStream]</body></methods><methods><class-id>NetworkPosition</class-id> <category>computing</category><body package="Mapsv0">convertFromMetre	| lonlat |	lonlat := mercator meterToLatLon: metre.	longitude := lonlat y.	latitude := lonlat x.</body><body package="Mapsv0">dist: aNetworkPosition	"Distance orthodromique"	| latA lonA latB lonB r d |	latA := self latitude * Double pi / 180.	lonA := self longitude * Double pi / 180.	latB := aNetworkPosition latitude * Double pi / 180.	lonB := aNetworkPosition longitude * Double pi / 180.	"r := 6371."	r := 6378137.	"d := 2 * r * ( () sqrt ) arcSin."	d := r * (latA sin * latB sin + (latA cos * latB cos * (lonB - lonA) cos)) arcCos.	^d</body><body package="Mapsv0">pixelWithZoom: zoom	metre isNil		ifTrue: [metre := self mercator latLonToMeter: latitude lon: longitude].	^self mercator meterToPixelNew: (metre x) @ (metre y "negated") zoom: zoom</body><body package="Mapsv0">setCurrentZoom: z	currentZoom := z</body></methods><methods><class-id>NetworkPosition</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	longitude := nil.	latitude := nil.	altitude := nil.	pixelDico := Dictionary new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>NetworkPosition class</class-id> <category>testing</category><body package="Mapsv0">test1	"self test1"	(self lon: 3 lat: 4) inspect</body><body package="Mapsv0">test2	"self test2"	(self lon: 3 lat: 4 alt: 1) inspect</body></methods><methods><class-id>NetworkPosition class</class-id> <category>instance creation</category><body package="Mapsv0">lon: lon lat: lat	^(self new)		longitude: lon;		latitude: lat</body><body package="Mapsv0">lon: lon lat: lat alt: alt	^(self lon: lon lat: lat)		altitude: alt</body><body package="Mapsv0">metre: metre mercator: mercator	^(self new)		metre: metre;		mercator: mercator;		convertFromMetre;		yourself</body><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyGapiv2</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyGapiv2</class-id> <category>networking</category><body package="QuickMap">getPng: anIndex x: x y: y zoom: zoom	| httpResponse imageStream url qhr idxc cli sem |	idxc := self semIndexClient.	cli := self clientAt: idxc.	sem := self semaphoreAt: idxc.	url := self				getUri: anIndex				x: x				y: y				zoom: zoom.	qhr := QuickHttpRequest get: url.	qhr requestLine url path: ((OrderedCollection new)				add: 'vt';				add: 'lyrs=m@260000000&amp;hl=en&amp;src=apiv2&amp;x=' , x printString , '&amp;y='							, y printString , '&amp;z='							, zoom printString;				yourself).	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: cli.	sem critical: [httpResponse := qhr execute].	imageStream := httpResponse value byteSource.	^imageStream</body></methods><methods><class-id>QuickTileProxyGapiv2</class-id> <category>private</category><body package="QuickMap">getUri1: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| galileo |	galileo := 'Galileo' readStream next: (Random new next * 7) rounded.	^('http://mt' , anInteger printString		, '.google.com/vt/lyrs=m@260000000&amp;hl=en&amp;src=apiv2&amp;x=' , x printString		, '&amp;y=' , y printString		, '&amp;z=' , zoom printString		, '&amp;s=' , galileo)		asURI</body><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	"| galileo |	galileo := 'Galileo' readStream next: (Random new next * 7) rounded."	^('http://mt' ", anInteger printString"		, '.google.com/vt/lyrs=m@260000000&amp;hl=en&amp;src=apiv2&amp;x=' , x printString		, '&amp;y=' , y printString		, '&amp;z=' , zoom printString		", '&amp;s=' , galileo")		asURI</body></methods><methods><class-id>QuickTileProxyGapiv2 class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^'Google api v2'</body><body package="QuickMap">maxSocket	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^22</body><body package="QuickMap">maxZoom	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^22</body></methods><methods><class-id>Mapsv0Proxy</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Mapsv0Proxy class</class-id> <category>accessing</category><body package="Mapsv0">client	Client isNil ifTrue: [Client := self newClient]</body><body package="Mapsv0">httpConnexion	^httpConnexion</body><body package="Mapsv0">httpConnexion: anObject	httpConnexion := anObject</body><body package="Mapsv0">newClient	| url req |	url := 'http://mt.google.com/vt/x=0&amp;y=0&amp;z=0' asURI.	req := Net.HttpRequest get: url.	req fieldValueAt: 'User-Agent' put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	^(Net.HttpClient new)		readingOptions: req readingOptions;		writingOptions: req writingOptions;		yourself</body><body package="Mapsv0">tileRequest: httpRequest	| c |	c := self client.	c executeRequest: httpRequest</body></methods><methods><class-id>Mapsv0Proxy class</class-id> <category>http</category><body package="Mapsv0">executeRequest: httpRequest	^self client executeRequest: httpRequest</body></methods><methods><class-id>Mapsv0Proxy class</class-id> <category>instance creation</category><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyGkhm</class-id> <category>networking</category><body package="QuickMap">getPng: anIndex x: x y: y zoom: zoom	| httpResponse imageStream url qhr idxc cli sem |	idxc := self semIndexClient.	cli := self clientAt: idxc.	sem := self semaphoreAt: idxc.	url := self				getUri: anIndex				x: x				y: y				zoom: zoom.	qhr := QuickHttpRequest get: url.	qhr requestLine url path: (OrderedCollection new add: 'kh'; add:('v=192&amp;x=', x printString, '&amp;y=', y printString, '&amp;z=', zoom printString) ; yourself).	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: cli.	sem critical: [httpResponse := qhr execute].	imageStream := httpResponse value byteSource.	^imageStream</body></methods><methods><class-id>QuickTileProxyGkhm</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyGkhm</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	^('http://khm1' ", anInteger printString"		, '.google.com/kh/v=192&amp;x=' , x printString		, '&amp;y=' , y printString		, '&amp;z=' , zoom printString)		asURI</body></methods><methods><class-id>QuickTileProxyGkhm class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^'Google sat'</body><body package="QuickMap">maxSocket	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^6</body><body package="QuickMap">maxZoom	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^20</body></methods><methods><class-id>QuickTileModel</class-id> <category>computing</category><body package="QuickMap">addLonLat: string	| rs start ch ws |	rs := string readStream.	start := rs upTo: $ .	ch := rs next.	self textCollector isNil		ifTrue: [self newTextCollector: TextCollector new].	[rs atEnd or: [ch isSeparator not]] whileFalse: [ch := rs next].	rs atEnd		ifFalse: 			[ws := String new writeStream.			ws nextPutAll: start.			ws nextPut: $,.			ws nextPut: ch.			ws nextPutAll: rs upToEnd. 			(self textCollector)				nextPutAll: ws contents;				cr]</body><body package="QuickMap">addLonLatFromLineArrayDivision: n fromMapOrigin: mapOrigin	| start stop pointArray string | 	start := self lineArray first.	stop := self lineArray last.	self textCollector: nil.	pointArray := self pointsFromStartPos: start toStopPos: stop division: self diviseur.	pointArray do: 			[:intermediapePos |			string := self makeLatLonStringAt: intermediapePos fromOrigin: mapOrigin.			self addLonLat: string]</body><body package="QuickMap">addPosition: aPoint	| meter np |	meter := mercator pixelToMeterNew: aPoint zoom: zoom.	np := NetworkPosition metre: meter mercator: mercator.	sensorPositions add: np.</body><body package="QuickMap">addZone: aRectangle	| originMeter cornerMeter rectangleMeter |	originMeter := mercator pixelToMeterNew: aRectangle origin zoom: zoom.	cornerMeter := mercator pixelToMeterNew: aRectangle corner zoom: zoom.	rectangleMeter := Rectangle origin: originMeter corner: cornerMeter.	clicZoneAllRectangleAbsolute add: rectangleMeter.	clicZoneAllRectangle add: aRectangle.	self fillWithSensors: aRectangle</body><body package="QuickMap">fillWithSensors: aRectangleInPixel	| o ox oy c cx cy r rx ry dx dy n |	o := aRectangleInPixel origin.	ox := o x.	oy := o y.	c := aRectangleInPixel corner.	cx := c x.	cy := c y.	dx := cx - ox.	dy := cy - oy.	r := Random new.	n := sensorsNumber value.	"self halt."	n timesRepeat: 			[| sp sm s np |			rx := r next * dx + ox.			ry := r next * dy + oy.			sp := rx @ ry.			sm := mercator pixelToMeterNew: sp zoom: zoom.			np := NetworkPosition metre: sm mercator: mercator. 			"s := mercator meterToLatLon: sm."			"np := NetworkPosition lon: s y lat: s x."			sensorPositions add: np]</body><body package="QuickMap">makeLatLonArrayAt: aPixel fromOrigin: aMapOrigin	| lonlat latitude longitude meter currentPoint |		currentPoint := aPixel + aMapOrigin.	meter := self mercator pixelToMeterNew: currentPoint zoom: self zoom.	lonlat := self mercator meterToLonLat: meter.	latitude := lonlat y.	longitude := lonlat x.	^Array with: longitude with: latitude</body><body package="QuickMap">makeLatLonArrayOfStringAt: aPixel fromOrigin: aMapOrigin	| latitude longitude array |	array := self makeLatLonArrayAt: aPixel fromOrigin: aMapOrigin.	latitude := array last printString readStream upTo: $d.	longitude := array first printString readStream upTo: $d.	^Array with: longitude with: latitude</body><body package="QuickMap">makeLatLonStringAt: aPixel fromOrigin: aMapOrigin	| latitude longitude array |	array := self makeLatLonArrayOfStringAt: aPixel fromOrigin: aMapOrigin.	latitude := array last.	longitude := array first.	^ latitude , ' ', longitude</body><body package="QuickMap">makePixelAt: aPosition fromOrigin: aMapOrigin origin: aOrigin zoom: zoomView	| meter mer currentPoint relative position |	mer := self mercator.	meter := mer latLonToMeter: aPosition x lon: aPosition y.	currentPoint := mer meterToPixelNew: meter zoom: zoomView.	relative := currentPoint - aMapOrigin.	position := relative + aOrigin.	^position</body><body package="QuickMap">makePixelList: aMapOrigin origin: aOrigin zoom: zoomView	| latlong position row |	lightrapPositions isNil ifTrue: [lightrapPositions := OrderedCollection new.		]	ifFalse:[		lightrapPositions isNil whileFalse:[lightrapPositions removeFirst]		].		lightrapData isNil ifFalse:	[				1 to: lightrapData size do:		[:x| lightrapData at: x.			row := lightrapData at: x.			latlong := (row at: 6) @ (row at: 7).			position := self makePixelAt: latlong fromOrigin: aMapOrigin origin: aOrigin zoom: zoomView.						lightrapPositions add: position.						Transcript show: 'Point ', latlong x printString, '@',latlong y printString, ' ',position x printString, '@', position y printString; cr.			]		].</body><body package="QuickMap">pointsFromStartPos: start toStopPos: stop division: n	| delta points pos |	delta := (stop - start) / n.	points := OrderedCollection new.	points add: start.	pos := start.	1 to: n - 1		do: 			[:index |			pos := pos + delta.			points add: pos].	points add: stop.	^points</body><body package="QuickMap">refreshLighttraps: trapList	lightrapData := trapList</body><body package="QuickMap">refreshStations: stationList	stations := stationList</body><body package="QuickMap">zoomChanged	clicZoneAllRectangle := OrderedCollection new.	clicZoneAllRectangleAbsolute do: 			[:r |			| originPixel cornerPixel rectanglePixel |			originPixel := mercator meterToPixelNew: r origin zoom: zoom.			cornerPixel := mercator meterToPixelNew: r corner zoom: zoom.			rectanglePixel := Rectangle origin: originPixel corner: cornerPixel.			clicZoneAllRectangle add: rectanglePixel]</body></methods><methods><class-id>QuickTileModel</class-id> <category>accessing</category><body package="QuickMap">clicZone	^clicZone</body><body package="QuickMap">clicZone: anObject	clicZone := anObject</body><body package="QuickMap">clicZoneAllRectangle	^clicZoneAllRectangle</body><body package="QuickMap">clicZoneAllRectangle: anObject	clicZoneAllRectangle := anObject</body><body package="QuickMap">clicZoneInProgress	^clicZoneInProgress</body><body package="QuickMap">clicZoneInProgress: anObject	clicZoneInProgress := anObject</body><body package="QuickMap">clicZoneRectangle	^clicZoneRectangle</body><body package="QuickMap">clicZoneRectangle: anObject	clicZoneRectangle := anObject</body><body package="QuickMap">diviseur	^diviseur</body><body package="QuickMap">diviseur: anObject	diviseur := anObject</body><body package="QuickMap">geoPositionVH	^geoPositionVH</body><body package="QuickMap">highLightCells	^highLightCells</body><body package="QuickMap">highLightCells: anObject	highLightCells := anObject</body><body package="QuickMap">lastPickCellModel	^lastPickCellModel</body><body package="QuickMap">lastPickCellModel: anObject	lastPickCellModel := anObject</body><body package="QuickMap">lightrapData	^lightrapData</body><body package="QuickMap">lightrapData: anObject	lightrapData := anObject</body><body package="QuickMap">lightrapPositions	^lightrapPositions</body><body package="QuickMap">lightrapPositions: anObject	lightrapPositions := anObject</body><body package="QuickMap">lineArray	^lineArray</body><body package="QuickMap">lineArray: anObject	lineArray := anObject</body><body package="QuickMap">mercator	^mercator</body><body package="QuickMap">newTextCollector: anObject 	textCollector := anObject.	self textCollector nextPutAll: 'latitude,longitude,elevation,name' ;cr</body><body package="QuickMap">pickModel	^pickModel</body><body package="QuickMap">pickModel: anObject	pickModel := anObject</body><body package="QuickMap">pixelPerKm	^pixelPerKm</body><body package="QuickMap">pixelPerKm: anObject	pixelPerKm := anObject</body><body package="QuickMap">sensorPositions	^sensorPositions</body><body package="QuickMap">sensorPositions: anObject	sensorPositions := anObject</body><body package="QuickMap">sensorsNumber	^sensorsNumber</body><body package="QuickMap">sensorsNumber: anObject	sensorsNumber := anObject</body><body package="QuickMap">stationPositions	^stationPositions</body><body package="QuickMap">stationPositions: anObject	stationPositions := anObject</body><body package="QuickMap">stations	^stations</body><body package="QuickMap">stations: anObject	stations := anObject</body><body package="QuickMap">textCollector	 textCollector isNil		ifTrue: [self newTextCollector: TextCollector new].	^textCollector</body><body package="QuickMap">textCollector: anObject	textCollector := anObject</body><body package="QuickMap">zoom	^zoom</body><body package="QuickMap">zoom: anObject	zoom := anObject</body></methods><methods><class-id>QuickTileModel</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	sensorPositions := OrderedCollection new.	mercator := GlobalMercator new.	 self textCollector. " enforce a avalue"	geoPositionVH := (Array new: 2) asValue.	pickModel := PickMobileModel new initialize.	pickModel points: OrderedCollection new.	pickModel bounds: (Rectangle origin: 0 @ 0 corner: 1024 @ 768).	pickModel portee: 100.	pickModel filename: './aMap'.	clicZone := false.	clicZoneInProgress := false.	clicZoneAllRectangle := OrderedCollection new.	clicZoneAllRectangleAbsolute := OrderedCollection new.	clicZoneRectangle := Rectangle origin: 0 @ 0 corner: 0 @ 0.	sensorsNumber := 0 asValue.	stationPositions := nil.	self pixelPerKm: (Dictionary				withKeysAndValues: #(0 0.0078125 1 0.015625 2 0.03125 3 0.0625 4 0.125 5 0.25 6 0.5 7 1 8 2 9 5 10 9 11 18 12 36 13 72 14 144 15 288 16 575 17 1150 18 2300 19 4600 20 9200 21 18400)).	self pickModelRange onChangeSend: #changePickModelRange to: self.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>QuickTileModel</class-id> <category>aspects</category><body package="QuickMap">pickModelRange	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pickModelRange isNil		ifTrue:			[pickModelRange := 0 asValue]		ifFalse:			[pickModelRange]</body></methods><methods><class-id>QuickTileModel</class-id> <category>changing</category><body package="QuickMap">changePickModelRange	| rangeInPixel |	rangeInPixel := self pickModelRange value / 1000				* (self pixelPerKm at: zoom).	pickModel portee: rangeInPixel</body></methods><methods><class-id>QuickTileModel class</class-id> <category>instance creation</category><body package="QuickMap">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickHttpRequest</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	"mapClients := SequenceableCollection new."	^self</body></methods><methods><class-id>QuickHttpRequest</class-id> <category>accessing</category><body package="QuickMap">mapClients	^mapClients</body><body package="QuickMap">mapClients: anObject	mapClients := anObject</body></methods><methods><class-id>QuickHttpRequest</class-id> <category>low-level command interface</category><body package="QuickMap">execute	"mapClients isEmpty ifFalse:[c := mapClients removeFirst.] ifTrue:[c := self newClient.]."	| client resp |	mapClients isNil		ifTrue: [mapClients := self newClient]		ifFalse: 			[mapClients				readingOptions: self readingOptions;				writingOptions: self writingOptions].	client := mapClients.	client delaySeconds: 120.	resp := [client executeRequest: self] on: Error				do: 					[:exc |					exc class = Net.HttpStatusLineError						ifTrue: [client disconnect]						ifFalse: 							[exc class = Net.HttpObjectNotFound								ifTrue: ['Erreur 404']								ifFalse: 									[exc class = OsTransferFaultError										ifTrue: 											[exc originator close											"resp := client executeRequest: self"]										ifFalse: 											[exc class = OsError ifTrue: [client disconnect] ifFalse: ["exc inspect" nil ]]]].					client disconnect.					nil].	", Net.HttpStatusLineError"	resp isNil ifTrue: [resp := client executeRequest: self].	^resp</body></methods><methods><class-id>QuickHttpRequest</class-id> <category>parsing</category><body package="QuickMap">parse: scanner	" *** This method was defined by Net.MessageElement as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>TrackPoint</class-id> <category>accessing</category><body package="PickCell">alt	^alt</body><body package="PickCell">alt: anObject	alt := anObject</body><body package="PickCell">id	^id</body><body package="PickCell">id: anObject	id := anObject</body><body package="PickCell">lat	^lat</body><body package="PickCell">lat: anObject	lat := anObject</body><body package="PickCell">lon	^lon</body><body package="PickCell">lon: anObject	lon := anObject</body><body package="PickCell">rssi	^rssi</body><body package="PickCell">rssi: anObject	rssi := anObject</body><body package="PickCell">time	^time</body><body package="PickCell">time: anObject	time := anObject</body></methods><methods><class-id>TrackPoint</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	id := nil.	lon := nil.	lat := nil.	rssi:= nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TrackPoint class</class-id> <category>testing</category><body package="PickCell">testFrom1	^self from: '	ID1, 12:23:11, 4824.0176N, 00430.0715W, 32.5, -80'	"addGPSPoints: trackPoints"</body><body package="PickCell">testFrom2	"trackPoint := self new.	trackPoint		id: id;		lon: lon;		lat: lat;		rssi: rssi.	trackPoint from: 'ID2, 12:46:14, 4824.0155N, 00430.0543W, 53.5, -73'.	addGPSPoints: trackPoints"</body><body package="PickCell">testFrom3	"	| trackPoint |	trackPoint := self  from: 'ID2, 12:46:14, 4824.0155N, 00430.0543W, 53.5, -73'.	trackPoints"</body><body package="PickCell">testFrom4	| id rssi testValue values |	id := 1.	rssi := 1.	testValue := self new.	testValue := self						id: id						rssi: rssi.	values:= OrderedCollection new asSortedCollection: #id.	values add: testValue.						^testValue</body><body package="PickCell">testTime	"	Time readTimeFrom: '12:46:14 '  readStream . "</body></methods><methods><class-id>TrackPoint class</class-id> <category>instance creation</category><body package="PickCell">from1: textOrStream	| trackPoint rs id latitudeString north longitudeString west lat lon rssi altitude gpsTimeString gpsTime altitudeString check |	check := 0.	rs := textOrStream readStream.	id := rs upTo: $D.	id := (rs upTo: $,) asNumber.	check := check + 1.	check = 1		ifTrue: 			[rs next.	" remove aspace"			gpsTimeString := rs upTo: $,.			check := check + 1.			check = 2				ifTrue: 					[gpsTime := self parseHour: gpsTimeString.					latitudeString := rs upTo: $,.					latitudeString isEmpty ifTrue: [^nil].					north := latitudeString last = $N.					lat := self parseFloat: latitudeString.					check := check + 1.					check = 3						ifTrue: 							[longitudeString := rs upTo: $,.							longitudeString isEmpty ifTrue: [^nil].							west := longitudeString last = $W.							lon := self parseFloat: longitudeString.							check := check + 1.							check = 4								ifTrue: 									[west ifTrue: [lon := lon negated].									north ifFalse: [lat := lat negated].									altitudeString := rs upTo: $,.									altitude := altitudeString asNumber.									check := check + 1.									check = 5										ifTrue: 											[rssi := rs upToEnd asNumber.											check := check + 1.											check = 6												ifTrue: 													[trackPoint := self																id: id																lon: lon																lat: lat																rssi: rssi.													trackPoint time: gpsTime.													trackPoint alt: altitude.													check = 6 ifTrue: [^trackPoint]]]]]]].	^nil</body><body package="PickCell">from: textOrStream	| trackPoint rs id latitudeString north longitudeString west lat lon rssi altitude gpsTimeString gpsTime altitudeString check |	check := 0.	rs := textOrStream readStream.	id := rs upTo: $D.	id := (rs upTo: $,) asNumber.	check := check + 1.	check = 1		ifTrue: 			[rs next.	" remove aspace"			gpsTimeString := rs upTo: $,.			check := check + 1.			check = 2				ifTrue: 					[gpsTime := self parseHour: gpsTimeString.					latitudeString := rs upTo: $,.					latitudeString isEmpty ifTrue: [^nil].					north := latitudeString last = $N.					lat := self parseFloat: latitudeString.					check := check + 1.					check = 3						ifTrue: 							[longitudeString := rs upTo: $,.							longitudeString isEmpty ifTrue: [^nil].							west := longitudeString last = $W.							lon := self parseFloat: longitudeString.							check := check + 1.							check = 4								ifTrue: 									[west ifTrue: [lon := lon negated].									north ifFalse: [lat := lat negated].									altitudeString := rs upTo: $,.									altitude := altitudeString asNumber.									check := check + 1.									check = 5										ifTrue: 											[rssi := rs upToEnd asNumber.											check := check + 1.											check = 6												ifTrue: 													[trackPoint := self																id: id																lon: lon																lat: lat																rssi: rssi.													trackPoint time: gpsTime.													trackPoint alt: altitude.													check = 6 ifTrue: [^trackPoint]]]]]]].	^nil</body><body package="PickCell">id: id lon: lon lat: lat alt: alt rssi: rssi	| trackPoint |	trackPoint := self new.	trackPoint		id: id;		lon: lon;		lat: lat;		alt: alt;		rssi: rssi.			^trackPoint</body><body package="PickCell">id: id lon: lon lat: lat rssi: rssi	| trackPoint |	trackPoint := self new.	trackPoint		id: id;		lon: lon;		lat: lat;		rssi: rssi.	^trackPoint</body><body package="PickCell">id: id rssi: rssi	| trackPoint |	trackPoint := self new.	trackPoint		id: id;		rssi: rssi.	^trackPoint</body><body package="PickCell">id: id value: value	| trackPoint |	trackPoint := self new.	trackPoint		id: id;		value: value. 	^trackPoint</body><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="PickCell">parseFloat: aString	| rs n ch entier decimal number |	rs := aString readStream.	n := 0.	[rs atEnd] whileFalse: 			[ch := rs next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := entier + decimal.	^number asDouble</body><body package="PickCell">parseHour: aString	| rs |	rs := aString readStream.	^Time readFrom: rs</body><body package="PickCell">testValue| id value abc |	id:= 1.value:= 10.abc :=  self																id: id																value: value.</body></methods><methods><class-id>MapAccessController</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MapAccessController</class-id> <category>events</category><body package="MapAccess">redButtonPressedEvent: aRedButtonPressedEvent	| cursorPoint |	cursorPoint := self sensor cursorPointFor: aRedButtonPressedEvent.	self model value clicPointVH value: cursorPoint</body></methods><methods><class-id>GeoPosition</class-id> <category>converting</category><body package="MapAccess">resolution: zoom	^self class initialResolution / (2 raisedTo: zoom)</body><body package="MapAccess">toMeter	^toMeter isNil		ifFalse: [toMeter]		ifTrue: 			[| mx my |			mx := longitude * self class originShift / 180.0.			my := ((90 + latitude) * Double pi / 360.0) tan ln / (Double pi / 180.0).			my := my * self class originShift / 180.0.			toMeter := mx @ my.			toMeter]</body><body package="MapAccess">toPixelWithZoom: zoom	| mx my res px py xy |	xy := self toMeter.	res := self resolution: zoom.	mx := xy x.	my := xy y negated.	px := (mx + self class originShift) / res.	py := (my + self class originShift) / res.	^px rounded @ py rounded</body><body package="MapAccess">toPixelWithZoomShift: zoom	| mx my res px py xy |	xy := self toMeter.	res := self resolution: zoom.	mx := xy x.	my := xy y.	px := mx / res.	py := my / res.	^px rounded @ py rounded</body></methods><methods><class-id>GeoPosition</class-id> <category>printing</category><body package="MapAccess">printOn: aStream	longitude printOn: aStream.	aStream nextPutAll: 'Â° ; '.	latitude printOn: aStream.	(elevation isNil or: [elevation isZero])		ifTrue: [aStream nextPut: $Â°]		ifFalse: 			[aStream nextPutAll: 'Â° ; '.			elevation printOn: aStream]</body></methods><methods><class-id>GeoPosition</class-id> <category>accessing</category><body package="MapAccess">elevation	^elevation</body><body package="MapAccess">elevation: anObject	elevation := anObject</body><body package="MapAccess">latitude	^latitude</body><body package="MapAccess">latitude: anObject	latitude := anObject</body><body package="MapAccess">longitude	^longitude</body><body package="MapAccess">longitude: anObject	longitude := anObject</body></methods><methods><class-id>GeoPosition</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	longitude := nil.	latitude := nil.	elevation := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>GeoPosition class</class-id> <category>instance creation</category><body package="MapAccess">lon: lon lat: lat	^(self new)		longitude: lon;		latitude: lat</body><body package="MapAccess">lon: lon lat: lat elevation: ele	^(self lon: lon lat: lat) elevation: ele</body><body package="MapAccess">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>GeoPosition class</class-id> <category>accessing</category><body package="MapAccess">initialResolution	^initialResolution isNil		ifFalse: [initialResolution]		ifTrue: 			[| tileSize |			tileSize := 256.			initialResolution := 2 * Double pi * 6378137 / tileSize.			initialResolution]</body><body package="MapAccess">originShift	^originShift isNil		ifFalse: [originShift]		ifTrue: 			[originShift := 2 * Double pi * 6378137 / 2.0.			originShift]</body></methods><methods><class-id>QuickTileMap</class-id> <category>accessing</category><body package="QuickMap">controller	^controller</body><body package="QuickMap">controller: anObject	controller := anObject</body><body package="QuickMap">convertToPoints: lat longitude: long zoom: zoomView	"meters := "	| point m |		m := self globalMercator latLonToMeter: lat lon: long.	point := (self globalMercator meterToPixelNew: m zoom: zoomView) rounded.	^point</body><body package="QuickMap">dicoProxy	^dicoProxy</body><body package="QuickMap">getOrigin	| o |	o := self container origin.	^o</body><body package="QuickMap">globalMercator	^globalMercator</body><body package="QuickMap">globalMercator: anObject	globalMercator := anObject</body><body package="QuickMap">path	^path</body><body package="QuickMap">path: anObject	path := anObject</body><body package="QuickMap">pathInPixel	^pathInPixel</body><body package="QuickMap">pathInPixel: anObject	pathInPixel := anObject</body><body package="QuickMap">satellite	^satellite</body><body package="QuickMap">satellite: anObject	satellite := anObject</body></methods><methods><class-id>QuickTileMap</class-id> <category>changing</category><body package="QuickMap">addPointMeter: meter	| pixel |	path add: meter.	pixel := globalMercator meterToPixelNew: meter zoom: model value zoom.	pathInPixel add: pixel</body><body package="QuickMap">updateModel	self invalidateNow</body><body package="QuickMap">zoomChanged: newZoom	| gpr |	self convertPathWithZoom: newZoom.	self model value changePickModelRange.	self topComponent model doBuildGraph.	"gpr := self topComponent model gpredictReader.	gpr isNil ifFalse: [gpr mobileInterface value zoom: newZoom]"</body></methods><methods><class-id>QuickTileMap</class-id> <category>displaying</category><body package="QuickMap">displayCell: color on: aGC	| qtm cells lastPoint sat gawSat cell name |	super displayOn: aGC.	zoom := self model value zoom.	qtm := self model value.	cells := qtm highLightCells.	cells isNil		ifFalse: 			[cells keysAndValuesDo: 					[:cellIndex :arrayWithCell |					cell := arrayWithCell at: 5.					name := arrayWithCell at: 6.					image := cell cellImage.					lastPoint := cell position.					sat := Circle center: lastPoint radius: 10.					gawSat := GraphicsAttributesWrapper on: sat asFiller.					gawSat attributes: ColorValue red.					gawSat displayOn: aGC at: 0 @ 0]]</body><body package="QuickMap">displayCellx: color on: aGC	| qtm cells white bounds mid cache cacheGC mergedColor gaw ga img1 img2 pix1 pix2 pix3 cv3 rectangle |	super displayOn: aGC.	zoom := self model value zoom.	qtm := self model value.	cells := qtm highLightCells.	self halt.	cells isNil 		ifFalse: 			[white := ColorValue black.			cells keysAndValuesDo: 					[:cellIndex :cell |					image := cell cellImage.					bounds := image bounds.					mid := (bounds scaledBy: 0.5 @ 0.5) corner.					cache := Pixmap extent: bounds extent.					cacheGC := cache graphicsContext.					mergedColor := color blendWith: white weight: mid x.					rectangle := bounds asFiller.					gaw := GraphicsAttributesWrapper on: rectangle.					ga := GraphicsAttributes new paint: mergedColor.					gaw attributes: ga.					gaw displayOn: cacheGC.					img1 := cacheGC medium asImage.					img2 := aGC medium asImage.					0 to: img1 height - 1						do: 							[:yy |							0 to: img1 width - 1								do: 									[:xx |									pix1 := img1 valueAtPoint: xx @ yy.									pix2 := img2 valueAtPoint: (  (xx @ yy)).									pix3 := pix1 blendWith: pix2.									cv3 := img1 palette indexOfPaintNearest: pix3.									img1 valueAtPoint: xx @ yy put: (img1 palette at: cv3)]].					img1 displayOn: aGC at: cell position]]</body><body package="QuickMap">displayColorPathOn: aGC	colPathPolyline do: 			[:pathPolyline |			| gaws |			gaws := GraphicsAttributesWrapper on: pathPolyline asStroker.			gaws attributes: ColorValue black.			gaws displayOn: aGC]</body><body package="QuickMap">displayOn0: aGC	super displayOn: aGC.	'Bonjour' asComposedText displayOn: aGC		at: self container scrollOffset + (100 @ 100)</body><body package="QuickMap">displayOn: aGC	| comp | 	super displayOn: aGC.	"Satellite path"	pathInPixel isEmpty ifFalse: [self displayPathOn: aGC].	"New satellite path: col of Polylines"	colPathPolyline isEmpty ifFalse: [self displayColorPathOn: aGC].	zoom := self model value zoom.	comp := self model value pickModel lastGraph.	comp isNil ifFalse: [comp displayOn: aGC].	self model value clicZoneAllRectangle		do: [:r | r asStroker displayOn: aGC].	self model value clicZoneInProgress		ifTrue: 			[| r |			r := Rectangle origin: self controller clicZoneOrigin						corner: self controller clicZoneCorner.			r asStroker displayOn: aGC].	self 	displayCell: ColorValue blue on: aGC.	self displayStationsOn: aGC.</body><body package="QuickMap">displayPathOn: aGC	| p gaw sat |	p := Polyline vertices: pathInPixel asArray.	gaw := GraphicsAttributesWrapper on: p asStroker.	gaw attributes: ColorValue black.	gaw displayOn: aGC.	"Satellite icon"	pathInPixel isEmpty		ifFalse: 			[| lastPoint gawSat |			lastPoint := pathInPixel last.			sat := Circle center: lastPoint radius: 10.			gawSat := GraphicsAttributesWrapper on: sat asFiller.			gawSat attributes: ColorValue red.			gawSat displayOn: aGC at: 0 @ 0]</body><body package="QuickMap">displayPointsOn: aGC	| colPoints | 	"Satellite path"		colPoints := self model value stations.			Transcript show: colPoints size printString.</body><body package="QuickMap">displayStationsOn: aGC	| colStations pos cir gawCircle |	colStations := self model value stationPositions.		1 to: colStations size do: 	[ :element | colStations at: element.				pos := (colStations at: element) rounded.				Transcript show: pos x printString, '@', pos y printString; cr. 				cir := Circle center: pos radius: 20.		gawCircle := GraphicsAttributesWrapper on: cir asFiller.		gawCircle attributes: ColorValue red.		gawCircle displayOn: aGC.	].</body></methods><methods><class-id>QuickTileMap</class-id> <category>bounds accessing</category><body package="QuickMap">preferredExtent	"TODO: This should probably be derived from something in VisualComponent to represent maximum bounds"	^(Rectangle origin: 0 @ 0		corner: globalMercator tileSize @ globalMercator tileSize) extent</body></methods><methods><class-id>QuickTileMap</class-id> <category>private</category><body package="QuickMap">makeActiveProxy: aByteSymbol	proxy := dicoProxy at: aByteSymbol				ifAbsentPut: 					[(Compiler evaluate: aByteSymbol asString , ' new') container: self]</body><body package="QuickMap">refreshLighttrapList: traps	self model value refreshLighttraps: traps</body><body package="QuickMap">refreshStationList: stations	self model value refreshStations: stations</body></methods><methods><class-id>QuickTileMap</class-id> <category>As yet unclassified</category><body package="QuickMap">getController	controller isNil		ifTrue: 			[self controller: QuickTileController new.			self controller view: self.			self controller model: model].	^controller</body></methods><methods><class-id>QuickTileMap</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	"tileSize"	dicoProxy := Dictionary new.	"self makeActiveProxy: #QuickTileProxyOSM."	super initialize.	path := OrderedCollection new.	pathInPixel := OrderedCollection new.	globalMercator := GlobalMercator new.	model := QuickTileModel new asValue.	model value zoom: mapZoom.	model onChangeSend: #updateModel to: self.	colPathPolyline := OrderedCollection new.		" *** Replace this comment with the appropriate initialization code *** "	"self mapZoom: 12."	"tileSize := 256."	"globalMercator := GlobalMercator new."	"self container origin value: (1996 * tileSize) negated @ (1416 * tileSize) negated."	^self</body></methods><methods><class-id>QuickTileMap</class-id> <category>computing</category><body package="QuickMap">convertPathWithZoom: myZoom	| lastP colPath currentPath |	path isEmpty ifTrue: [^self].	pathInPixel := path				collect: [:point | (globalMercator meterToPixelNew: point zoom: myZoom) rounded].	lastP := pathInPixel first.	colPath := OrderedCollection new.	currentPath := OrderedCollection new.	pathInPixel do: 			[:p |			p x &gt; lastP x				ifTrue: 					[colPath add: currentPath.					currentPath := OrderedCollection new].			currentPath add: p.			lastP := p].	colPath add: currentPath.	colPathPolyline := colPath collect: [:p | Polyline vertices: p asArray]</body></methods><methods><class-id>CellView</class-id> <category>accessing</category><body package="PickCell">computeCellsFor: pixels	| array5 assocArray cell point cellImage found mutation |	array5 := self model value. 	assocArray := array5 at: 3. 	cell := assocArray select: 					[:elment |					point := elment key.					cell := elment value.					cellImage := cell cellImage.					found := false.					pixels do: 							[:pixel |							cellImage pixelsDo: 									[:x :y |									pixelPoint := cellImage valueAtPoint: x @ y.									(pixels includes: pixelPoint) ifTrue: [found := true]]].					found].	cell isEmpty		ifFalse: 			[assocArray := array5 at: 3 put: cell.			self model value: array5.			self invalidate].	^cell</body><body package="PickCell">getPixelAt: point	|  pixel   box pixmap | 	box := self bounds.	pixmap := Pixmap extent: box extent.	self  displayOn: pixmap graphicsContext. 	pixel := pixmap asImage valueAtPoint: point.	^pixel</body><body package="PickCell">getPixelByCellAt: point	| array5 image extent logicalPoint assocArray cell offset cellImage pixel |	array5 := self model value.	image := array5 first.	extent := image extent.	logicalPoint := point / extent + (1 @ 1).	logicalPoint := logicalPoint truncated.	assocArray := array5 at: 3.	cell := assocArray detect: [:elment | elment key = logicalPoint].	offset := point - (point / extent * extent).	cellImage := cell value cellImage.	pixel := cellImage valueAtPoint: offset.	^pixel</body><body package="PickCell">processRectangle: aRectangle	| box pixmap pixels image cells |	box := self bounds.	pixmap := Pixmap extent: box extent.	self displayOn: pixmap graphicsContext.	pixels := Set new.	image := pixmap asImage.	aRectangle origin y to: aRectangle corner y		do: 			[:yPos |			aRectangle origin x to: aRectangle corner x				do: [:xPos | pixels add: (image valueAtPoint: xPos @ yPos)]].	cells := self computeCellsFor: pixels.	^cells</body><body package="PickCell">processRectangleColors: aRectangle	| box pixmap pixels image |	box := self bounds.	pixmap := Pixmap extent: box extent.	self displayOn: pixmap graphicsContext.	pixels := Set new.	image := pixmap asImage.	aRectangle origin y to: aRectangle corner y		do: 			[:yPos |			aRectangle origin x to: aRectangle corner x				do: [:xPos | pixels add: (image valueAtPoint: xPos @ yPos)]].	^pixels</body></methods><methods><class-id>CellView</class-id> <category>controller accessing</category><body package="PickCell">defaultControllerClass	^CellController</body></methods><methods><class-id>CellView</class-id> <category>initialize-release</category><body package="PickCell">initialize 	super initialize.	view := nil.	^self</body></methods><methods><class-id>CellView</class-id> <category>displaying</category><body package="PickCell">displayOn: aGC	"self model value inspect."	| image aCellImage graph masterModel showSensors allPoints pointShiftedToZero theCellImage displayPoint pointsToCellImageArray |	self model value isNil		ifFalse: 			[ 			aCellImage := self model value first.			image := aCellImage.			"aGC displayImage: image at: 1 @ 1."			allPoints := self model value at: 2.			pointsToCellImageArray := self model value at: 3.			pointsToCellImageArray do: 					[:pointAsso |					pointShiftedToZero := pointAsso key - (1 @ 1).					theCellImage := pointAsso value.					displayPoint  := pointShiftedToZero scaledBy: image extent.	"+ (0 @ image height)"					aGC displayImage: theCellImage  cellImage at: displayPoint ].			showSensors := (self model value at: 6) showSensors value.			showSensors				ifTrue: 					[masterModel := self controller masterModel value.					graph := masterModel lastGraph.					graph isNil ifFalse: [graph displayOn: aGC]]]</body></methods><methods><class-id>Mapsv0Tile</class-id> <category>accessing</category><body package="Mapsv0">image	image isNil ifTrue: [self getTile].	^image</body><body package="Mapsv0">image: anObject	image := anObject</body><body package="Mapsv0">pixmap	pixmap isNil ifTrue: [pixmap := CachedImage on: self image "asRetainedMedium"].	^pixmap</body><body package="Mapsv0">pixmap: anObject	pixmap := anObject</body><body package="Mapsv0">xTile	^xTile</body><body package="Mapsv0">xTile: anObject	xTile := anObject</body><body package="Mapsv0">yTile	^yTile</body><body package="Mapsv0">yTile: anObject	yTile := anObject</body><body package="Mapsv0">zoom	^zoom</body><body package="Mapsv0">zoom: anObject	zoom := anObject</body></methods><methods><class-id>Mapsv0Tile</class-id> <category>displaying</category><body package="Mapsv0">displayOn: aGraphicContext	self pixmap displayOn: aGraphicContext</body><body package="Mapsv0">displayOn: aGraphicContext at: point	self pixmap displayOn: aGraphicContext at: point</body></methods><methods><class-id>Mapsv0Tile</class-id> <category>actions</category><body package="Mapsv0">getGoogleSatUrlTileX: tileX tileY: tileY tileZoom: tileZoom	^('http://khm.google.com/kh/v=125&amp;src=app&amp;x=' , tileX , '&amp;y=' , tileY , '&amp;z=' , tileZoom, '&amp;s=Gal') asURI</body><body package="Mapsv0">getGoogleUrlTileX: tileX tileY: tileY tileZoom: tileZoom	^('http://mt.google.com/vt/x=' , tileX , '&amp;y=' , tileY , '&amp;z=' , tileZoom) asURI</body><body package="Mapsv0">getOsmUrlTileX: tileX tileY: tileY tileZoom: tileZoom	^('http://tile.openstreetmap.org/' , tileZoom , '/' , tileX , '/' , tileY , '.png') asURI</body><body package="Mapsv0">getTile	| url req resp imageStream readerClass reader img tileX tileY tileZoom |	tileX := self xTile printString.	tileY := self yTile printString.	tileZoom := self zoom printString.	url := self getGoogleUrlTileX: tileX tileY: tileY tileZoom: tileZoom.	"url := self getGoogleSatUrlTileX: tileX tileY: tileY tileZoom: tileZoom."	"url := self getOsmUrlTileX: tileX tileY: tileY tileZoom: tileZoom."	req := Net.HttpRequest get: url.	req fieldValueAt: 'User-Agent' put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	"req fieldValueAt: 'Cookie'		put: 'khcookie=fzwq2icv06GixUT7mb24z1xmUeCgkEy5mAUocQ; OGPERM=W6%3D0.0.1.1; PREF=ID=9f5cf3ac123b6d7c:U=561832629c1ab64d:FF=4:LD=fr:TM=1332757589:LM=1361285404:SG=2:S=izkq1t8lEtR5uF83; NID=67=pr_i9rPVnM_xZlxtSMxVkNgaQ0YYl1IKnbHHfdIixEZ4j2Z_eVF5VclnEUJhGPUQgojJL-g42wkTOSSeDSD9U7Fd7M2v4QKC33h1jfrS2nk5J1xl3wHzuzdXXhBMeW64'."	resp := req execute.	"resp inspect."	imageStream := resp value byteSource.		[readerClass := ImageReader readerClassFor: imageStream.	reader := readerClass new from: imageStream] ensure: [imageStream ifNotNil: [:stream | stream close]].	img := reader image.	image := img.	^self</body><body package="Mapsv0">removeTile	image := nil</body></methods><methods><class-id>Mapsv0Tile</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	image := nil.	pixmap := nil.	^self</body></methods><methods><class-id>Mapsv0Tile class</class-id> <category>instance creation</category><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Mapsv0">x: x y: y zoom: z	| gt |	gt := self new.	gt		xTile: x;		yTile: y;		zoom: z.	^gt</body></methods><methods><class-id>QuickTileProxyThunderforest</class-id> <category>private</category><body package="QuickMap">getUri1: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| url |	url := ('http://b.tile.thunderforest.com/outdoors/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		 . 	^url asURI</body><body package="QuickMap">getUri2: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| url |	url := ('http://c.tile.thunderforest.com/outdoors/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		 . 	^url asURI</body><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| url |	url := ('http://a.tile.thunderforest.com/outdoors/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		 . 		"Transcript show: url ; cr."	^url asURI</body></methods><methods><class-id>QuickTileProxyThunderforest</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyThunderforest class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	^'Thunderforest'</body><body package="QuickMap">maxSocket	^6</body><body package="QuickMap">maxZoom	^19</body></methods><methods><class-id>NetworkDistance</class-id> <category>comparing</category><body package="Mapsv0">&lt; aNetworkDistance	"^distance &lt; aNetworkDistance distance"	^aNetworkDistance &gt;= distance</body><body package="Mapsv0">&lt;= aNetworkDistance	^(distance &gt; aNetworkDistance) not</body><body package="Mapsv0">= aNetworkDistance	^(aNetworkDistance includes: nodeA)		and: [aNetworkDistance includes: nodeB]</body><body package="Mapsv0">&gt; aNetworkDistance	^aNetworkDistance &lt; distance</body><body package="Mapsv0">&gt;= aNetworkDistance	^(distance &lt; aNetworkDistance) not</body><body package="Mapsv0">equals: aNetworkDistance	^(aNetworkDistance &lt; distance or: [NetworkDistance &gt; distance]) not</body></methods><methods><class-id>NetworkDistance</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>NetworkDistance</class-id> <category>accessing</category><body package="Mapsv0">distance	^distance</body><body package="Mapsv0">distance: anObject	distance := anObject</body><body package="Mapsv0">nodeA	^nodeA</body><body package="Mapsv0">nodeA: anObject	nodeA := anObject</body><body package="Mapsv0">nodeB	^nodeB</body><body package="Mapsv0">nodeB: anObject	nodeB := anObject</body></methods><methods><class-id>NetworkDistance</class-id> <category>displaying</category><body package="Mapsv0">displayOn: aGraphicsContext origin: aPoint	| pA pB |	pA := nodeA pos pixel.	pA := pA - aPoint.	pB := nodeB pos pixel.	pB := pB - aPoint.	aGraphicsContext displayLineFrom: pA to: pB</body></methods><methods><class-id>NetworkDistance</class-id> <category>printing</category><body package="Mapsv0">printOn: aStream	distance printOn: aStream</body></methods><methods><class-id>NetworkDistance</class-id> <category>private</category><body package="Mapsv0">computeDistance	distance := nodeA dist: nodeB</body></methods><methods><class-id>NetworkDistance</class-id> <category>testing</category><body package="Mapsv0">includes: aNode	^aNode = nodeA or: [aNode = nodeB]</body><body package="Mapsv0">remoteNode: aNode	aNode = nodeA ifTrue: [^nodeB] ifFalse: [^nodeA]</body></methods><methods><class-id>NetworkDistance class</class-id> <category>instance creation</category><body package="Mapsv0">distanceNode: aFirstNode withNode: aSecondNode	| nd |	nd := (self new)				nodeA: aFirstNode;				nodeB: aSecondNode.	nd computeDistance.	^nd</body><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyHillShading</class-id> <category>private</category><body package="QuickMap">getUri1: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'""http://otile3.mqcdn.com/tiles/1.0.0/sat/$%7Bz%7D/$%7Bx%7D/$%7By%7D.png"	^('http://otile3.mqcdn.com/tiles/1.0.0/sat/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri2: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^('http://otile3.mqcdn.com/tiles/1.0.0/sat/' , zoom printString , '/'		, x printString , '/'		, y printString , '.png')		asURI</body><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'" 	^('http://c.tiles.wmflabs.org/hillshading/' , zoom printString		, '/' , x printString		, '/' , y printString		, '.png') asURI</body></methods><methods><class-id>QuickTileProxyHillShading</class-id> <category>networking</category><body package="QuickMap">getPng: anIndex x: x y: y zoom: zoom	| httpResponse imageStream url qhr idxc cli sem baseDirName fn fnis fnos reader image ws |	baseDirName := self pickCellDir.	fn := baseDirName , self class name , '-' , x printString , '-'				, y printString.	fnis := fn , '.png'.	fnos := fn , '.png'.	fnos asFilename exists		ifTrue: 			[reader := ImageReader fromFile: fnos.			reader readImage.			image := reader image.			^image]		ifFalse: 			[idxc := self semIndexClient.			cli := self clientAt: idxc.			sem := self semaphoreAt: idxc.			url := self						getUri: anIndex						x: x						y: y						zoom: zoom.			qhr := QuickHttpRequest get: url.			qhr fieldValueAt: 'User-Agent'				put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.			qhr mapClients: cli.			sem critical: [httpResponse := qhr execute].			imageStream := httpResponse value byteSource.			ws := (fnis asFilename withEncoding: #binary) writeStream.			imageStream reset.			ws setBinary: true.			ws nextPutAll: imageStream contents.			ws				flush;				close.			"UnixProcess cshOne: 'jpegtopnm ' , fnis , '| pnmtopng ' , '&gt; ' , fnos."			UnixProcess				cshOne: 'convert ' , fnis , ' -background gray   -flatten ' , fnos.			reader := ImageReader fromFile: fnos.			reader readImage.			image := reader image.			^image].	^imageStream</body></methods><methods><class-id>QuickTileProxyHillShading</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyHillShading class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	^'Hill Shading'</body><body package="QuickMap">maxSocket	^6</body><body package="QuickMap">maxZoom	^19</body></methods><methods><class-id>AlgoDis.PickCellController</class-id> <category>event driven</category><body package="PickCell">addDBPoints: results  	| points pm myGC bounds cache cacheGC img1 point lat lon mercator geoPoint aOrigin aMapArray aMapOrigin zoom | 	points := self points.	"points isNil ifFalse: [points add: point]."	myGC := self view graphicsContext.	bounds := myGC medium bounds.	pm := self model value.	mercator := pm mercator.		aOrigin := bounds origin.	aMapArray := self model value mapOrigin.	aMapOrigin := aMapArray at: 1.	zoom := aMapArray at: 2.		results do: [ :eachPoint | 		lat := eachPoint at: 2.		lon := eachPoint at: 3.		geoPoint := lon@lat.		" Convert to pixel using mercator		 add to points collection"				point := self makePixelAt: geoPoint fromOrigin: aMapOrigin origin: aOrigin zoom: zoom mercator: mercator.		points add: point.		].	"	self halt."	cache := Pixmap extent: bounds extent.	cacheGC := cache graphicsContext.	pm bounds isNil		ifFalse: 			[pm buildGraph: cacheGC.			img1 := cacheGC medium asImage.			img1 displayOn: myGC.			self view invalidate]</body><body package="PickCell">addPoint: point	| points pm myGC bounds cache cacheGC img1 graphOK |	points := self points.	points isNil ifFalse: [points add: point].	myGC := self view graphicsContext.	bounds := myGC medium bounds.	cache := Pixmap extent: bounds extent.	cacheGC := cache graphicsContext.	pm := self model value.	pm bounds isNil		ifFalse: 			[graphOK := pm buildGraph: cacheGC.			graphOK isNil				ifFalse: 					[img1 := cacheGC medium asImage.					img1 displayOn: myGC.					self view invalidate]]</body><body package="PickCell">addPoint: point usingGC: aGC	| points gc pm |	points := self points.	points isNil ifFalse: [points add: point].	gc := self view graphicsContext.	pm := self model value.	self halt.	pm bounds isNil		ifFalse: 			[pm buildGraph: gc.			self view invalidate]</body><body package="PickCell">desiresFocus	^true</body><body package="PickCell">getDBPoints	| points pm myGC bounds  point lat lon mercator geoPoint aOrigin aMapArray aMapOrigin zoom results array | 	results := OrderedCollection new.	points := self points.	"points isNil ifFalse: [points add: point]."	myGC := self view graphicsContext.	bounds := myGC medium bounds.	pm := self model value.	mercator := pm mercator.		aOrigin := bounds origin.	aMapArray := self model value mapOrigin.	aMapOrigin := aMapArray at: 1.	zoom := aMapArray at: 2.		points  do: [ :eachPoint | 		"adapt using mercator"		array := Array new: 8.		array at: 2 put: eachPoint x.		array at: 3 put: eachPoint y.		"lon := eachPoint at: 3. "		" Convert to pixel using mercator		 add to points collection"				point := self makePixelAt: geoPoint fromOrigin: aMapOrigin origin: aOrigin zoom: zoom mercator: mercator.		points add: point.		].	"	self halt."</body><body package="PickCell">handlerForMouseEvent: event	^((self viewHasCursorWithEvent: event)		and: [self model notNil])			ifTrue: [self]			ifFalse: [nil]</body><body package="PickCell">redButtonPressedEvent: aRedButtonPressedEvent	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	| point |	Cursor crossHair show.	point := self sensor cursorPointFor: aRedButtonPressedEvent.	self sensor shiftDown		ifTrue: [self model value cellDisplay selectColorFor: point]		ifFalse: [self addPoint: point]</body></methods><methods><class-id>AlgoDis.PickCellController</class-id> <category>events</category><body package="PickCell">closeEvent: anExitEvent	"Change the cursor shape back to normal.	Also end current stroke in case red button is still being pressed."		Cursor normal show</body><body package="PickCell">closeNoTerminate	self view close</body><body package="PickCell">enterEvent: anEnterEvent	"Request keyboard focus."</body><body package="PickCell">exitEvent: anExitEvent	"Change the cursor shape back to normal.	Also end current stroke in case red button is still being pressed."		Cursor normal show</body><body package="PickCell">keyPressedEvent: event		| mikado |	event keyValue = $x		ifTrue:			[mikado := self model value. 			self model value: mikado].	event keyValue = #Up ifTrue: [Dialog warn: 'Up']</body><body package="PickCell">makePixelAt: aPosition fromOrigin: aMapOrigin origin: aOrigin zoom: zoomView mercator: aMercator	| meter currentPoint relative pos|  	meter := aMercator latLonToMeter: aPosition x lon: aPosition y.	currentPoint := aMercator meterToPixelNew: meter zoom: zoomView.	relative := currentPoint - aMapOrigin.	pos := relative + aOrigin.	^pos</body><body package="PickCell">mouseMovedEvent: aMouseMovedEvent	"Set the cursor when moving in the SketchView.	Add a new point for every mouse movement when drawing is in progress."	| pickCellModel |	Cursor crossHair show.	position := self sensor cursorPointFor: aMouseMovedEvent.	pickCellModel := self model value.	pickCellModel mousePoint value: position.</body></methods><methods><class-id>AlgoDis.PickCellController</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."		super initialize. 	^self</body><body package="PickCell">keyboardProcessor	^keyboardProcessor</body><body package="PickCell">keyboardProcessor: kp	keyboardProcessor := kp</body><body package="PickCell">release	"Upon release, change the cursor shape back to normal."		super release.	Cursor normal show</body></methods><methods><class-id>AlgoDis.PickCellController</class-id> <category>accessing</category><body package="PickCell">addAGPSPoint: aTrackPoint	| pm myGC bounds cache cacheGC img1 point lat lon mercator geoPoint aOrigin aMapOrigin zoom pickcellPoints aMapLocation myPoint |	myGC := self view graphicsContext.	bounds := myGC medium bounds.	pm := self model value.	mercator := pm mercator.	pickcellPoints := pm points.	aOrigin := bounds origin.	aMapLocation := self model value mapOrigin.	aMapOrigin := aMapLocation at: 1.	zoom := aMapLocation at: 2.	pickcellPoints := pm points.	"theTrackPoints do: 			[:eachPoint |"	"myPoint := eachPoint."	aTrackPoint isNil		ifFalse: 			[myPoint := aTrackPoint.			lat := myPoint lat.			lon := myPoint lon.			geoPoint := lat @ lon.			point := self						makePixelAt: geoPoint						fromOrigin: aMapOrigin						origin: aOrigin						zoom: zoom						mercator: mercator.			pickcellPoints add: point.			cache := Pixmap extent: bounds extent.			cacheGC := cache graphicsContext.			pm bounds isNil				ifFalse: 					[pm buildGraph: cacheGC.					img1 := cacheGC medium asImage.					img1 displayOn: myGC.					self view invalidate]]</body><body package="PickCell">addAGPSPointInactive: aTrackPoint	| pm myGC bounds cache cacheGC img1 point lat lon mercator geoPoint aOrigin aMapOrigin zoom pickcellPoints aMapLocation myPoint |	myGC := self view graphicsContext.	bounds := myGC medium bounds.	pm := self model value.	mercator := pm mercator.	pickcellPoints := pm points.	aOrigin := bounds origin.	aMapLocation := self model value mapOrigin.	aMapOrigin := aMapLocation at: 1.	zoom := aMapLocation at: 2.	pickcellPoints := pm points.	"theTrackPoints do: 			[:eachPoint |"	"myPoint := eachPoint."	aTrackPoint isNil		ifFalse: 			[myPoint := aTrackPoint.			lat := myPoint lat.			lon := myPoint lon.			geoPoint := lat @ lon.			point := self						makePixelAt: geoPoint						fromOrigin: aMapOrigin						origin: aOrigin						zoom: zoom						mercator: mercator.			pickcellPoints add: point.			cache := Pixmap extent: bounds extent.			cacheGC := cache graphicsContext.			pm bounds isNil				ifFalse: 					[pm buildGraphInactive: cacheGC.					img1 := cacheGC medium asImage.					img1 displayOn: myGC.					self view invalidate]]</body><body package="PickCell">addGPSPoints: theTrackPoints	| pm myGC bounds cache cacheGC img1 point lat lon mercator geoPoint aOrigin aMapOrigin zoom pickcellPoints aMapLocation myPoint |	myGC := self view graphicsContext.	bounds := myGC medium bounds.	pm := self model value.	mercator := pm mercator.	pickcellPoints := pm points.	aOrigin := bounds origin.	aMapLocation := self model value mapOrigin.	aMapOrigin := aMapLocation at: 1.	zoom := aMapLocation at: 2.	pickcellPoints := pm points.	theTrackPoints do: 			[:eachPoint |			myPoint := eachPoint.			lat := myPoint lat.			lon := myPoint lon.			geoPoint := lat @ lon.			point := self						makePixelAt: geoPoint						fromOrigin: aMapOrigin						origin: aOrigin						zoom: zoom						mercator: mercator.			pickcellPoints add: point].	cache := Pixmap extent: bounds extent.	cacheGC := cache graphicsContext.	pm bounds isNil		ifFalse: 			[pm buildGraph: cacheGC.			img1 := cacheGC medium asImage.			img1 displayOn: myGC.			self view invalidate]</body><body package="PickCell">getPoint	^position</body><body package="PickCell">getReveivedPoints: aTrackPoint	| pm myGC bounds point lat lon mercator geoPoint aOrigin aMapOrigin zoom aMapLocation myPoint |	myGC := self view graphicsContext.	bounds := myGC medium bounds.	pm := self model value.	mercator := pm mercator.	pm points.	aOrigin := bounds origin.	aMapLocation := self model value mapOrigin.	aMapOrigin := aMapLocation at: 1.	zoom := aMapLocation at: 2.	aTrackPoint isNil		ifFalse: 			[myPoint := aTrackPoint.			lat := myPoint lat.			lon := myPoint lon.			geoPoint := lat @ lon.			point := self						makePixelAt: geoPoint						fromOrigin: aMapOrigin						origin: aOrigin						zoom: zoom						mercator: mercator].	^point</body><body package="PickCell">points	^self model value points</body></methods><methods><class-id>PseudoTile</class-id> <category>displaying</category><body package="QuickMap">displayOn: aGC	| tileSize |	tileSize := 256.	position printString asComposedText displayOn: aGC at: position * tileSize</body></methods><methods><class-id>PseudoTile</class-id> <category>accessing</category><body package="QuickMap">position	^position</body><body package="QuickMap">position: anObject	position := anObject</body></methods><methods><class-id>PseudoTile</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>PseudoTile class</class-id> <category>instance creation</category><body package="QuickMap">id: aPoint	^self new position: aPoint</body><body package="QuickMap">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>AlgoDis.ImageHistory</class-id> <category>accessing</category><body package="PickCell">add: association	self imageHistory add: association</body><body package="PickCell">imageHistory	^imageHistory</body><body package="PickCell">imageHistory: anObject	imageHistory := anObject</body><body package="PickCell">knownMapUrl	^knownMapUrl</body><body package="PickCell">knownMapUrl: anObject	knownMapUrl := anObject</body></methods><methods><class-id>AlgoDis.ImageHistory</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	knownMapUrl := nil.	imageHistory := OrderedCollection new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.ImageHistory class</class-id> <category>instance creation</category><body package="PickCell">knownMapUrl: knownUrl	| imageHistory |	imageHistory := self new.	imageHistory knownMapUrl: knownUrl.	^imageHistory</body><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>UIQuickMap</class-id> <category>actions</category><body package="QuickMap">doAwakeLocation	| locWindows win |	locWindows := UILocation allInstances.	locWindows isEmpty		ifTrue: 			[win := UILocation new.			win open.			self uiLocation: win].	self uiLocation: locWindows first</body><body package="QuickMap">doBuildGraph	| quickTileModel pm sp z pip selected n tileViewScroller |	tileViewScroller := self quickTileMap component.	quickTileModel := tileViewScroller model value.	pm := quickTileModel pickModel.	sp := quickTileModel sensorPositions.	z := quickTileModel zoom.	sp := sp collect: [:np | np pixelWithZoom: z].	pm points: sp.	pip := tileViewScroller pathInPixel.	n := pip size.	selected := OrderedCollection new.	(1 to: n by: 100) do: 			[:i |			selected add: (pip at: i)	"select: [:pix | pix x \\ 5 = 0 or: [pix y \\ 5 = 0]]."].	pm steps: pip.	pm buildGraph: self quickTileMap graphicsContext.	self quickTileMap invalidate</body><body package="QuickMap">doBuildNet	"This stub method was generated by UIDefiner"	"self halt."	| xyTile xTile yTile zoom colNodes no symList |	gm := UIGoogleMap new.	xyTile := quickTileMap scrollOffset // 256.	xTile := xyTile x.	yTile := xyTile y.	zoom := quickTileMap component model value zoom.	gm zoom retractInterestsFor: gm.	gm xTile value: xTile.	gm yTile value: yTile.	gm zoom value: zoom.	gm oldZoom: zoom.	gm zoom onChangeSend: #changeZoom to: gm.	colNodes := quickTileMap component model value sensorPositions collect: 					[:sp |					"sp model: gm googleModel."					(AlgoDis.NetworkNodeLocalized pos: sp)						range: 100;						sym: 'it works!';						yourself].	gm range value: quickTileMap component model value pickModelRange value.	symList := (colNodes collect: [:n | n sym]) asSet asOrderedCollection.	gm googleModel value		pickModelTmp: self quickTileMap component model value pickModel.	gm networkList list: symList.	gm networkList selectAll.	gm googleModel value colNodes: colNodes.	gm googleModel value computeDistance.	gm googleModel value sortDistanceByNode.	gm googleModel value selectReachedNodes.	no := NetworkOrganisation				withReachedNodes: gm googleModel value dicoReachedNodes.	"bn := "	no buildNetwork.	"bn inspect."	"self halt."	"self lesPointsGPSVH value: colGPSPos.	self GPSColToPixelCol."	gm open.	gm doUpdateTile</body><body package="QuickMap">doBuildNet2	| view gc netAndDicoAndComposite pickModel |	"self halt."	self updatePickModel.	pickModel := self quickTileMap component model value pickModel.	pickModel filename: 'santander.net'.	view := self quickTileMap component.	gc := view graphicsContext.	"gp := self drawingParameters."	netAndDicoAndComposite := pickModel buildNetAndDisplayOn: gc" graphicParameters: gp".	self updateGeneratorsWith: netAndDicoAndComposite first.	pickModel lastGraph: netAndDicoAndComposite last.	pickModel pointDictionary: (netAndDicoAndComposite at: 2).</body><body package="QuickMap">doConfig	"config isNil		ifTrue: [config := self class openOn: self withSpec: #windowSpecConfig]		ifFalse: [config window raise]"	"self builder window openPopUpIn: (Rectangle origin: 200@200 corner: 300@300)"	"| conf |	conf := UIQuickMapConfig new.	conf masterWindow: self."	configWin isNil		ifTrue: [configWin := UIQuickMapConfig openOn: self config]		ifFalse: 			[configWin window map]</body><body package="QuickMap">doCopy	| selection |	selection := self mouseLat value  , ' ' , self mouseLon value.	TextEditorController copySelection: selection</body><body package="QuickMap">doDeleteNet	"This stub method was generated by UIDefiner"	myModel value pickModel lastGraph: nil.	self quickTileMap invalidate</body><body package="QuickMap">doDisplayCover	| uit qtm cellPosArray pm dico |	uit := UITextPoints new.	uit doLoad.	cellPosArray := uit doAnalyzeCover.	qtm := myModel value.	pm := qtm lastPickCellModel.	pm isNil		ifFalse: 			[dico := pm positionCoverDictionary: cellPosArray.			qtm highLightCells: dico.			quickTileMap component invalidateNow. ].</body><body package="QuickMap">doGeoLocalize	"This stub method was generated by UIDefiner"	| box pm tileView positionTopLeft geoLoc positionBottomRight positionBottomLeft positionTopRight map mercator qtmModel orMet bounds corMet |	self halt.	self doAwakeLocation.	map := quickTileMap component.	bounds := quickTileMap bounds.	quickTileMap offsetOrigin.	mercator := map globalMercator.	qtmModel := map model value.	gm := mercator.	orMet := gm pixelToMeterNew: bounds origin zoom: qtmModel zoom.	orMet := gm meterToLonLat: orMet.	corMet := gm pixelToMeterNew: bounds corner zoom: qtmModel zoom.	corMet := gm meterToLonLat: corMet.	self laLonTop value: corMet x printString.	self laLatTop value: corMet y printString.	pm := PickCellModel new.	pm computeLocationAtPoint: 0 @ 0.	pm filename: nil.	pm points: OrderedCollection new.	box := self quickTileMap bounds.	pm bounds: box.	tileView := self quickTileMap component.	pm mapOrigin: (Array with: self quickTileMap scrollOffset				with: tileView model value zoom).	positionTopLeft := 0 @ 0.	positionBottomRight := box extent.	positionBottomLeft := positionTopLeft x @ positionBottomRight y.	positionTopRight := positionBottomRight x @ positionBottomRight y.	geoLoc := pm computeLocationAtPoint: positionBottomLeft.	pm geoRef1: geoLoc.	geoLoc := pm computeLocationAtPoint: positionTopRight.	pm geoRef2: geoLoc.</body><body package="QuickMap">doGetPath	| qtm s ws text sFirst filename rs |	qtm := self quickTileMap component model value.	s := qtm pickModel steps copy.	filename := 'CudaInterface/stepPoints.c' asFilename.	ws := filename writeStream.	"ws := WriteStream on: String new."	ws nextPutAll: '#define NBPOINTS '.	s size printOn: ws.	ws nextPut: Character cr.	ws nextPutAll: 'point mobilePath[NBPOINTS] = {'.	ws nextPut: Character cr.	sFirst := s first.	ws nextPutAll: '  {'.	sFirst x printOn: ws.	ws nextPutAll: ', '.	sFirst y printOn: ws.	ws nextPutAll: '}'.	ws nextPut: Character cr.	s removeFirst.	s do: 			[:p |			ws nextPutAll: ', {'.			p x printOn: ws.			ws nextPutAll: ', '.			p y printOn: ws.			ws nextPutAll: '}'.			ws nextPut: Character cr].	ws nextPutAll: '  } ;'.	ws nextPut: Character cr.	ws close.	rs := filename readStream.	text := rs contents.	rs close.	text asText inspect</body><body package="QuickMap">doLoadMeteoData	"This stub method was generated by UIDefiner"	" self parseCSVFile:	'postesSynop.csv' "		| aOrigin aMapOrigin zoom |	aOrigin := self quickTileMap container container bounds origin.	aMapOrigin := self quickTileMap scrollOffset.	zoom := self quickTileMap component zoom.			self quickTileMap component model value makePixelList: aMapOrigin origin: aOrigin zoom: zoom.</body><body package="QuickMap">doMove	| delta |	delta := 1 @ 1.	forkMove := 			[1000 timesRepeat: 					[self quickTileMap scrollBy: delta.					(Delay forMilliseconds: 1) wait]]					forkAt: Processor timingPriority</body><body package="QuickMap">doMoveBrest	"| tileSize so |"	"tileSize := 256."	"self halt."	"so := quickTileMap container scrollOffset."	"so inspect."	self setBrest.	self quickTileMap component invalidate.</body><body package="QuickMap">doMoveMap	"This stub method was generated by UIDefiner"	| model c |	c := (self builder componentAt: #ActionButton8) component component. 	"c instVarNamed: 'isInTransition' put: true.	c redisplayForTransitionChange.	c instVarNamed: 'isInTransition' put: true.	c redisplayForTransitionChange."	c isInTransition: true.	c := (self builder componentAt: #ActionButton7) component component. 	c isInTransition: false.	model := self quickTileMap component model value.	model clicZone: false.	^self</body><body package="QuickMap">doOpenGpredict	"This stub method was generated by UIDefiner"	gpredictReader := GpredictReader new.	gpredictReader open.	gpredictReader doStart.	"currentZoom := quickTileMap component mapZoom.	gpredictReader mobileInterface value zoom: currentZoom."	gpredictReader mobileInterface onChangeSend: #fetchSatPos to: self.	forkDelay := 			[[true] whileTrue: 					[(Delay forMilliseconds: 1000) wait.					self updateMap]]					fork</body><body package="QuickMap">doOpenGpredictFileReader	"This stub method was generated by UIDefiner"	gpredictTraceReader := GPredictTraceReader new.	gpredictTraceReader pathLonLat: quickTileMap component path.	gpredictTraceReader open</body><body package="QuickMap">doOpenPickcell	"open a pick cell window"	| box uiPickCell pm origin tileView boxView pixmap | 	boxView := self builder componentAt: #ViewHolder1.	origin := self builder window displayBox origin.	box := boxView bounds translatedBy: origin.	pixmap := Pixmap extent: box extent.	quickTileMap displayOn: pixmap graphicsContext.	uiPickCell := UIPickCellNodes new.	pm := uiPickCell pickModel value.	pm filename: nil.	pm points: OrderedCollection new.	pm bounds: box.	tileView := self quickTileMap component.	pm mapOrigin: (Array with: self quickTileMap scrollOffset				with: tileView model value zoom).	uiPickCell pickModel value: pm.	uiPickCell laVue image: pixmap asImage. 	myModel value lastPickCellModel: pm.	"keep this model"	uiPickCell open</body><body package="QuickMap">doOpenPickcellOld	"This stub method was generated by UIDefiner"	| box uiPickCell pm image origin image32 pixel tileView boxView qtm pixmap |	self halt. 	qtm := quickTileMap   .	boxView := self builder componentAt: #ViewHolder1.	origin := self builder window displayBox origin.	box := boxView bounds translatedBy: origin. 	pixmap := Pixmap extent: box extent.	qtm displayOn: pixmap graphicsContext  .	image := Screen default completeContentsOfArea: box.	image := pixmap.	uiPickCell := UIPickCellNodes new.	pm := uiPickCell pickModel value.	pm filename: nil.	pm points: OrderedCollection new.	pm bounds: box.	tileView := self quickTileMap component.	pm mapOrigin: (Array with: self quickTileMap scrollOffset				with: tileView model value zoom).	uiPickCell pickModel value: pm.	image32 := Image				extent: image extent				depth: image depth				palette: image palette."	image pixelsDo: 			[:x :y |			pixel := image valueAtPoint: x @ y.			image32 valueAtPoint: x @ y put: pixel]."	"uiPickCell laVue image: image32."	uiPickCell laVue image: pixmap asImage.	"	self tileView displayOn: image asRetainedMedium graphicsContext."	uiPickCell open</body><body package="QuickMap">doOpenShapefile	| shxFilename |	shxFilename := Dialog				requestFileNameWithMessage: 'Browse Shapefile file'				default: '*.shx'				version: #mustBeOld				ifFail: [^nil]				for: nil. 	self parseSHXFileOrString: shxFilename.	self quickTileMap component invalidate</body><body package="QuickMap">doSatPathDuration	| map path pathInMeter mercator z |	"self satPathDuration value inspect."	path := SgpSdpInterface				pathAAUCubeSatNextHours: self satPathDuration value.	"path inspect."	map := quickTileMap component.	mercator := map globalMercator.	pathInMeter := path collect: 					[:p |					| m |					m := mercator latLonToMeter: p y lon: p x.					m].	map path: pathInMeter.	z := myModel value zoom.	map convertPathWithZoom: z.	"self doBuildGraph."	quickTileMap invalidate</body><body package="QuickMap">doSavePoints	"This stub method was generated by UIDefiner"	| quickTileModel textCollector name filename ws urlName result |	quickTileModel := self quickTileMap component.	quickTileModel := quickTileModel model value.	textCollector := quickTileModel textCollector.	name := 'points.text'.	urlName := 'ftp://ftpremote:wputamd64@wsn.univ-brest.fr/' , name.	filename := name asFilename.	ws := filename writeStream.	ws isWritable		ifTrue: 			[ws nextPutAll: textCollector value.			ws close].	result := UnixProcess cshOne: 'wput -u ' , name , ' ' , urlName.	Dialog warn: result</body><body package="QuickMap">doSetSensorZone	"This stub method was generated by UIDefiner"	"Add a zone filled with sensors"	| model c |	c := (self builder componentAt: #ActionButton8) component component. 	c isInTransition: false.	c := (self builder componentAt: #ActionButton7) component component. 	c isInTransition: true.	model := self quickTileMap component model value.	model clicZone: true.	"Cursor crossHair show."	^self</body><body package="QuickMap">doShowStationsonMap	"This stub method was generated by UIDefiner"	| results |	results := self retrieveStationData: 'wsn' password: 'wsn'  environment: 'opale:5432_pickcelldb0' strSql: 'Select stationid, quote_literal(stationname) as name, latitude, longitude, elevation From Station'.</body><body package="QuickMap">doStopMove	forkMove isNil ifFalse: [forkMove terminate]</body><body package="QuickMap">doTestTimestamp1	| path pathInMeter mercator |	path := SgpSdpInterface pathAAUCubeSatNextHours: 2 + (4/60).	mercator := GlobalMercator new.	pathInMeter := path collect: 					[:p |					| m |					m := mercator latLonToMeter: p y lon: p x.					m].	pathInMeter inspect.	quickTileMap component path: pathInMeter</body><body package="QuickMap">restoreSession	quickTileMap component mapZoom: (SavedSession at: 2).	quickTileMap setOrigin: (SavedSession at: 1) negated.	SavedSession size &gt; 2 ifTrue:[currentProxy value: (SavedSession at: 3)]</body><body package="QuickMap">retrieveLighttrapData: user password: pass environment: en strSql: sql		| connection session answer row colTraps |	connection := PostgresSocketConnection new.	connection		username: user;		pass: pass;		envi: en.	connection connect.	session := connection getSession. 	session prepare: sql;		execute.		colTraps := OrderedCollection new.	answer := session answer.	[answer atEnd] whileFalse:			[ 			  row := answer next.			  colTraps add: row]."	1 to: colTraps size do: 	[ :x | colTraps at: x.		row := colTraps at: x.				s := (row at: 2), ' ',(row at: 6) printString, ' ', (row at: 7) printString.				Transcript show: s; cr.	]."	connection disconnect.		      self quickTileMap component refreshLighttrapList: colTraps.   "    self quickTileMap component invalidateNow. "</body><body package="QuickMap">retrieveStationData: user password: pass environment: en strSql: sql		| connection session colStation answer row s results |	connection := PostgresSocketConnection new.	connection		username: user;		pass: pass;		envi: en.	connection connect.	session := connection getSession. 	session prepare: sql;		execute.	      results := OrderedCollection new.	colStation := OrderedCollection new.	answer := session answer.	[answer atEnd] whileFalse:			[ 			  row := answer next.			  colStation add: row].	1 to: colStation size do: 	[ :x | colStation at: x.		row := colStation at: x.				s := (row at: 3) printString, ' ', (row at: 4) printString.		results add: s.		Transcript show: s; cr.	].	connection disconnect.			^results  "    self quickTileMap component refreshStationList: colStation.       self quickTileMap component invalidateNow. "</body><body package="QuickMap">saveSerie	"This stub method was generated by UIDefiner"	| quickTileModel textCollector name filename ws |	quickTileModel := self quickTileMap component.	quickTileModel := quickTileModel model value.	textCollector := quickTileModel textCollector.	name := 'points.text'.	filename := name asFilename.	ws := filename writeStream.	ws isWritable		ifTrue: 			[ws nextPutAll: textCollector value.			ws close]</body><body package="QuickMap">setBrest	| tileSize |	tileSize := 256.	quickTileMap component mapZoom: 12.	quickTileMap setOrigin: ((1996 * tileSize) @ (1416 * tileSize)) negated.</body><body package="QuickMap">setFranceMeteo	| x |"	tileSize := 256."	quickTileMap component mapZoom: 12.		x := -510976 @ -362496.		quickTileMap setOrigin: x."	((1996 * tileSize) @ (1416 * tileSize)) negated."</body><body package="QuickMap">showSerie	"This stub method was generated by UIDefiner"	| quickTileModel textCollector tp qtm | 	qtm := self quickTileMap component.	quickTileModel := qtm model value. 	textCollector := quickTileModel textCollector. 	tp := UITextPoints new.	self laSoucheNom value isEmpty ifTrue:[ tp guessedName: 'Shapes'] ifFalse: [	tp guessedName: self laSoucheNom value. ].	tp open.	tp leTexte value: textCollector value</body><body package="QuickMap">showtrap	"This stub method was generated by UIDefiner"	| quickTileModel longitude latitude myZoom myOLH textCollector name filename ws myText |	quickTileModel := myModel value.	longitude := quickTileModel geoPositionVH value first asNumber.	latitude := quickTileModel geoPositionVH value last asNumber.	myZoom := quickTileModel zoom.	myOLH := OpenLayerHtml				lat: latitude				lon: longitude				zoom: myZoom				urlFileName: 'myosmfile.osm'.	textCollector := quickTileModel textCollector.	myText := textCollector value.	" pour OSM"	OpenLayerHtml testHtmlFileFor: myOLH withOsmText: myText</body><body package="QuickMap">showtrapBao	"This stub method was generated by UIDefiner"	| aOrigin aMapOrigin zoom str |		str := 'Select osm_id, name, lat, lon, way,  ST_YMin(ST_Transform(way,4326)) as lat1,  ST_XMin(ST_Transform(way,4326)) as lon1 from planet_osm_point p inner join planet_osm_nodes n on p.osm_id=n.id where man_made = ''light trap'''.	 		self retrieveLighttrapData: 'osm' password: 'fare&amp;bali'  environment: 'wsn.univ-brest.fr:8080_vietnambao2' strSql: str.		aOrigin := self quickTileMap container container bounds origin.	aMapOrigin := self quickTileMap scrollOffset.	zoom := self quickTileMap component zoom.			self quickTileMap component model value makePixelList: aMapOrigin origin: aOrigin zoom: zoom.</body></methods><methods><class-id>UIQuickMap</class-id> <category>interface opening</category><body package="QuickMap">postOpenWith: aBuilder	"self doConfig"	| button component | 	self leModeDesPoints value: #isPath.	button := aBuilder componentAt: #ActionButton8.	button isNil		ifFalse: 			[component := button component component.			component  isInTransition: true].	button := aBuilder componentAt: #ActionButton7.	button isNil		ifFalse: 			[component := button component component.			component isInTransition: false].</body></methods><methods><class-id>UIQuickMap</class-id> <category>aspects</category><body package="QuickMap">config	^config isNil		ifTrue: 			[config := UIQuickMapConfig new.			config masterWindow: self.			config]		ifFalse: [config]</body><body package="QuickMap">laLatBottom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laLatBottom isNil		ifTrue:			[laLatBottom := String new asValue]		ifFalse:			[laLatBottom]</body><body package="QuickMap">laLatTop	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laLatTop isNil		ifTrue:			[laLatTop := String new asValue]		ifFalse:			[laLatTop]</body><body package="QuickMap">laLonBottom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laLonBottom isNil		ifTrue:			[laLonBottom := String new asValue]		ifFalse:			[laLonBottom]</body><body package="QuickMap">laLonTop	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laLonTop isNil		ifTrue:			[laLonTop := String new asValue]		ifFalse:			[laLonTop]</body><body package="QuickMap">laSoucheNom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laSoucheNom isNil		ifTrue:			[laSoucheNom := String new asValue]		ifFalse:			[laSoucheNom]</body><body package="QuickMap">leDiviseur	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leDiviseur isNil		ifTrue:			[leDiviseur := 2 asValue]		ifFalse:			[leDiviseur]</body><body package="QuickMap">leModeDesPoints	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leModeDesPoints isNil		ifTrue:			[leModeDesPoints := #isPath asValue]		ifFalse:			[leModeDesPoints]</body><body package="QuickMap">mouseLat	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mouseLat isNil		ifTrue:			[mouseLat := String new asValue]		ifFalse:			[mouseLat]</body><body package="QuickMap">mouseLon	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mouseLon isNil		ifTrue:			[mouseLon := String new asValue]		ifFalse:			[mouseLon]</body><body package="QuickMap">pickModelRange	^myModel value pickModelRange</body><body package="QuickMap">satPathDuration	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^satPathDuration isNil		ifTrue:			[satPathDuration := 0 asValue]		ifFalse:			[satPathDuration]</body><body package="QuickMap">sensorsNumber	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^myModel value sensorsNumber isNil		ifTrue:			[myModel value sensorsNumber: 0 asValue]		ifFalse:			[myModel value sensorsNumber]</body></methods><methods><class-id>UIQuickMap</class-id> <category>changing</category><body package="QuickMap">changeDiviseur	| qtm qtc div |	qtm := self quickTileMap component.	qtc := qtm controller.	div := self leDiviseur value .	div &gt;1 ifTrue:  			[ 			qtc model value diviseur: div].</body><body package="QuickMap">changeModePoints	| qtm qtc |	qtm := self quickTileMap component.	qtc := qtm controller.	self leModeDesPoints value = #isPath		ifTrue: 			[qtc pathInProgress: true.			qtc lineInProgress: false.			qtc model value textCollector: nil].	self leModeDesPoints value = #isLine 		ifTrue: 			[qtc pathInProgress: false.			qtc lineInProgress: true.			qtc model value textCollector: nil.			qtc model value lineArray: (Array new: 2).			qtc model value diviseur: self leDiviseur value]</body><body package="QuickMap">changeMouse	| map geoStrngs |	map := self quickTileMap component.	geoStrngs := map model value  geoPositionVH value. 	geoStrngs first isNil ifFalse: [self mouseLon value: geoStrngs first].	geoStrngs last isNil ifFalse: [self mouseLat value: geoStrngs last]</body><body package="QuickMap">changeProxy	| winTitle | 	self quickTileMap component makeActiveProxy: currentProxy value.	winTitle := 'Quick Map - ' , self quickTileMap component proxy class friendlyName.	self builder window label: winTitle.	self quickTileMap component invalidate</body><body package="QuickMap">fetchSatPos	| meter gpr |	gpr := gpredictReader mobileInterface value.	"pixel := gpr pixel."	meter := gpr meter.	"c := Circle center: pixel radius: 10."	"c inspect."	"gaw := GraphicsAttributesWrapper on: c asFiller.	gaw attributes: ColorValue black.	quickTileMap component satellite: gaw."	quickTileMap component addPointMeter: meter.	newUpdate := true	"quickTileMap component pathInPixel add: pixel."	"quickTileMap component invalidateNow"</body><body package="QuickMap">updateMap		"gpr := gpredictReader mobileInterface value.	pixel := gpr pixel.	meter := gpr meter.	c := Circle center: pixel radius: 10."	"c inspect."	"gaw := GraphicsAttributesWrapper on: c asFiller.	gaw attributes: ColorValue black.	quickTileMap component satellite: gaw.	quickTileMap component path add: meter.		quickTileMap component pathInPixel add: pixel."	newUpdate ifTrue: 		[quickTileMap component invalidateNow.		newUpdate := false]</body></methods><methods><class-id>UIQuickMap</class-id> <category>accessing</category><body package="QuickMap">currentProxy	^currentProxy</body><body package="QuickMap">currentProxy: anObject	currentProxy := anObject</body><body package="QuickMap">globalMercator	^globalMercator</body><body package="QuickMap">globalMercator: anObject	globalMercator := anObject</body><body package="QuickMap">googleModel	^googleModel</body><body package="QuickMap">googleModel: anObject	googleModel := anObject</body><body package="QuickMap">gpredictReader	^gpredictReader</body><body package="QuickMap">gpredictReader: anObject	gpredictReader := anObject</body><body package="QuickMap">lastPickCellModel	^lastPickCellModel</body><body package="QuickMap">lastPickCellModel: anObject	lastPickCellModel := anObject</body><body package="QuickMap">quickTileMap	^quickTileMap</body><body package="QuickMap">quickTileMap: anObject	quickTileMap := anObject</body><body package="QuickMap">uiLocation	^uiLocation</body><body package="QuickMap">uiLocation: anObject	uiLocation := anObject</body></methods><methods><class-id>UIQuickMap</class-id> <category>fileIn/Out</category><body package="QuickMap">parseCSVFile: csvFilename	| reader lines connection session sql data id name lat long ele |	reader := CsvReader onFileNamed: csvFilename.	[lines := OrderedCollection new.	[reader atEnd] whileFalse:	     [lines add: reader nextLine.]] 	ensure: [reader close].		connection := PostgresSocketConnection new.connection	username: 'wsn';	pass: 'wsn';	envi: 'opale:5432_pickcelldb0'.connection connect.session := connection getSession. "Drop table if exists"2 to: lines size do: [	:x | (lines at: x).			"Separate data fields"	data := (lines at: x) tokensBasedOn: $;.		id := data at: 1.		name := data at: 2.	lat := data at: 3.	long := data at: 4.	ele := data at: 5.		sql := 'Insert Into Station Values(''',id, ''', $$''',name,'''$$, ',lat,',',long,',',ele,')'.	"	Transcript show: sql; cr. "	"Insert Into Table"	session prepare: sql;		execute;		answer.].connection disconnect.</body><body package="QuickMap">parseSHXFileOrString: shxFilename	| obj |	obj := ShapefileReader readAllObjectsFromShapefile: shxFilename.	quickTileMap component overlay updateObjects: obj</body></methods><methods><class-id>UIQuickMap</class-id> <category>interface closing</category><body package="QuickMap">disconnectAll	(quickTileMap component instVarNamed: 'dicoProxy') do: 			[:p |			p close.			p disconnect]</body><body package="QuickMap">requestForWindowClose	"Save session"	| origin zoom |	origin := quickTileMap scrollOffset.	zoom := quickTileMap component mapZoom.	SavedSession := Array				with: origin				with: zoom				with: currentProxy value.	self disconnectAll.	config isNil ifFalse: [config closeAndUnschedule].	forkDelay isNil ifFalse: [forkDelay terminate].	^true</body><body package="QuickMap">resetAll	(quickTileMap component instVarNamed: 'dicoProxy') do: [:p | p reset]</body></methods><methods><class-id>UIQuickMap</class-id> <category>initialize-release</category><body package="QuickMap">initialize	| origin zoom map scroller |	map := QuickTileMap new.	"globalMercator := GlobalMercator new."	currentProxy := ValueHolder new.	"#QuickTileProxyOSM asValue."	SavedSession isNil		ifTrue: 			["self setBrest."			| tileSize |			tileSize := 256.			origin := (1996 * tileSize) @ (1416 * tileSize).			zoom := 12.			currentProxy value: #QuickTileProxyOSM]		ifFalse: 			["self restoreSession"			origin := SavedSession at: 1.			zoom := SavedSession at: 2.			SavedSession size &gt; 2				ifTrue: [currentProxy value: (SavedSession at: 3)]				ifFalse: [currentProxy value: #QuickTileProxyOSM]].	map getController.	map mapZoom: zoom.	map model value zoom: zoom.	map makeActiveProxy: currentProxy value.	scroller := ScrollWrapper on: map at: origin negated.	quickTileMap := scroller.	"BorderedWrapper on:"	currentProxy onChangeSend: #changeProxy to: self.	newUpdate := false.	myModel := map model.	self leModeDesPoints onChangeSend: #changeModePoints to: self.	self leDiviseur onChangeSend: #changeDiviseur to: self.	myModel value geoPositionVH onChangeSend: #changeMouse to: self.	self pickModelRange value: myModel value pickModel portee</body></methods><methods><class-id>UIQuickMap class</class-id> <category>resources</category><body package="QuickMap">cursorCrossHair	^Cursor crossHair asOpaqueImage</body><body package="QuickMap">cursorOpenHand	^Cursor hand asOpaqueImage</body></methods><methods><class-id>UIQuickMap class</class-id> <category>private</category><body package="QuickMap">buildClosedHandCursor	| c |	c := Cursor new.	c instVarNamed: 'errorCode' put: 0.	c instVarNamed: 'hotSpot' put: 0 @ 0.	c instVarNamed: 'image' put: self cursorHand image.	c instVarNamed: 'mask' put: self cursorHandMask.	c instVarNamed: 'name' put: 'closed hand'.	^c</body><body package="QuickMap">closedHand	^ClosedHandCursor isNil		ifFalse: [ClosedHandCursor]		ifTrue: [ClosedHandCursor := self buildClosedHandCursor]</body><body package="QuickMap">resetConfig	SavedSession := nil.	self initialize</body></methods><methods><class-id>UIQuickMap class</class-id> <category>class initialization</category><body package="QuickMap">initialize	super initialize.	#{UIQuickMap.SatelliteIcon} binding reinitializeValue.	#{UIQuickMap.SatelliteIcon2} binding reinitializeValue.	#{UIQuickMap.SatelliteIcon3} binding reinitializeValue.	SatelliteIcon4 := OpaqueImage figure: self satellite32x32 shape: self satellite32x32mask</body><body package="QuickMap">satelliteIcon	^SatelliteIcon</body><body package="QuickMap">satelliteIcon2	^SatelliteIcon2</body><body package="QuickMap">satelliteIcon3	^SatelliteIcon3</body><body package="QuickMap">satelliteIcon4	^SatelliteIcon4</body></methods><methods><class-id>UIQuickMap class</class-id> <category>interface opening</category><body package="QuickMap">openChoose	self openOn: self new withSpec: #windowSpecChoose</body><body package="QuickMap">openMove	self openOn: self new withSpec: #windowSpecMove</body></methods><methods><class-id>AlgoDis.OpenLayerHtml</class-id> <category>accessing</category><body package="PickCell">lat	^lat</body><body package="PickCell">lat: anObject	lat := anObject</body><body package="PickCell">lon	^lon</body><body package="PickCell">lon: anObject	lon := anObject</body><body package="PickCell">urlFileName	^urlFileName</body><body package="PickCell">urlFileName: anObject	urlFileName := anObject</body><body package="PickCell">zoom	^zoom</body><body package="PickCell">zoom: anObject	zoom := anObject</body></methods><methods><class-id>AlgoDis.OpenLayerHtml</class-id> <category>private</category><body package="PickCell">printFooterOn: aStream	aStream		nextPutAll: '                        format: new OpenLayers.Format.OSM()                    }),                    projection: new OpenLayers.Projection("EPSG:4326")                });                 map.addLayers([layer]);             }        &lt;/script&gt;    &lt;/head&gt;    &lt;body onload="init()"&gt;        &lt;div id="map" class="smallmap"&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;';		cr</body><body package="PickCell">printHeaderOn: aStream	aStream		nextPutAll: '&lt;html&gt;    &lt;head&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="http://openlayers.org/api/OpenLayers.js"&gt;&lt;/script&gt;        &lt;script type="text/javascript"&gt;';		cr</body><body package="PickCell">printLatOn: myStream	myStream nextPutAll: '            var lat='.	self lat printOn: myStream</body><body package="PickCell">printLonOn: myStream	myStream nextPutAll: '            var lon='.	self lon printOn: myStream</body><body package="PickCell">printMapOn: myStream	myStream nextPutAll: '            var map '.</body><body package="PickCell">printMiddleOn: myStream	myStream nextPutAll: '              function init(){                map = new OpenLayers.Map ("map", {                controls:[                    new OpenLayers.Control.Navigation(),                    new OpenLayers.Control.PanZoomBar(),                    new OpenLayers.Control.LayerSwitcher(),                    new OpenLayers.Control.Attribution()],                    maxExtent: new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34),                    maxResolution: 156543.0399,                    numZoomLevels: 19,                    units: ''m'',                    projection: new OpenLayers.Projection("EPSG:900913"),                    displayProjection: new OpenLayers.Projection("EPSG:4326")                } );                                 map.addLayer(new OpenLayers.Layer.OSM());                 var lonLat = new OpenLayers.LonLat(lon, lat).transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913"));                 map.setCenter (lonLat, zoom);                //Initialise the vector layer using OpenLayers.Format.OSM                var layer = new OpenLayers.Layer.Vector("Polygon", {                    strategies: [new OpenLayers.Strategy.Fixed()],                    protocol: new OpenLayers.Protocol.HTTP({'</body><body package="PickCell">printUrlOn: myStream	myStream nextPutAll: '                         url:'.	self urlFileName printOn: myStream</body><body package="PickCell">printZoomOn: myStream	myStream nextPutAll: '            var zoom='.	self zoom printOn: myStream</body><body package="PickCell">printurlFileNameOn: myStream	myStream nextPutAll: '                         url:'.	myStream nextPut: $".	myStream nextPutAll: self urlFileName.	myStream nextPut: $"</body></methods><methods><class-id>AlgoDis.OpenLayerHtml</class-id> <category>printing html</category><body package="PickCell">printHtmlOn: myStream 	self printHeaderOn: myStream.	self printLatOn: myStream.	myStream		nextPut: $;;		cr.	self printLonOn: myStream.	myStream		nextPut: $;;		cr.	self printZoomOn: myStream.	myStream		nextPut: $;;		cr.	self printMapOn: myStream.	myStream		nextPut: $;;		cr.	self printMiddleOn: myStream.	self printurlFileNameOn: myStream.	myStream		nextPut: $,;		cr.	self printFooterOn: myStream.	^myStream contents</body><body package="PickCell">printHtmlOnFileName: aFileName	| fname myStream |	fname := aFileName asFilename.	fname  canBeWritten 		ifTrue: 			[myStream := fname writeStream.			self printHtmlOn: myStream.			myStream close]</body></methods><methods><class-id>AlgoDis.OpenLayerHtml</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	lat := nil.	lon := nil.	zoom := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.OpenLayerHtml class</class-id> <category>testing</category><body package="PickCell">testHtml	" OpenLayerHtml testHtml "	| myOLH myStream |	myOLH := self				lat: 34.070				lon: -118.73				zoom: 15				urlFileName: 'myosmfile.osm'.	myStream := String new writeStream.	myOLH printHtmlOn: myStream.	^myStream contents</body><body package="PickCell">testHtmlFile	" OpenLayerHtml testHtmlFile "	| myOLH |	myOLH := self				lat: 34.070				lon: -118.73				zoom: 15				urlFileName: 'myosmfile.osm'.	myOLH printHtmlOnFileName: 'openLayersTest.html'</body><body package="PickCell">testHtmlFileFor: myOLH	" OpenLayerHtml testHtmlFile "	 		myOLH printHtmlOnFileName: 'openLayersTest.html'</body><body package="PickCell">testHtmlFileFor: myOLH withOsmText: myText	" OpenLayerHtml testHtmlFile "	myOLH printHtmlOnFileName: 'openLayersTest.html'</body><body package="PickCell">testOsm	" OpenLayerHtml testOsm "	| text |text := '&lt;?xml version=''1.0'' encoding=''UTF-8''?&gt;&lt;osm version=''0.6'' generator=''JOSM''&gt;  &lt;bounds minlat=''34.0662408634219'' minlon=''-118.736715316772'' maxlat=''34.0731374116421'' maxlon=''-118.73122215271'' origin=''OpenStreetMap server'' /&gt;  &lt;node id=''358802885'' timestamp=''2009-03-11T06:30:08Z'' user=''yellowbkpk'' visible=''true'' version=''1'' lat=''34.0666735'' lon=''-118.734254''&gt;    &lt;tag k=''gnis:created'' v=''06/14/2000'' /&gt;    &lt;tag k=''gnis:county_id'' v=''037'' /&gt;    &lt;tag k=''name'' v=''Santa Monica Mountains National Recreation Area'' /&gt;    &lt;tag k=''leisure'' v=''park'' /&gt;    &lt;tag k=''gnis:feature_id'' v=''277263'' /&gt;    &lt;tag k=''gnis:state_id'' v=''06'' /&gt;    &lt;tag k=''ele'' v=''243'' /&gt;  &lt;/node&gt;  &lt;node id=''453966480'' timestamp=''2009-08-02T03:36:00Z'' user=''Apo42'' visible=''true'' version=''1'' lat=''34.07234'' lon=''-118.7343501'' /&gt;  &lt;node id=''453966482'' timestamp=''2009-08-02T03:36:01Z'' user=''Apo42'' visible=''true'' version=''1'' lat=''34.0670965'' lon=''-118.7322253'' /&gt;  &lt;node id=''453966143'' timestamp=''2009-08-02T03:35:45Z'' user=''Apo42'' visible=''true'' version=''1'' lat=''34.0724577'' lon=''-118.7364799'' /&gt;  &lt;node id=''453966130'' timestamp=''2009-08-02T03:35:44Z'' user=''Apo42'' visible=''true'' version=''1'' lat=''34.0671122'' lon=''-118.7364725'' /&gt;  &lt;node id=''453966490'' timestamp=''2009-08-02T03:36:02Z'' user=''Apo42'' visible=''true'' version=''1'' lat=''34.0722227'' lon=''-118.7322321'' /&gt;  &lt;way id=''38407529'' timestamp=''2009-08-02T03:37:41Z'' user=''Apo42'' visible=''true'' version=''1''&gt;    &lt;nd ref=''453966480'' /&gt;    &lt;nd ref=''453966490'' /&gt;    &lt;nd ref=''453966482'' /&gt;    &lt;nd ref=''453966130'' /&gt;    &lt;nd ref=''453966143'' /&gt;    &lt;nd ref=''453966480'' /&gt;    &lt;tag k=''park:type'' v=''state_park'' /&gt;    &lt;tag k=''csp:unitcode'' v=''537'' /&gt;    &lt;tag k=''admin_level'' v=''4'' /&gt;    &lt;tag k=''name'' v=''Malibu Creek State Park'' /&gt;    &lt;tag k=''csp:globalid'' v=''{4A422954-089E-407F-A5B3-1E808F830EAA}'' /&gt;    &lt;tag k=''leisure'' v=''park'' /&gt;    &lt;tag k=''attribution'' v=''CASIL CSP_Opbdys072008'' /&gt;    &lt;tag k=''note'' v=''simplified with josm to reduce node #'' /&gt;    &lt;tag k=''boundary'' v=''national_park'' /&gt;  &lt;/way&gt;&lt;/osm&gt;'.^text</body><body package="PickCell">testOsmOn: fileName	" OpenLayerHtml testOsmOn: 'myosmfile.osm'  "	| fname myStream |	fname := fileName asFilename.	fname canBeWritten		ifTrue: 			[myStream := fname writeStream.			myStream nextPutAll: self testOsm .			myStream close]</body></methods><methods><class-id>AlgoDis.OpenLayerHtml class</class-id> <category>instance creation</category><body package="PickCell">lat: lat lon: lon zoom: zoom	| olhm |	olhm := self new.	olhm		lat: lat;		lon: lon;		zoom: zoom.	^olhm</body><body package="PickCell">lat: lat lon: lon zoom: zoom urlFileName: urlFileName	| olhm |	olhm := self new.	olhm		lat: lat;		lon: lon;		zoom: zoom;		urlFileName: urlFileName.	^olhm</body><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>UIKnownUrls</class-id> <category>accessing</category><body package="PickCell">closeVH	^closeVH</body><body package="PickCell">closeVH: anObject	closeVH := anObject</body><body package="PickCell">knownUrl	^knownUrl</body><body package="PickCell">knownUrl: anObject	knownUrl := anObject</body></methods><methods><class-id>UIKnownUrls</class-id> <category>fileIn/Out</category><body package="PickCell">doLoadFile	| fn cancel ku rs newKU line rsLine nom anUrl |	fn := Dialog requestFileName: 'Choose a file' default: '*.txt' version: #old.	cancel := fn isEmpty.	cancel		ifFalse: 			[rs := fn asFilename readStream.			newKU := Dictionary new.			rs isReadable ifFalse: [^Dialog warn: 'cannot read ' , fn].			[rs atEnd] whileFalse: 					[line := rs upTo: Character cr.					line isEmpty						ifFalse: 							[rsLine := line readStream.							nom := rsLine upTo: $-.							rsLine next.							anUrl := rsLine upToEnd.							newKU at: nom put: anUrl]].			ku := KnownMapUrl reset.			ku := KnownMapUrl knownUrls.			newKU keys asSortedCollection do: 					[:key | 					ku at: key put: (newKU at: key)].								self reload]</body><body package="PickCell">doSaveFile	| fn cancel ws ku | 	fn := Dialog requestNewFileName: 'name a file' default: '*.txt'.	cancel := fn isEmpty.	cancel		ifFalse: 			[ws := fn asFilename writeStream.			ws isWritable ifFalse: [^Dialog warn: 'cannot write ' , fn].			ku := KnownMapUrl knownUrls.			ku keys asSortedCollection do: 					[:key |					ws						nextPutAll: key asString;						nextPutAll: '-&gt;'.					ws						nextPutAll: (ku at: key) asString;						cr].			ws close]</body></methods><methods><class-id>UIKnownUrls</class-id> <category>actions</category><body package="PickCell">doAdd	"This stub method was generated by UIDefiner"	| aShortName anUrl | 	aShortName := self leShortName value.	anUrl := self leUrl value.	(aShortName isEmpty not and: [anUrl isEmpty not])		ifTrue: 			[ 			self addShortName: aShortName url: anUrl.			self reload]</body><body package="PickCell">doCancel	"This stub method was generated by UIDefiner"	self knownUrl value: nil.	self closeRequest</body><body package="PickCell">doDelete	"This stub method was generated by UIDefiner"	| selectionIndex noms list |	selectionIndex := self lesNoms selectionIndex.	selectionIndex &gt; 0		ifTrue: 			[noms := self lesNoms list.			noms removeAtIndex: selectionIndex.			list := self laListe list.			list removeAtIndex: selectionIndex.			self lesNoms list: noms. 			self laListe  list: list. 			self save   ]</body><body package="PickCell">doQuit	"This stub method was generated by UIDefiner"	self closeRequest</body><body package="PickCell">doSave	"This stub method was generated by UIDefiner"	| noms |	noms := self lesNoms list.	self lesNoms list: noms</body></methods><methods><class-id>UIKnownUrls</class-id> <category>changes</category><body package="PickCell">changedList	| newKU |	KnownMapUrl reset.	newKU := KnownMapUrl knownUrls.	self lesNoms list with: self laListe list		do: [:eachNom :eachUrl | newKU at: eachNom put: eachUrl].	self reload.	self lesNoms selectionIndex: 0.	self laListe selectionIndex: 0</body><body package="PickCell">changedNom	| selectionIndex shortName |	selectionIndex := self lesNoms selectionIndex.	self laListe selectionIndex: selectionIndex.	selectionIndex &gt; 0		ifTrue: 			[shortName := self lesNoms selection.			url := self laListe list at: selectionIndex.			self leShortName value: shortName.			self leUrl value: url.			self knownUrl value: self getKnownUrl.			self enableSave]		ifFalse: [self disableSave]</body><body package="PickCell">changedUrl	| selectionIndex shortName |	selectionIndex := self laListe selectionIndex.	self lesNoms selectionIndex: selectionIndex.	selectionIndex &gt; 0		ifTrue: 			[shortName := self lesNoms selection.			url := self laListe list at: selectionIndex.			self leShortName value: shortName.			self leUrl value: url.			self knownUrl value: self getKnownUrl.			self enableSave]		ifFalse: [self disableSave]</body><body package="PickCell">disableSave	| saveButton |	saveButton := self builder componentAt: #SaveButton.	saveButton disable</body><body package="PickCell">enableSave	| saveButton |	saveButton := self builder componentAt: #SaveButton.	saveButton enable</body><body package="PickCell">getKnownUrl	^KnownMapUrl url: self leUrl value shortName: self leShortName value</body></methods><methods><class-id>UIKnownUrls</class-id> <category>interface closing</category><body package="PickCell">closeRequest	self closeVH: true asValue.	super closeRequest.</body></methods><methods><class-id>UIKnownUrls</class-id> <category>aspects</category><body package="PickCell">laListe	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^laListe isNil		ifTrue:			[laListe := SelectionInList new]		ifFalse:			[laListe]</body><body package="PickCell">leShortName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leShortName isNil		ifTrue:			[leShortName := String new asValue]		ifFalse:			[leShortName]</body><body package="PickCell">leUrl	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leUrl isNil		ifTrue:			[leUrl := String new asValue]		ifFalse:			[leUrl]</body><body package="PickCell">lesNoms	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lesNoms isNil		ifTrue:			[lesNoms := SelectionInList new]		ifFalse:			[lesNoms]</body></methods><methods><class-id>UIKnownUrls</class-id> <category>private</category><body package="PickCell">addShortName: aShortName url: anUrl	| ku |	(aShortName isEmpty not and: [anUrl isEmpty not])		ifTrue: 			[ku := KnownMapUrl knownUrls.			ku at: aShortName put: anUrl.			self 				reload]</body><body package="PickCell">getUrlSortedList: ku	| shortNames values |	shortNames := ku keys asSortedCollection.	values := shortNames collect: [:name | ku at: name].	^values</body><body package="PickCell">save 	| newKU |	KnownMapUrl reset. 	newKU := KnownMapUrl knownUrls.	self lesNoms list with: self laListe list		do: [:eachNom :eachUrl | newKU at: eachNom put: eachUrl].	self reload.	self lesNoms selectionIndex: 0.	self laListe selectionIndex: 0</body></methods><methods><class-id>UIKnownUrls</class-id> <category>initialize-release</category><body package="PickCell">initialize	| ku |	ku := KnownMapUrl knownUrls.	ku isEmpty		ifFalse: 			[self lesNoms list: ku keys asSortedCollection.			self laListe list: (self getUrlSortedList: ku)].	self lesNoms selectionIndexHolder onChangeSend: #changedNom to: self.	self laListe selectionIndexHolder onChangeSend: #changedUrl to: self.	self knownUrl: nil asValue.	self closeVH: false asValue</body><body package="PickCell">reload	| ku |	ku := KnownMapUrl knownUrls.	ku isEmpty		ifFalse: 			[self lesNoms list: ku keys asSortedCollection.			self laListe list: (self getUrlSortedList: ku)]</body></methods><methods><class-id>UIMapAccess</class-id> <category>actions</category><body package="MapAccess">doMoveEast	self xTile value: self xTile value + 1.	self doUpdateTile</body><body package="MapAccess">doMoveNE	self yTile value: self yTile value - 1.	self xTile value: self xTile value + 1.	self doUpdateTile</body><body package="MapAccess">doMoveNW	self yTile value: self yTile value - 1.	self xTile value: self xTile value - 1.	self doUpdateTile</body><body package="MapAccess">doMoveNorth	self yTile value: self yTile value - 1.	self doUpdateTile</body><body package="MapAccess">doMoveSE	self yTile value: self yTile value + 1.	self xTile value: self xTile value + 1.	self doUpdateTile</body><body package="MapAccess">doMoveSW	self yTile value: self yTile value + 1.	self xTile value: self xTile value - 1.	self doUpdateTile</body><body package="MapAccess">doMoveSouth	self yTile value: self yTile value + 1.	self doUpdateTile</body><body package="MapAccess">doMoveWest	self xTile value: self xTile value - 1.	self doUpdateTile</body><body package="MapAccess">doOpenTileCacheConfig	"This stub method was generated by UIDefiner"	| ui |	ui := UIMapTileCacheConfig new.	"ui dicoChoices value addAll: self mapAccess mapTileCache dicoZoom keys."	ui parent: self.	ui open</body><body package="MapAccess">doQuit	self closeRequest</body><body package="MapAccess">doReset	self zoom retractInterestsFor: self.	self xTile value: self initialXTile.	self yTile value: self initialYTile.	self zoom value: self initialZoom.	self oldZoom: self initialZoom.	validComponent := false.	self zoom onChangeSend: #changeZoom to: self</body><body package="MapAccess">doUpdateTile	validComponent ifFalse: [self updateShapeObjects].	self mapAccess: (self mapAccess				x: self xTile value				y: self yTile value				zoom: self zoom value)</body></methods><methods><class-id>UIMapAccess</class-id> <category>accessing</category><body package="MapAccess">colBat	^colBat</body><body package="MapAccess">colBat: anObject	colBat := anObject</body><body package="MapAccess">mapAccess	^mapAccessVH value</body><body package="MapAccess">mapAccess: aValue	^mapAccessVH value: aValue</body><body package="MapAccess">oldZoom	^oldZoom</body><body package="MapAccess">oldZoom: anObject	oldZoom := anObject</body><body package="MapAccess">tileView	^tileView</body><body package="MapAccess">tileView: anObject	tileView := anObject</body></methods><methods><class-id>UIMapAccess</class-id> <category>aspects</category><body package="MapAccess">echelle	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^echelle isNil		ifTrue:			[echelle := 0 asValue]		ifFalse:			[echelle]</body><body package="MapAccess">latitude	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^latitude isNil		ifTrue:			[latitude := 0 asValue]		ifFalse:			[latitude]</body><body package="MapAccess">longitude	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^longitude isNil		ifTrue:			[longitude := 0 asValue]		ifFalse:			[longitude]</body><body package="MapAccess">xTile	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^xTile isNil		ifTrue:			[xTile := 0 asValue]		ifFalse:			[xTile]</body><body package="MapAccess">yTile	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^yTile isNil		ifTrue:			[yTile := 0 asValue]		ifFalse:			[yTile]</body><body package="MapAccess">zoom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^zoom isNil		ifTrue:			[zoom := 0 asValue]		ifFalse:			[zoom]</body></methods><methods><class-id>UIMapAccess</class-id> <category>changing</category><body package="MapAccess">changeZoom	| actualZoom difference xt yt |	actualZoom := self zoom value.	difference := actualZoom - oldZoom.	difference = 0 ifTrue: [^self].	xt := self xTile value.	yt := self yTile value.	difference &gt; 0		ifTrue: 			["zoom in"			difference timesRepeat: [xt := xt * 2].			difference timesRepeat: [yt := yt * 2]]		ifFalse: 			["zoom out"			difference := difference negated.			difference timesRepeat: [xt := (xt / 2) truncated].			difference timesRepeat: [yt := (yt / 2) truncated]].	self xTile value: xt.	self yTile value: yt.	oldZoom := actualZoom.	validComponent := false</body><body package="MapAccess">mapClic	| clic xclic yclic currentTileDico currentZoom tileX tileY pixelX pixelY metre latlon res mercator metre2 difference |	clic := self mapAccess clicPointVH value.	xclic := clic x.	yclic := clic y.	"On rÃ©cupÃ¨re les coordonnÃ©es du carreau en haut Ã  gauche"	currentTileDico := self mapAccess.	currentZoom := currentTileDico zoom.	currentZoom isNil ifTrue: [^nil].	tileX := currentTileDico xTile.	tileY := currentTileDico yTile.	"upperLeftTile := tileX @ tileY."	"Calcul des coordonnÃ©es en pixel du point cliquÃ©"	pixelX := tileX * 256 + xclic.	pixelY := tileY * 256 + yclic.	"Calcul des coordonnÃ©es en mÃ¨tre du point cliquÃ©"	mercator := GlobalMercator new.	metre := mercator pixelToMeterNew: pixelX @ pixelY zoom: currentZoom.	"metre2 := mercator pixelToMeter: (pixelX + 1) @ pixelY zoom: currentZoom."	"difference := metre2 x - metre x."	"Calcul des coordonnÃ©es WGS84 du point cliquÃ©"	latlon := mercator meterToLatLon: metre.	self longitude value: latlon y.	self latitude value: latlon x .	"Calcul de l'Ã©chelle"	res := mercator resolution: currentTileDico zoom.	res := res * latlon x negated degreesToRadians cos.	self echelle value: res.	"self echelle2 value: difference"</body></methods><methods><class-id>UIMapAccess</class-id> <category>fileIn/Out</category><body package="MapAccess">doOpenShapefile	| shxFilename |	shxFilename := Dialog				requestFileNameWithMessage: 'Browse Shapefile file'				default: '*.shx'				version: #mustBeOld				ifFail: [^nil]				for: nil.	"TimeProfiler profile: [self parseSHXFileOrString: shxFilename]."	self parseSHXFileOrString: shxFilename</body><body package="MapAccess">parseSHXFileOrString: shxFilename	colBat := ShapefileReader readAllObjectsFromShapefile: shxFilename.	self updateShapeObjects</body><body package="MapAccess">updateShapeObjects	colBat isNil		ifFalse: 			[| cp currentZoom |			currentZoom := self zoom value.			cp := CompositePart new.			colBat do: 					[:each |					| sw |					sw := StrokingWrapper on: (each convertWithZoom: currentZoom).					cp addComponent: sw].			self mapAccess component: cp.			validComponent := true]</body></methods><methods><class-id>UIMapAccess</class-id> <category>constants</category><body package="MapAccess">initialXTile	^1996</body><body package="MapAccess">initialYTile	^1416</body><body package="MapAccess">initialZoom	^12</body></methods><methods><class-id>UIMapAccess</class-id> <category>initialize-release</category><body package="MapAccess">initialize	super initialize.	mapAccessVH := MapAccess new asValue.	tileView := MapAccessView new.	tileView model: mapAccessVH.	tileView controller: MapAccessController new.	self xTile value: 0.	self yTile value: 0.	self zoom value: 0.	self oldZoom: 0.	self zoom onChangeSend: #changeZoom to: self.	validComponent := false.	mapAccessVH value clicPointVH onChangeSend: #mapClic to: self.	self doUpdateTile</body></methods><methods><class-id>UIMapAccess</class-id> <category>interface closing</category><body package="MapAccess">requestForWindowClose	^Dialog confirm: 'You are about to close the window!'</body></methods><methods><class-id>QuickTileProxyIndonesia</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string :=super baseWsn, '/osm_indonesia/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>QuickTileProxyIndonesia</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.CellController</class-id> <category>event driven</category><body package="PickCell">getPixelAt: point		| array5 image extent logicalPoint assocArray cell offset cellImage pixel |	array5 := self model value.		image := array5 first.		extent := image extent.		logicalPoint := (point / extent) + 1@1.		assocArray := array5 at: 3.		cell := assocArray detect: [ :elment | elment key = logicalPoint].		offset := point -((point / extent) * extent).		cellImage := cell value cellImage.		pixel := cellImage valueAtPoint:offset.		^pixel</body><body package="PickCell">redButtonPressedEvent: aRedButtonPressedEvent	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	| point pixel csel |	Cursor crossHair show.	self dragInProgress: false.	point := self sensor cursorPointFor: aRedButtonPressedEvent.	self sensor shiftDown		ifTrue: 			[pixel := self view getPixelAt: point.			csel := ColorSelectionDialog new.			csel selection: pixel.			csel open			"self model value cellDisplay selectColorFor: point"]		ifFalse: 			[self sensor ctrlOrCommandDown				ifTrue: 					[origin := point.					dragInProgress := true]				ifFalse: 					[self addPoint: point.					self view invalidate]]</body></methods><methods><class-id>AlgoDis.CellController</class-id> <category>events</category><body package="PickCell">addPoint: aPoint	"Set the cursor when moving in the SketchView.	Add a new point for every mouse movement when drawing is in progress."		| masterController | 	masterController := self masterController.	masterController isNil ifFalse: [ masterController addPoint: aPoint]</body><body package="PickCell">exitEvent: anExitEvent	"Change the cursor shape back to normal.	Also end current stroke in case red button is still being pressed."	Cursor normal show.	self dragInProgress: false</body><body package="PickCell">mouseMovedEvent: aMouseMovedEvent	"Set the cursor when moving in the SketchView.	Add a new point for every mouse movement when drawing is in progress."	| modelArray |	self model value isNil		ifFalse: 			[Cursor crossHair show.			position := self sensor cursorPointFor: aMouseMovedEvent.			modelArray := self model value.			(modelArray at: 4) value: position			"self model value: modelArray"]</body><body package="PickCell">redButtonReleasedEvent: aRedButtonReleasedEvent	"Start drawing a new line when the &lt;Select&gt; button is pressed.	Keep showing the crosshair when pressed."	| point corner pixels |	point := self sensor cursorPointFor: aRedButtonReleasedEvent.	self dragInProgress		ifTrue: 			[corner := point.			dragInProgress := false.			pixels := self view						processRectangle: (Rectangle vertex: self origin vertex: corner).			pixels inspect]</body></methods><methods><class-id>AlgoDis.CellController</class-id> <category>accessing</category><body package="PickCell">dragInProgress	^dragInProgress</body><body package="PickCell">dragInProgress: anObject	dragInProgress := anObject</body><body package="PickCell">masterController	| uiMaster masterLaVue masterController |	self model value isNil ifTrue: [^nil].	uiMaster := self model value last.	uiMaster isNil ifTrue: [^nil].	masterLaVue := uiMaster laVue.	masterController := masterLaVue controller.	^masterController.</body><body package="PickCell">masterModel	| uiMaster masterLaVue masterModel |	self model value isNil ifTrue: [^nil].	uiMaster := self model value last.	uiMaster isNil ifTrue: [^nil].	masterLaVue := uiMaster laVue.	masterModel := masterLaVue model.	^masterModel</body><body package="PickCell">optionKey	^optionKey</body><body package="PickCell">optionKey: anObject	optionKey := anObject</body><body package="PickCell">origin	^origin</body><body package="PickCell">origin: anObject	origin := anObject</body></methods><methods><class-id>AlgoDis.CellController</class-id> <category>initialize-release</category><body package="PickCell">initialize  dragInProgress := false.</body></methods><methods><class-id>AlgoDis.PickCellView</class-id> <category>accessing</category><body package="PickCell">image	^image</body><body package="PickCell">image: anObject	image := anObject</body></methods><methods><class-id>AlgoDis.PickCellView</class-id> <category>displaying</category><body package="PickCell">displayCoverCells: coverCells on: aGC	| cellImage position center gaw ga cell name color text style bounds cache mergedColor cacheGC img1 cv3 red pixel rootPoint diagonale length length2 level height width doLabel |	rootPoint := self rootPointIn: coverCells.	height := self model value cellArray size.	width := self model value cellArray first size.	doLabel := self model value displayModeDictionary at: #displayLabel.	diagonale := width @ height.	length := (diagonale x squared + diagonale y squared) sqrt rounded.	coverCells keysAndValuesDo: 			[:posCell :arrayWithCell |			cell := arrayWithCell at: 5.			name := arrayWithCell at: 6.			text := name asComposedText.			style := TextAttributes styleNamed: #small.			text textStyle: style.			cellImage := cell cellImage.			position := cell position.			rootPoint isNil				ifTrue: [level := 0.1]				ifFalse: 					[diagonale := posCell - rootPoint.					length2 := (diagonale x squared + diagonale y squared) sqrt rounded.					level := (length - length2) squared / length squared.					level := level / 3].			red := ColorValue red.			bounds := cellImage bounds.			cache := Pixmap extent: bounds extent.			cacheGC := cache graphicsContext.			img1 := cacheGC medium asImage.			img1 palette: cellImage palette copy.			cellImage pixelsDo: 					[:x :y |					pixel := cellImage atPoint: x @ y.					color := cellImage palette at: pixel.					"rootPoint = posCell ifTrue: [level := 0.2] ifFalse: [level := 0.1]."					mergedColor := color blendWith: red weight: level.					cv3 := cellImage palette indexOfPaintNearest: mergedColor.	"mergedColor."					img1 valueAtPoint: x @ y put: (cellImage palette at: cv3)].			center := position + (2 @ (cellImage bounds height / 2)).			gaw := GraphicsAttributesWrapper on: text.			name last = $R				ifTrue: [color := ColorValue red]				ifFalse: [color := ColorValue blue].			ga := GraphicsAttributes new paint: color.			gaw attributes: ga.			img1 displayOn: aGC at: position.			doLabel ifTrue: [gaw displayOn: aGC at: center]]</body><body package="PickCell">displayCoverTextCells: coverCells on: aGC	| cellImage position center gaw ga cell name color text box width style |	coverCells keysAndValuesDo: 			[:posCell :arrayWithCell | 			cell := arrayWithCell at: 5.			name := arrayWithCell at: 6.			text := name asComposedText.			style :=  (TextAttributes styleNamed: #small).			text textStyle: style.			cellImage := cell cellImage.			position := cell position.			center := position + ( 2 @ (cellImage bounds height  / 2)).			box := text bounds.			width := box width.  			gaw := GraphicsAttributesWrapper on:text.			name last = $R				ifTrue: [color := ColorValue red]				ifFalse: [color := ColorValue blue].			ga := GraphicsAttributes new paint: color.			gaw attributes: ga.			cellImage displayOn: aGC at: position.			gaw displayOn: aGC at: center]</body><body package="PickCell">displayGridOn: aGC	| gaw grid bounds yPos ls xPos |	grid := self model value grid.	image := self model value cellDisplay image.	image isNil		ifFalse: 			[bounds := image bounds.			yPos := 0.			0 to: 1 + (bounds height / grid y)				do: 					[:n |					ls := LineSegment from: 0 @ yPos to: bounds width @ yPos.					gaw := GraphicsAttributesWrapper on: ls asStroker.					gaw attributes: (GraphicsAttributes new paint: ColorValue red).					gaw displayOn: aGC.					yPos := yPos + grid y].			xPos := 0.			0 to: 1 + (bounds width / grid x)				do: 					[:n |					ls := LineSegment from: xPos @ 0 to: xPos @ bounds height.					gaw := GraphicsAttributesWrapper on: ls asStroker.					gaw attributes: (GraphicsAttributes new paint: ColorValue blue).					gaw displayOn: aGC.					xPos := xPos + grid x]]</body><body package="PickCell">displayOn: myGC	| graph gaw coverCells displayDico winds bounds cache cacheGC img1 |	displayDico := self model value displayModeDictionary.	bounds := myGC medium bounds.	cache := Pixmap extent: bounds extent.	cacheGC := cache graphicsContext.	self image isNil		ifFalse: 			[(displayDico at: #displayImage) ifTrue: [self image displayOn: cacheGC]].	(displayDico at: #displayGrid) ifTrue: [self displayGridOn: cacheGC].	coverCells := self model value highLightCells.	coverCells isNil		ifFalse: 			[(displayDico at: #displayCoverCells)				ifTrue: [self displayCoverCells: coverCells on: cacheGC]].	graph := self model value lastGraph.	graph isNil		ifFalse: [(displayDico at: #displayGraph) ifTrue: [graph displayOn: cacheGC]].	winds := self model value windArray.	winds isNil		ifFalse: 			[(displayDico at: #displayWinds)				ifTrue: [self displayWinds: winds on: cacheGC]].	self model value zones isNil		ifFalse: 			[(displayDico at: #displayZones)				ifTrue: 					[self model value zones do: 							[:rect |							gaw := GraphicsAttributesWrapper on: rect asStroker.							gaw attributes: (GraphicsAttributes new paint: ColorValue yellow).							gaw displayOn: cacheGC]]].	img1 := cacheGC medium asImage.	img1 displayOn: myGC</body><body package="PickCell">displayOnSafe: aGC	| graph gaw coverCells displayDico winds |	displayDico := self model value displayModeDictionary.	self image isNil		ifFalse: [(displayDico at: #displayImage) ifTrue: [self image displayOn: aGC]].	(displayDico at: #displayGrid) ifTrue: [self displayGridOn: aGC].	graph := self model value lastGraph.	graph isNil		ifFalse: [(displayDico at: #displayGraph) ifTrue: [graph displayOn: aGC]].	coverCells := self model value highLightCells.	coverCells isNil		ifFalse: 			[(displayDico at: #displayCoverCells)				ifTrue: [self displayCoverCells: coverCells on: aGC]].	winds := self model value windArray.	winds isNil		ifFalse: 			[(displayDico at: #displayWinds) ifTrue: [self displayWinds: winds on: aGC]].	self model value zones isNil		ifFalse: 			[(displayDico at: #displayZones)				ifTrue: 					[self model value zones do: 							[:rect |							gaw := GraphicsAttributesWrapper on: rect asStroker.							gaw attributes: (GraphicsAttributes new paint: ColorValue yellow).							gaw displayOn: aGC]]]</body><body package="PickCell">displayTextCoverCells: coverCells on: aGC	| cellImage position center gaw ga cell name color text box width style |	coverCells keysAndValuesDo: 			[:posCell :arrayWithCell | 			cell := arrayWithCell at: 5.			name := arrayWithCell at: 6.			text := name asComposedText.			style :=  (TextAttributes styleNamed: #small).			text textStyle: style.			cellImage := cell cellImage.			position := cell position.			center := position + ( 2 @ (cellImage bounds height  / 2)).			box := text bounds.			width := box width.  			gaw := GraphicsAttributesWrapper on:text.			name last = $R				ifTrue: [color := ColorValue red]				ifFalse: [color := ColorValue blue].			ga := GraphicsAttributes new paint: color.			gaw attributes: ga.			cellImage displayOn: aGC at: position.			gaw displayOn: aGC at: center]</body><body package="PickCell">displayWinds: winds on: aGC	| gaw grid bounds ls rs geopos uwind vwind processName xStart pos yStart xStop yStop ga scale |	grid := self model value grid.	winds isEmpty ifTrue: [^nil].	bounds := image bounds.	scale := 4.	winds do: 			[:pointInWinds |			rs := pointInWinds readStream.			pos := rs next.			geopos := rs next.			uwind := rs next * scale.			vwind := rs next * scale.			processName := rs next.			(uwind &gt; 1000 or: [vwind &gt; 1000])				ifFalse: 					[xStart := (pos x - 1) * grid x + 1.					yStart := (pos y - 1) * grid y + 1.					xStop := (xStart + uwind) rounded.					yStop := (yStart + vwind) rounded.					ls := LineSegment from: xStart @ yStart to: xStop @ yStop.					gaw := GraphicsAttributesWrapper on: ls asStroker.					ga := (GraphicsAttributes new)								paint: ColorValue yellow;								lineWidth: 2.					gaw attributes: ga.					gaw displayOn: aGC]]</body><body package="PickCell">getCellFromGrid	| grid bounds yPos xPos nbLines nbCol array cell newImage linePlus1 colPlus1 ceiling floor thisGrid |	grid := self model value grid.	self image isNil ifTrue: [^false].	bounds := self image bounds.	nbLines := ((1 + bounds height) / grid y) truncated.	linePlus1 := (1 + bounds height) \\ grid y &gt; 0.	" remove this to avoid right and bottom margin"	linePlus1		ifTrue: 			["nbLines := nbLines + 1"			nil].	nbCol := ((1 + bounds width) / grid x) truncated.	colPlus1 := (1 + bounds height) \\ grid y &gt; 0.	" remove this to avoid right and bottom margin"	colPlus1		ifTrue: 			["nbCol := nbCol + 1"			nil].	array := (Array new: nbLines) collect: [:x | Array new: nbCol].	yPos := 0. 	ceiling := grid ceiling.	floor := grid truncated.	0 to: nbLines - 1		do: 			[:hor |			| gridChoice |			gridChoice := hor even.			xPos := 0.			0 to: nbCol - 1				do: 					[:vert |					gridChoice ifTrue: [thisGrid := ceiling] ifFalse: [thisGrid := floor].					gridChoice := gridChoice not.					"newImage := Image								extent: thisGrid								depth: image depth								palette: image palette copy."					newImage := Image								extent: thisGrid								depth: image depth								bitsPerPixel: 32								palette: image palette copy.					cell := newImage								copy: (0 @ 0 extent: thisGrid)								from: xPos @ yPos								in: image								rule: RasterOp paint.					(array at: hor + 1) at: vert + 1 put: cell.					xPos := xPos + thisGrid x].			yPos := yPos + thisGrid y].	self model value cellArray: array.	^self model value buildCellArrayModel</body><body package="PickCell">getCellFromGridWithMargin	| grid bounds yPos xPos nbLines nbCol array cell newImage linePlus1 colPlus1 ceiling floor thisGrid |	grid := self model value grid.	self image isNil ifTrue: [^false].	bounds := self image bounds.	nbLines := ((1 + bounds height) / grid y) truncated.	linePlus1 := (1 + bounds height) \\ grid y &gt; 0.	" remove this to avoid right and bottom margin"	linePlus1 ifTrue: [nbLines := nbLines + 1].	nbCol := ((1 + bounds width) / grid x) truncated.	colPlus1 := (1 + bounds height) \\ grid y &gt; 0.	colPlus1 ifTrue: [nbCol := nbCol + 1].	array := (Array new: nbLines) collect: [:x | Array new: nbCol].	yPos := 0.	"self halt."	ceiling := grid ceiling.	floor := grid truncated.	0 to: nbLines - 1		do: 			[:hor |			| gridChoice |			gridChoice := hor even.			xPos := 0.			0 to: nbCol - 1				do: 					[:vert |					gridChoice ifTrue: [thisGrid := ceiling] ifFalse: [thisGrid := floor].					gridChoice := gridChoice not.					"newImage := Image								extent: thisGrid								depth: image depth								palette: image palette copy."					newImage := Image								extent: thisGrid								depth: image depth								bitsPerPixel: 32								palette: image palette copy.					cell := newImage								copy: (0 @ 0 extent: thisGrid)								from: xPos @ yPos								in: image								rule: RasterOp paint.					(array at: hor + 1) at: vert + 1 put: cell.					xPos := xPos + thisGrid x].			yPos := yPos + thisGrid y].	self model value cellArray: array.	^self model value buildCellArrayModel</body><body package="PickCell">rootPointIn: coverCells	| name |	coverCells keysAndValuesDo: 			[:pos :arrayWithCell | 			name := arrayWithCell at: 6.			name last = $R ifTrue: [^pos]].	^nil</body><body package="PickCell">selectColorFor: point	| pixel |	self halt.	pixel := self image valueAtPoint: point.	self model value writeColor: pixel</body></methods><methods><class-id>AlgoDis.PickCellView</class-id> <category>As yet unclassified</category><body package="PickCell">getCellFromGrid2	| grid bounds yPos xPos nbLines nbCol array linePlus1 colPlus1 image32 pixel |	grid := self model value grid.	self image isNil ifTrue: [^false].	bounds := self image bounds.	nbLines := ((1 + bounds height) / grid y) truncated.	linePlus1 := (1 + bounds height) \\ grid y &gt; 0.	linePlus1 ifTrue: [nbLines := nbLines + 1].	nbCol := ((1 + bounds width) / grid x) truncated.	colPlus1 := (1 + bounds height) \\ grid y &gt; 0.	colPlus1 ifTrue: [nbCol := nbCol + 1].	array := (Array new: nbLines) collect: [:x | Array new: nbCol].	yPos := 0.	0 to: nbLines - 1		do: 			[:hor |			xPos := 0.			0 to: nbCol - 1				do: 					[:vert |					image32 := Image								extent: self image extent								depth: self image depth								palette: self image palette copy.					image pixelsDo: 							[:x :y |							pixel := image valueAtPoint: x @ y.							image32 valueAtPoint: x @ y put: pixel].					(array at: hor + 1) at: vert + 1 put: image32.					xPos := xPos + grid x].			yPos := yPos + grid y].	self model value cellArray: array.	^self model value buildCellArrayModel</body></methods><methods><class-id>AlgoDis.PickCellView</class-id> <category>controller accessing</category><body package="PickCell">defaultControllerClass		^PickCellController</body></methods><methods><class-id>UITextPoints</class-id> <category>accessing</category><body package="PickCell">guessedName	| pm |	pm := self pickModel.	pm isNil ifTrue: [^self guessedName: 'cellSystemNoName'].	guessedName := pm guessedName.	guessedName isNil ifTrue: [^self guessedName: 'cellSystemNoName'].	^guessedName</body><body package="PickCell">guessedName: anObject	guessedName := anObject.	^guessedName</body><body package="PickCell">guessedNameFromString: aString	| index string |	index := aString lastIndexOf: $..	index &gt; 1		ifTrue: [string := aString copyFrom: 1 to: index-1]		ifFalse: [string := aString].	guessedName := string.	^string</body><body package="PickCell">pickModel	^pickModel</body><body package="PickCell">pickModel: anObject	pickModel := anObject</body></methods><methods><class-id>UITextPoints</class-id> <category>actions</category><body package="PickCell">doAnalyze	| rs header cellPos line ls char tmpStream latitude longitude elevation numbers name |	rs := self leTexte value readStream.	" discard 1st line"	header := rs upTo: Character cr.	" read line by line"	cellPos := OrderedCollection new.	[rs atEnd] whileFalse: 			[line := rs upTo: Character cr.			ls := line readStream.			char := ls next.			char := ls next.			[char isSeparator] whileTrue: [char := ls next].			tmpStream := String new writeStream.			[char isSeparator] whileFalse: 					[tmpStream nextPut: char.					char := ls next].			tmpStream nextPut: $d.			latitude := tmpStream contents asNumber.			[char isSeparator] whileTrue: [char := ls next].			tmpStream := String new writeStream.			[char isSeparator] whileFalse: 					[tmpStream nextPut: char.					char := ls next].			tmpStream nextPut: $d.			longitude := tmpStream contents asNumber.			[char isSeparator] whileTrue: [char := ls next].			tmpStream := String new writeStream.			[char isSeparator] whileFalse: 					[tmpStream nextPut: char.					char := ls next].			tmpStream nextPut: char.			elevation := tmpStream contents asNumber.			[char isSeparator] whileTrue: [char := ls next].			tmpStream := String new writeStream.			[ls atEnd] whileFalse: 					[tmpStream nextPut: char.					char := ls next].			tmpStream nextPut: char.			name := tmpStream contents.			numbers := Array						with: latitude						with: longitude						with: elevation						with: name.			cellPos add: numbers].	self pickModel isNil		ifFalse: 			[self pickModel processElevations: cellPos.			self pickModel guessedName: self guessedName].	^cellPos</body><body package="PickCell">doAnalyzeCover	| rs header cellPos line ls latitude longitude elevation numbers name |	rs := self leTexte value readStream.	" discard 1st line"	header := rs upTo: Character cr.	" read line by line"	cellPos := OrderedCollection new.	[rs atEnd] whileFalse: 			[line := rs upTo: Character cr.			ls := line readStream.			longitude := ls upTo: $,.			longitude := longitude reject: [:ch | ch = $ ].			longitude := (longitude , 'd') asNumber.			latitude := ls upTo: $,.			latitude := latitude reject: [:ch | ch = $ ].			latitude := (latitude , 'd') asNumber.			elevation := (ls upTo: $,) asNumber.			name := ls upToEnd.			name := name reject: [:ch | ch = $ ].			"name last = $R ifFalse: [name := name copyFrom: 1 to: name size - 1]."			numbers := Array						with: latitude						with: longitude						with: elevation						with: name.			cellPos add: numbers].	self pickModel isNil		ifFalse: 			[self pickModel processElevations: cellPos.			self pickModel guessedName: self guessedName].	^cellPos</body><body package="PickCell">doAnalyzeWind	| rs header cellPos line numbers name scanner tokens ws ls |	rs := self leTexte value readStream.	" discard 1st line"	header := rs upTo: Character cr.	" read line by line"	cellPos := OrderedCollection new.	[rs atEnd] whileFalse: 			[line := rs upTo: Character cr.			scanner := Scanner new.			tokens := scanner scanTokens: line.			ls  := tokens readStream.						ws := Array new writeStream.			ws nextPut:  ls next asDouble.			ws nextPut:  ls next asDouble.			ws nextPut:  ls next.			ws nextPut:  ls next.			ws nextPut: ls next.			name := ls next asString.			ls atEnd ifFalse: [    name := name, ls next asString].			ws nextPut: name.			numbers := ws contents.			cellPos add: numbers].	self pickModel isNil		ifFalse: 			[self pickModel processWinds: cellPos.			self pickModel guessedName: self guessedName].	^cellPos</body><body package="PickCell">doGetBackForURL	"This stub method was generated by UIDefiner"	"Read a GPS coordinates file, and send a request to GPSVisualizer to retrieve elevation data"	"Select all this code (ctrl+A) and do it (ctrl + D)"	"me"	| rs me1 me2 me3 me4 me5 me6 me7 me8 me9 hr resp htmlText fullFilename found pattern url htmlText2 name texte line ws |	rs := self leTexte value readStream.	name := 'points.text'.	"Reading file with GPS coordinates"	me1 := Net.MimeEntity new.	me1		contentDisposition: 'form-data; name="uploaded_file_1"; filename="' , name				, '"'.	me1 contentType: 'text/plain'.	me1 contents: rs.	rs close.	"Other fields that may be sent"	me2 := Net.MimeEntity new.	me2 contentDisposition: 'form-data; name="remote_data"'.	me3 := Net.MimeEntity new.	me3 contentDisposition: 'form-data; name="submitted"'.	me3 body: ((Net.SimpleBody new)				source: 'Convert &amp; add elevation' readStream;				yourself).	me4 := Net.MimeEntity new.	me4 contentDisposition: 'form-data; name="convert_format"'.	me4 body: ((Net.SimpleBody new)				source: 'text' readStream;				yourself).	me5 := Net.MimeEntity new.	me5 contentDisposition: 'form-data; name="units"'.	me5 body: ((Net.SimpleBody new)				source: 'metric' readStream;				yourself).	me6 := Net.MimeEntity new.	me6 contentDisposition: 'form-data; name="convert_delimiter"'.	me6 body: ((Net.SimpleBody new)				source: 'tab' readStream;				yourself).	me7 := Net.MimeEntity new.	me7 contentDisposition: 'form-data; name="add_elevation"'.	me7 body: ((Net.SimpleBody new)				source: 'auto' readStream;				yourself).	me8 := Net.MimeEntity new.	me8 contentDisposition: 'form-data; name="profile_x"'.	me8 body: ((Net.SimpleBody new)				source: 'distance' readStream;				yourself).	me9 := Net.MimeEntity new.	me9 contentDisposition: 'form-data; name="profile_y"'.	me9 body: ((Net.SimpleBody new)				source: 'altitude' readStream;				yourself).	"Request POST multipart/form-data"	hr := Net.HttpRequest				post: 'Http://www.gpsvisualizer.com/convert?output_elevation'.	hr		addPart: me1;		addPart: me2;		addPart: me3;		addPart: me4;		addPart: me5;		addPart: me6;		addPart: me7;		addPart: me8;		addPart: me9.	hr referer: 'Http://www.gpsvisualizer.com/elevation'.	hr		userAgent: 'Mozilla/5.0 (X11; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0'.	hr contentType: 'multipart/form-data'.	resp := hr execute.	"Reading results"	htmlText := resp value byteSource contents asString.	"Regexp matcher to catch filename to download"	rs := htmlText readStream.	pattern := '/download/convert/'.	1 to: htmlText size - pattern size		do: 			[:pos |			found := pattern = (htmlText copyFrom: pos to: pos + pattern size - 1).			found				ifTrue: 					[rs := (htmlText copyFrom: pos to: pos + 100) readStream.					rs						upTo: $/;						upTo: $/;						upTo: $/.					url := rs upTo: $".					Transcript						show: pos printString , '  ' , url;						cr;						flush]].	fullFilename := '/download/convert/' , url.	Transcript		show: 'Http://www.gpsvisualizer.com' , fullFilename;		cr.	"New request to read the file"	hr := Net.HttpRequest get: 'Http://www.gpsvisualizer.com' , fullFilename.	hr referer: 'Http://www.gpsvisualizer.com/convert?elevation'.	hr		userAgent: 'Mozilla/5.0 (X11; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0'.	resp := hr execute. 	htmlText2 := resp contents asText.	rs := htmlText2 readStream.	"line := rs upTo: Character lf."	ws := Text new writeStream.	[rs atEnd] whileFalse: [ line := rs upTo: Character lf. line isEmpty  ifFalse:  [   ws nextPutAll: line. ws cr.] ].	texte := ws contents.	self leTexte value: texte. 	self doAnalyze.	^texte</body><body package="PickCell">doLoad	| name filename rs | 	name := self pickModel guessedDirectory.	name := name , '/'  , self guessedName, '-elev.txt'.	name := Dialog requestFileName: 'name of file ?'  default: name for: nil.	name isEmpty		ifFalse: 			[filename := name asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[self leTexte value: rs contents.					rs close]]</body><body package="PickCell">doLoadFile: filenamePattern	| fn rs |	filenamePattern isEmpty		ifFalse: 			[fn := filenamePattern asFilename.			rs := fn readStream.			rs isReadable				ifTrue: 					[self leTexte value: rs contents.					rs close]]</body><body package="PickCell">doParseCoverage	| aName filename rs nodeid time lat lon rssi alt latString lonString cellPos values |	cellPos := OrderedCollection new.	aName := 'trackGPSPoints.txt'.	aName isEmpty		ifFalse: 			[filename := aName asFilename.			rs := filename readStream.			rs isReadable				ifTrue: 					[[rs atEnd] whileFalse: 							[nodeid := rs upTo: $,.							nodeid first = Character cr								ifTrue: [nodeid := nodeid copyFrom: 2 to: nodeid size].							time := rs upTo: $,.							latString := rs upTo: $,.							lat := self parseLat: latString.							lonString := rs upTo: $,.							lon := self parseLon: lonString.							alt := (rs upTo: $,) asNumber.							rssi := rs upTo: Character cr.							values := Array										with: lat										with: lon										with: alt										with: rssi.							cellPos add: values]].			rs close].	self pickModel isNil		ifFalse: 			[self pickModel processElevations: cellPos.			self pickModel guessedName: self guessedName].	^cellPos</body><body package="PickCell">doSave	| name filename ws |	name := Dialog				requestFileName: 'save on file'				default: self guessedDirectory, '/', self guessedName , '-elev.txt'				for: nil.	name isEmpty		ifFalse: 			[self guessedNameFromString: name.			filename := name asFilename.			ws := filename writeStream.			ws isWritable				ifTrue: 					[ws nextPutAll: self leTexte value.					ws close]]</body><body package="PickCell">doSave: aString	| name filename ws |	name := aString , '.txt'.	name isEmpty		ifFalse: 			[filename := name asFilename.			ws := filename writeStream.			ws isWritable				ifTrue: 					[ws nextPutAll: self leTexte value.					ws close].			self guessedName: aString].	^aString</body><body package="PickCell">doSaveDefault	| name filename ws |	name := 'points.text'.	name isEmpty		ifFalse: 			[filename := name asFilename.			ws := filename writeStream.			ws isWritable				ifTrue: 					[ws nextPutAll: self leTexte value.					ws close]]</body><body package="PickCell">doSaveShapeFile	| name ws rs firstLine lat lon line1 gName |	gName := guessedName.	gName isEmpty ifTrue: [gName := 'shapes'].	name := Dialog				requestFileName: 'save on shape file'				default: self shapeDirectory , '/' , gName , '-shp.txt'				for: nil.	name isNil ifTrue: [name := 'testpolygon'].	false		ifFalse: 			[UnixProcess cshOne: 'shpcreate ' , name , ' polygon'.			ws := String new writeStream.			ws nextPutAll: 'shpadd ' , name , ' '.			rs := self leTexte value readStream.			rs upTo: Character cr.			firstLine := true.			[rs atEnd] whileFalse: 					[lat := (rs upTo: $,) asNumber.					lon := (rs upTo: Character cr) asNumber.					firstLine						ifTrue: 							[line1 := Array with: lat with: lon.							firstLine := false].					lon printOn: ws.					ws space.					lat printOn: ws.					ws space].			line1 last printOn: ws.			ws space.			line1 first printOn: ws.			ws space.			UnixProcess cshOne: ws contents.			ws close]</body><body package="PickCell">doSaveURL	"This stub method was generated by UIDefiner" 		self doGetBackForURL</body><body package="PickCell">doSaveURLOld	"This stub method was generated by UIDefiner"	| name filename ws urlName result |	name := 'points.text'.	self doSave: name.	urlName := 'ftp://ftpremote:wputamd64@wsn.univ-brest.fr/public/' , name.	filename := name asFilename.	ws := filename writeStream.	ws isWritable		ifTrue: 			[ws nextPutAll: self leTexte value.			ws close].	result := UnixProcess cshOne: 'wput -u ' , name , ' ' , urlName.	Dialog warn: result.		self doGetBackForURL: name.</body><body package="PickCell">parseLat: aString	| ls n ch entier decimal number north |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	north := aString last = $N.	north ifFalse: [number := number negated].	^number asDouble</body><body package="PickCell">parseLon: aString	| ls n ch entier decimal number west |	ls := aString readStream.	n := 0.	[ls atEnd] whileFalse: 			[ch := ls next.			ch = $. ifFalse: [ch isDigit ifTrue: [n := n * 10 + ch digitValue]]].	entier := (n / 1000000) truncated.	decimal := ((n / 10000) - (entier * 100)) / 60.	number := (entier + decimal) asDouble.	west := aString last = $W.	west ifTrue: [number := number negated].	^number asDouble</body><body package="PickCell">storeInDB	| rs header cellPos line ls  numbers name array1 rss |	rs := self leTexte value readStream.	" discard 1st line"	header := rs upTo: Character cr.	" read line by line"	cellPos := OrderedCollection new.	[rs atEnd] whileFalse: 			[line := rs upTo: Character cr. 			array1 := Scanner new scanTokens: line.			rss := array1 readStream.			rss next.			"name last = $R ifFalse: [name := name copyFrom: 1 to: name size - 1]."			numbers := Array						with: rss next						with: rss next						with: rss next						with: rss next.			cellPos add: numbers].	self pickModel isNil		ifFalse: 			[ 			self pickModel guessedName: self guessedName].	^cellPos</body></methods><methods><class-id>UITextPoints</class-id> <category>interface opening</category><body package="PickCell">postOpenWith: spec	self showCellSystemName</body><body package="PickCell">showCellSystemName	| pm name winTitle |	pm := self pickModel.	pm isNil		ifFalse: 			[name := pm guessedName.			name isNil ifTrue: [name := 'no name'].			winTitle := 'Points editor - ' , name.			self builder window label: winTitle]</body></methods><methods><class-id>UITextPoints</class-id> <category>parsing</category><body package="PickCell">elevationName	^self guessedName , '-elev.txt'</body><body package="PickCell">guessedDirectory	| dd pm |	pm := self pickModel.	pm isNil		ifTrue: 			[dd := Filename defaultDirectory.			dd := dd asString  , '/Generated'.			dd asFilename ensureDirectory.			^dd]		ifFalse: [^pm guessedDirectory]</body><body package="PickCell">noElevationName^	self guessedName , '.txt'</body><body package="PickCell">shapeDirectory	| dd pm |	pm := self pickModel.	pm isNil		ifTrue: 			[dd := Filename defaultDirectory.			dd := dd asString  , '/Shapes'.			dd asFilename ensureDirectory.			^dd]		ifFalse: [^pm guessedDirectory]</body></methods><methods><class-id>UITextPoints</class-id> <category>aspects</category><body package="PickCell">leTexte	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leTexte isNil		ifTrue:			[leTexte := String new asValue]		ifFalse:			[leTexte]</body></methods><methods><class-id>USBSerial</class-id> <category>accessing</category><body package="PickCell">bdrate	^bdrate</body><body package="PickCell">bdrate: anObject	bdrate := anObject</body><body package="PickCell">cportNr	^cportNr</body><body package="PickCell">cportNr: anObject	cportNr := anObject</body><body package="PickCell">mode	^mode</body><body package="PickCell">mode: anObject	mode := anObject</body></methods><methods><class-id>USBSerial</class-id> <category>initialize-release</category><body package="PickCell">initialize		super initialize.</body><body package="PickCell">initialize1		super initialize. 	self mode: self myMode.	self cportNr: 25.	self bdrate: 115200</body></methods><methods><class-id>USBSerial</class-id> <category>opening</category><body package="PickCell">close	"        unsigned char character[size +1];        int cport = 27;        int bdrate = 9600;        int numChar = 0;"	| result |	result := self RS232_CloseComport: self cportNr.	result &gt; 0 ifTrue: [self error: 'ComPort']</body><body package="PickCell">open	"        unsigned char character[size +1];        int cport = 27;        int bdrate = 9600;        int numChar = 0;"	| result  |	bdrate := 38400.	result := self				RS232_OpenComport: self cportNr				with: bdrate				with: self mode.	result &gt; 0 ifTrue: [self error: 'ComPort']</body></methods><methods><class-id>USBSerial class</class-id> <category>testing</category><body package="PickCell">getGPSDataTemp	| usb bufferPointer numChar ws buffer portOk points |	self unloadLibraries.	usb := self new.	usb initialize.	points := OrderedCollection new.	usb RS232_CloseComport: 27.	Transcript		show: Time now printString;		cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 38400.	usb		flushBuf: bufferPointer		with: 4095		with: 27		with: 38400.	portOk = 0		ifFalse: 			[Transcript				show: 'open error';				cr]		ifTrue: 			[1 timesRepeat: 					["bufferPointer := CIntegerType char gcMalloc: 4096."					numChar := usb								readBuf: bufferPointer								with: 4095								with: 27								with: 38400.					ws := String new writeStream.					0 to: numChar - 1						do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].					Transcript						show: numChar printString;						tab;						show: ws contents.					points add: (TrackPoint from: ws contents).					(Delay forSeconds: 1) wait].			usb RS232_CloseComport: 27].	^points</body><body package="PickCell">setupSample: port	| usb bufferPointer buffer portOk |	self unloadLibraries.	usb := self new.	usb initialize.	usb RS232_CloseComport: port.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 38400.	usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 38400.	portOk = 0 ifFalse: [^nil] ifTrue: [^usb]</body><body package="PickCell">test1	| usb |	usb := self new.	usb initialize.	usb open</body><body package="PickCell">test2	| usb buffer |	usb := self new.	buffer := CIntegerType char gcMalloc: 4096.	usb		readBuf: buffer		with: 4095		with: 27		with: 115200.	Transcript		show: buffer contents printString;		cr</body><body package="PickCell">test3	"        const int size = 4095;        unsigned char character[size +1];        int cport = 27;        int bdrate = 9600;        int numChar = 0;        while (1)        {                numChar = readBuf(character, size, cport, bdrate);                printf("	"Number of characters: %i\n"	", numChar);                printf("	"%s"	", (char *)character);                usleep(1000000);        }"	| usb bufferPointer numChar ws buffer |	usb := self new.	usb initialize.	Transcript show: Time now printString ; cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	10 timesRepeat: 			["bufferPointer := CIntegerType char gcMalloc: 4096."			numChar := usb						readBuf: bufferPointer						with: 4095						with: 27						with: 9600.			ws := String new writeStream.			0 to: numChar - 1				do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].			Transcript				show: numChar printString;				tab;				show: ws contents.			(Delay forSeconds: 1) wait]</body><body package="PickCell">test4	"        const int size = 4095;        unsigned char character[size +1];        int cport = 27;        int bdrate = 9600;        int numChar = 0;        while (1)        {                numChar = readBuf(character, size, cport, bdrate);                printf("	"Number of characters: %i\n"	", numChar);                printf("	"%s"	", (char *)character);                usleep(1000000);        }"	| usb bufferPointer numChar ws buffer portOk |	self unloadLibraries.	usb := self new.	usb initialize.	usb RS232_CloseComport: 27.	Transcript		show: Time now printString;		cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 9600.	portOk = 0		ifFalse: 			[Transcript				show: 'open error';				cr]		ifTrue: 			[10 timesRepeat: 					["bufferPointer := CIntegerType char gcMalloc: 4096."					numChar := usb								readBuf: bufferPointer								with: 4095								with: 27								with: 9600.					ws := String new writeStream.					0 to: numChar - 1						do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].					Transcript						show: numChar printString;						tab;						show: ws contents.					(Delay forSeconds: 1) wait].			usb RS232_CloseComport: 27]</body><body package="PickCell">test5	"        const int size = 4095;        unsigned char character[size +1];        int cport = 27;        int bdrate = 38400;        int numChar = 0;        while (1)        {                numChar = readBuf(character, size, cport, bdrate);                printf("	"Number of characters: %i\n"	", numChar);                printf("	"%s"	", (char *)character);                usleep(1000000);        }"	| usb bufferPointer numChar ws buffer portOk flushOk |	self unloadLibraries.	usb := self new.	usb initialize.	usb RS232_CloseComport: 27.	Transcript		show: Time now printString;		cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 38400.	flushOk := usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 38400.	portOk = 0		ifFalse: 			[Transcript				show: 'open error';				cr]		ifTrue: 			[100 timesRepeat: 					["bufferPointer := CIntegerType char gcMalloc: 4096."					numChar := usb								readBuf: bufferPointer								with: 4095								with: 27								with: 38400.					ws := String new writeStream.					0 to: numChar - 1						do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].					Transcript						show: numChar printString;						tab;						show: ws contents.					(Delay forSeconds: 1) wait].			usb RS232_CloseComport: 27]</body><body package="PickCell">test6	| usb bufferPointer numChar ws buffer portOk points |	self unloadLibraries.	usb := self new.	usb initialize.	points := OrderedCollection new.	usb RS232_CloseComport: 27.	Transcript		show: Time now printString;		cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 38400.	usb		flushBuf: bufferPointer		with: 4095		with: 27		with: 38400.	portOk = 0		ifFalse: 			[Transcript				show: 'open error';				cr]		ifTrue: 			[3 timesRepeat: 					["bufferPointer := CIntegerType char gcMalloc: 4096."					numChar := usb								readBuf: bufferPointer								with: 4095								with: 27								with: 38400.					ws := String new writeStream.					0 to: numChar - 1						do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].					Transcript						show: numChar printString;						tab;						show: ws contents.					points add: (TrackPoint from: ws contents).					(Delay forSeconds: 1) wait].			usb RS232_CloseComport: 27].	self halt.	^points</body><body package="PickCell">test7	| usb bufferPointer numChar ws buffer portOk flushOk points |	self unloadLibraries.	usb := self new.	usb initialize.	points := OrderedCollection new.	usb RS232_CloseComport: 27.	Transcript		show: Time now printString;		cr.	buffer := String new: 4096.	bufferPointer := buffer gcCopyToHeap.	portOk := usb				setReadBuf: bufferPointer				with: 4095				with: 27				with: 38400.	flushOk := usb				flushBuf: bufferPointer				with: 4095				with: 27				with: 38400.	portOk = 0		ifFalse: 			[Transcript				show: 'open error';				cr]		ifTrue: 			[10 timesRepeat: 					["bufferPointer := CIntegerType char gcMalloc: 4096."					numChar := usb								readBuf: bufferPointer								with: 4095								with: 27								with: 38400.					ws := String new writeStream.					0 to: numChar - 1						do: [:i | ws nextPut: (Character value: (bufferPointer at: i))].					Transcript						show: numChar printString;						tab;						show: ws contents.					points add: (TrackPoint from: ws contents).					(Delay forSeconds: 1) wait].			usb RS232_CloseComport: 27].		self halt.self laVue controller addGPSPoints: points</body><body package="PickCell">testSetupSample: port	| usb |	usb := self setupSample: 27.	usb close</body></methods><methods><class-id>NetworkOrganisation</class-id> <category>accessing</category><body package="Mapsv0">dicoNodesReached	^dicoNodesReached</body><body package="Mapsv0">dicoNodesReached: anObject	dicoNodesReached := anObject</body></methods><methods><class-id>NetworkOrganisation</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>NetworkOrganisation</class-id> <category>computing</category><body package="Mapsv0">buildNetwork	| nodeDic pointsToSymbolDictionary networkGeometry attributes |	nodeDic := Dictionary new.	pointsToSymbolDictionary := Dictionary new.	networkGeometry := AlgoDis.NetworkConnectivity new.	"networkGeometry name: aName."	networkGeometry communications: #('none' 'defined').	self dicoNodesReached keysAndValuesDo: 			[:node :accessibles |			accessibles isEmpty				ifFalse: 					[| accessiblesName key |					accessiblesName := accessibles asOrderedCollection collect: [:dist | (dist remoteNode: node) name].					key := node name.								attributes := AlgoDis.NetworkNodeAttributes						nodeName: key asString						fanOutNodes: accessiblesName						procedureName: 'Node'.			accessibles isEmpty ifFalse: [nodeDic at: key put: attributes]					pointsToSymbolDictionary at: node put: key.					nodeDic at: key put: attributes]].	networkGeometry nodeDictionary: nodeDic.	"self networkCon: networkGeometry."	^Array with: networkGeometry with: pointsToSymbolDictionary</body></methods><methods><class-id>NetworkOrganisation class</class-id> <category>instance creation</category><body package="Mapsv0">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Mapsv0">withReachedNodes: dico	^self new dicoNodesReached: dico</body></methods><methods><class-id>Mapsv0View</class-id> <category>accessing</category><body package="Mapsv0">application	^application</body><body package="Mapsv0">application: anObject	application := anObject</body><body package="Mapsv0">computeBounds	| comp bounds x y nbX nbY |	comp := self application builder componentAt: #TileViewHolder.	bounds := comp component bounds extent.	x := bounds x.	y := bounds y.	nbX := (x / 256) ceiling.	nbY := (y / 256) ceiling.	^nbX @ nbY</body><body package="Mapsv0">computeBounds128	| comp bounds x y nbX nbY |	comp := self application builder componentAt: #TileViewHolder.	bounds := comp component bounds extent.	x := bounds x.	y := bounds y.	nbX := (x / 128) rounded.	nbY := (y / 128) rounded.	^nbX @ nbY</body><body package="Mapsv0">googleMapTileCache	^googleMapTileCache</body><body package="Mapsv0">googleMapTileCache: anObject	googleMapTileCache := anObject</body><body package="Mapsv0">tileMatrix	^tileMatrix</body><body package="Mapsv0">tileMatrix: anObject	tileMatrix := anObject</body><body package="Mapsv0">viewBounds	| comp bounds x y |	comp := self application builder componentAt: #TileViewHolder.	bounds := comp component bounds extent.	x := bounds x.	y := bounds y.	^x @ y</body></methods><methods><class-id>Mapsv0View</class-id> <category>displaying</category><body package="Mapsv0">displayMapOn: aGraphicsContext	| bounds nbX nbY tileInfo tx ty tzoom graph |	bounds := self computeBounds.	nbX := bounds x.	nbY := bounds y.	tileInfo := self model value matrixTile.	tx := tileInfo at: #x ifAbsent: [^nil].	ty := tileInfo at: #y ifAbsent: [^nil].	(tx isNil or: [ty isNil]) ifTrue: [^nil].	tzoom := tileInfo at: #zoom ifAbsent: [^nil]. 	"aGraphicsContext translateBy: (translation * -1)."	0 to: nbY		do: 			[:ordonnee |			0 to: nbX				do: 					[:abscisse |					| gt |					gt := self googleMapTileCache								x: tx + abscisse								y: ty + ordonnee								zoom: tzoom.					"[gt displayOn: aGC at: (abscisse * 256) @ (ordonnee * 256)] fork"					"gt displayOn: aGraphicsContext at: (abscisse * 256) @ (ordonnee * 256)."					gt displayOn: aGraphicsContext at: (abscisse * 256) @ (ordonnee * 256)]].	"lp := self application lesPointsVH value."	"lp isEmpty ifFalse: [lp do: [:elt | elt displayOn: aGC]]."	graph := self model value pickModelTmp lastGraph.	graph isNil ifFalse: [graph displayOn: aGraphicsContext	"at: self model value originOffset * -1"]	"	aGC lineWidth: 1.	aGC paint: ColorValue black."	"colPickNodes := self model value colPickedNodesVH value."	"colPickNodes := self model value colNodes."	"origin := (tx * 256) @ (ty * 256)."	"self halt."	"colPickNodes do: [:node | node displayOn: aGC origin: origin]."	"self model value distanceSet do: [:elt | elt displayOn: aGC origin: origin]"</body><body package="Mapsv0">displayMarkAt: aPoint	| bounds nbX nbY c |	bounds := self computeBounds.	nbX := bounds x.	nbY := bounds y.	c := Circle center: aPoint radius: 10.	aPoint isNil ifFalse: [c asStroker displayAt: aPoint + (self model value originOffset * -1)]</body><body package="Mapsv0">displayOn: aGraphicsContext	| bounds nbX nbY tileInfo tx ty tzoom graph lp colPickNodes translation |	bounds := self computeBounds.	nbX := bounds x.	nbY := bounds y.	tileInfo := self model value matrixTile.	tx := tileInfo at: #x ifAbsent: [^nil].	ty := tileInfo at: #y ifAbsent: [^nil].	(tx isNil or: [ty isNil]) ifTrue: [^nil].	tzoom := tileInfo at: #zoom ifAbsent: [^nil].	translation := (tx * 256) @ (ty * 256).	"aGraphicsContext translateBy: (translation * -1).""aGraphicsContext translateBy: self model value originOffset."	0 to: nbY		do: 			[:ordonnee |			0 to: nbX				do: 					[:abscisse |					| gt |					gt := self googleMapTileCache								x: tx + abscisse								y: ty + ordonnee								zoom: tzoom.					"[gt displayOn: aGC at: (abscisse * 256) @ (ordonnee * 256)] fork"					"gt displayOn: aGraphicsContext at: (abscisse * 256) @ (ordonnee * 256)."					gt displayOn: aGraphicsContext at: (abscisse * 256) @ (ordonnee * 256)]].	"lp := self application lesPointsVH value."	"lp isEmpty ifFalse: [lp do: [:elt | elt displayOn: aGC]]."	"aGraphicsContext translateBy: translation."	"aGraphicsContext translateBy: self model value originOffset."	"self model value colNodes do: [:node | node displayOn: aGraphicsContext]."	graph := self model value pickModelTmp lastGraph.	graph isNil ifFalse: [		graph displayOn: aGraphicsContext	 at: self model value originOffset * -1]	"self inspect."	"	aGC lineWidth: 1.	aGC paint: ColorValue black."	"colPickNodes := self model value colPickedNodesVH value."	"colPickNodes := self model value colNodes."	"origin := (tx * 256) @ (ty * 256)."	"self halt."	"colPickNodes do: [:node | node displayOn: aGC origin: origin]."	"self model value distanceSet do: [:elt | elt displayOn: aGC origin: origin]"</body></methods><methods><class-id>Mapsv0View</class-id> <category>initialize-release</category><body package="Mapsv0">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	self tileMatrix: Dictionary new.	self googleMapTileCache: Mapsv0TileCache new.	^self</body></methods><methods><class-id>AlgoDis.KnownMapUrl</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	url := nil.	position := nil.	scale := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.KnownMapUrl</class-id> <category>accessing</category><body package="PickCell">position	^position</body><body package="PickCell">position: anObject	position := anObject</body><body package="PickCell">scale	^scale</body><body package="PickCell">scale: anObject	scale := anObject</body><body package="PickCell">shortName	^shortName</body><body package="PickCell">shortName: anObject	shortName := anObject</body><body package="PickCell">url	^url</body><body package="PickCell">url: anObject	url := anObject</body><body package="PickCell">url: anObject shortName: name	self url: anObject.	self shortName: name</body></methods><methods><class-id>AlgoDis.KnownMapUrl</class-id> <category>private</category><body package="PickCell">knownUrls	^self class knownUrls</body><body package="PickCell">remember	self knownUrls at: self shortName put: self url</body></methods><methods><class-id>AlgoDis.KnownMapUrl class</class-id> <category>instance creation</category><body package="PickCell">knownUrls	KnownUrls isNil ifTrue: [KnownUrls := Dictionary new].	^KnownUrls</body><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="PickCell">url: anUrl shortName: shortName	| kmu |	kmu := self new.	kmu url: anUrl shortName: shortName.	^kmu</body></methods><methods><class-id>AlgoDis.KnownMapUrl class</class-id> <category>testing</category><body package="PickCell">test1	^self url: 'http://wsn.univ-brest.fr/pottier' shortName: 'pottier'</body><body package="PickCell">test2	"^ KnownMapUrl test2 "	| k1 |	k1 := self test1.	k1 remember.	^self knownUrls</body></methods><methods><class-id>AlgoDis.KnownMapUrl class</class-id> <category>class initialization</category><body package="PickCell">initialize	^self knownUrls</body><body package="PickCell">reset	^KnownUrls := nil</body></methods><methods><class-id>MapTileCache</class-id> <category>accessing</category><body package="MapAccess">dicoZoom	^dicoZoomVH value</body><body package="MapAccess">dicoZoom: anObject	dicoZoomVH value: anObject</body><body package="MapAccess">x: xTile y: yTile zoom: zoom	| modulo x y dico |	modulo := 2 raisedTo: zoom.	x := xTile \\ modulo.	y := yTile \\ modulo.	dico := self dicoZoom at: zoom ifAbsentPut: [Dictionary new: 16].	^dico at: x @ y ifAbsentPut: [MapTile x: x y: y zoom: zoom]</body></methods><methods><class-id>MapTileCache</class-id> <category>actions</category><body package="MapAccess">emptyCache	self dicoZoom: (Dictionary new: 21)</body></methods><methods><class-id>MapTileCache</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	dicoZoom := Dictionary new: 22.	dicoZoomVH := (Dictionary new: 22) asValue.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>MapTileCache class</class-id> <category>instance creation</category><body package="MapAccess">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QuickTileProxyArcgisWorldImagery</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyArcgisWorldImagery</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	^('http://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/'		, zoom printString , '/'		, y printString , '/'		, x printString) asURI</body></methods><methods><class-id>QuickTileProxyArcgisWorldImagery class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^'ArcGis World Imagery'</body><body package="QuickMap">maxSocket	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^2</body><body package="QuickMap">maxZoom	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	^16</body></methods><methods><class-id>QuickTileProxyGapp</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| galileo |	galileo := 'Galileo' readStream next: (Random new next * 7) rounded.	^('http://mt' , anInteger printString		, '.google.com/vt/lyrs=m@259000000&amp;hl=en&amp;src=app&amp;x=' , x printString		, '&amp;y=' , y printString		, '&amp;z=' , zoom printString		, '&amp;s=' , galileo)		asURI</body></methods><methods><class-id>QuickTileProxyGapp</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxyGapp</class-id> <category>networking</category><body package="QuickMap">getPng: anIndex x: x y: y zoom: zoom	| httpResponse imageStream url qhr idxc cli sem galileo |	idxc := self semIndexClient.	cli := self clientAt: idxc.	sem := self semaphoreAt: idxc.	url := self				getUri: anIndex				x: x				y: y				zoom: zoom.	qhr := QuickHttpRequest get: url.	galileo := 'Galileo' readStream next: (Random new next * 7) rounded.	qhr requestLine url path: ((OrderedCollection new)				add: 'vt';				add: 'lyrs=m@259000000&amp;hl=en&amp;src=app&amp;x=' 							, x printString , '&amp;y='							, y printString , '&amp;z='							, zoom printString							, '&amp;s=' , galileo;				yourself).	qhr fieldValueAt: 'User-Agent'		put: 'Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.2.23) Gecko/20110921 Ubuntu/10.10 (maverick) Firefox/3.6.23'.	qhr mapClients: cli.	sem critical: [httpResponse := qhr execute].	imageStream := httpResponse value byteSource.	^imageStream</body></methods><methods><class-id>QuickTileProxyGapp class</class-id> <category>instance creation</category><body package="QuickMap">friendlyName	^'Google app'</body><body package="QuickMap">maxSocket	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^22</body><body package="QuickMap">maxZoom	" *** This method was defined by QuickTileProxy class as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	^22</body></methods><methods><class-id>AlgoDis.CellClassifier</class-id> <category>accessing</category><body package="PickCell">cell	^cell</body><body package="PickCell">cell: anObject	cell := anObject</body><body package="PickCell">cellArray	^cellArray</body><body package="PickCell">cellArray: anObject	cellArray := anObject</body><body package="PickCell">dictionary	^dictionary</body><body package="PickCell">dictionary: anObject	dictionary := anObject</body><body package="PickCell">newCellArray	^newCellArray</body><body package="PickCell">newCellArray: anObject	newCellArray := anObject</body><body package="PickCell">pickModel	^pickModel</body><body package="PickCell">pickModel: anObject	pickModel := anObject</body></methods><methods><class-id>AlgoDis.CellClassifier</class-id> <category>scanning</category><body package="PickCell">scan3	| pixel min max nb minRed maxRed sumRed minGreen maxGreen sumGreen minBlue maxBlue sumBlue mean signature seuil Gray glevel |	seuil := 0.1.	minRed := 2 raisedTo: 8.	maxRed := 0.	sumRed := 0.	minGreen := 2 raisedTo: 8.	maxGreen := 0.	sumGreen := 0.	minBlue := 2 raisedTo: 8.	maxBlue := 0.	sumBlue := 0.	nb := 0.	self cell pixelsDo: 			[:x :y |			pixel := self cell valueAtPoint: x @ y.			pixel red &lt; minRed ifTrue: [minRed := pixel red].			pixel red &gt; maxRed ifTrue: [maxRed := pixel red].			sumRed := sumRed + pixel red.			pixel green &lt; minGreen ifTrue: [minGreen := pixel green].			pixel green &gt; maxGreen ifTrue: [maxGreen := pixel green].			sumGreen := sumGreen + pixel green.			pixel blue &lt; minBlue ifTrue: [minBlue := pixel blue].			pixel blue &gt; maxBlue ifTrue: [maxBlue := pixel blue].			sumBlue := sumBlue + pixel blue.			self halt.			Gray := ((0 , 2125 sumRed) + 0 , 7154 sumGreen) + 0 , 0721 sumBlue.			nb := nb + 1.			self dictionary add: pixel].	min := ColorValue red: minRed green: minGreen blue: minBlue.	max := ColorValue red: maxRed green: maxGreen blue: maxBlue.	mean := ColorValue				red: (sumRed / nb) truncated				green: (sumGreen / nb) truncated				blue: (sumBlue / nb) truncated.	glevel := ColorValue gray: Gray.	signature := CellSignature				min: min				max: max				mean: mean				glevel: glevel.	signature seuil: seuil.	^signature</body><body package="PickCell">scan3: seuil	| pixel min max nb minRed maxRed sumRed minGreen maxGreen sumGreen minBlue maxBlue sumBlue mean glevel initialSignature |	initialSignature := CellSignature new.	initialSignature seuil: seuil.	minRed := 2 raisedTo: 18.	maxRed := 0.	sumRed := 0.	minGreen := 2 raisedTo: 18.	maxGreen := 0.	sumGreen := 0.	minBlue := 2 raisedTo: 18.	maxBlue := 0.	sumBlue := 0.	nb := 0.	self cell pixelsDo: 			[:x :y |			pixel := self cell valueAtPoint: x @ y.			pixel red &lt; minRed ifTrue: [minRed := pixel red].			pixel red &gt; maxRed ifTrue: [maxRed := pixel red].			sumRed := sumRed + pixel red.			pixel green &lt; minGreen ifTrue: [minGreen := pixel green].			pixel green &gt; maxGreen ifTrue: [maxGreen := pixel green].			sumGreen := sumGreen + pixel green.			pixel blue &lt; minBlue ifTrue: [minBlue := pixel blue].			pixel blue &gt; maxBlue ifTrue: [maxBlue := pixel blue].			sumBlue := sumBlue + pixel blue.			nb := nb + 1.			self dictionary at: x@y put: pixel].	min := ColorValue red: minRed green: minGreen blue: minBlue.	max := ColorValue red: maxRed green: maxGreen blue: maxBlue.	mean := ColorValue				red: sumRed / nb				green: sumGreen / nb				blue: sumBlue / nb.	initialSignature		min: min;		max: max;		mean: mean.	glevel := ColorValue				red: 0.2125 * sumRed / nb				green: 0.7154 * sumGreen / nb				blue: 0.0721 * sumBlue / nb.	initialSignature mean2: glevel.	^initialSignature</body><body package="PickCell">scan: seuil"	^self scan3: seuil"	^self scan3: seuil</body><body package="PickCell">scanElev: seuil	| pixel min max nb minRed maxRed sumRed minGreen maxGreen sumGreen minBlue maxBlue sumBlue mean glevel initialSignature minElev |	initialSignature := CellSignature new.	initialSignature seuil: seuil.	minElev := 2 raisedTo: 18. 	nb := 0.	self cell pixelsDo: 			[:x :y |				self halt.			pixel := self cell valueAtPoint: x @ y.			pixel red &lt; minRed ifTrue: [minRed := pixel red].			pixel red &gt; maxRed ifTrue: [maxRed := pixel red].			sumRed := sumRed + pixel red.			pixel green &lt; minGreen ifTrue: [minGreen := pixel green].			pixel green &gt; maxGreen ifTrue: [maxGreen := pixel green].			sumGreen := sumGreen + pixel green.			pixel blue &lt; minBlue ifTrue: [minBlue := pixel blue].			pixel blue &gt; maxBlue ifTrue: [maxBlue := pixel blue].			sumBlue := sumBlue + pixel blue.			nb := nb + 1.			self dictionary at: x@y put: pixel].	min := ColorValue red: minRed green: minGreen blue: minBlue.	max := ColorValue red: maxRed green: maxGreen blue: maxBlue.	mean := ColorValue				red: sumRed / nb				green: sumGreen / nb				blue: sumBlue / nb.	initialSignature		min: min;		max: max;		mean: mean.	glevel := ColorValue				red: 0.2125 * sumRed / nb				green: 0.7154 * sumGreen / nb				blue: 0.0721 * sumBlue / nb.	initialSignature mean2: glevel.	^initialSignature</body><body package="PickCell">signaturesToLists: seuil	| listOfFoundCells signatures oc pos cellule signature coll aCellImage rebuild sortedCollectionOfCells |	signatures := Dictionary new.	"Ce dictionnaire est accÃ©dÃ© par des signatures : cf : signatures at: signature	les valeurs sont des collections de point-&gt;aCellImage"	coll := SortedCollection				sortBlock: [:p1 :p2 | p1 x &lt; p2 x and: [p1 y &lt; p2 y]].	"Ici on va balayer le tableau des CellImage. On construit un dictionnaire dont les clÃ©s sont les signatures, 	et les Ã©lÃ©ments des collections de CellImage ayant cette signature."	self newCellArray keysAndValuesDo: 			[:yPos :row |			row keysAndValuesDo: 					[:xPos :anArray |					"c'est quoi ce bazard de last ???' , il faut sans doute clarifier en crÃ©ant une classe au lieu de cet Array: 					1) l'image					2) la signature					3) le CellImage calculÃ© en amont dans newCellArray "					aCellImage := anArray last.					aCellImage isNil						ifFalse: 							[signature := aCellImage signature.							cellule := aCellImage cellImage.							signature seuil: seuil.							"On regarde si on connait cette signature. Dans le cas contraire, on crÃ©e son rÃ©ceptacle"							listOfFoundCells := signatures at: signature										ifAbsent: 											[oc := OrderedCollection new.											signatures at: signature put: oc.											oc].							pos := xPos @ yPos.							coll add: pos.							"on ajoute une association a l'entrÃ©e concernÃ©e, la clÃ© est la position logique, et la valeur le CellImage que l'on vient de traiter"							listOfFoundCells add: pos -&gt; aCellImage]	"ca ne devrait pas arriver !"]].	" to check: let us build a new dictionary to sort elements havaing same signature "	rebuild := Dictionary new.	signatures keysAndValuesDo: 			[:keySignature :collection |			sortedCollectionOfCells  := SortedCollection						sortBlock: [:p1 :p2 | p1 key x = p2 key x ifTrue: [p1 key y &lt; p2 key y] ifFalse: [p1 key  x &lt; p2 key x]].			collection do: [:assKeyPlusCell  | sortedCollectionOfCells  add: assKeyPlusCell ].			rebuild at: keySignature put: collection asOrderedCollection].	^rebuild</body><body package="PickCell">updateUICellShow: seuil	| signatures points newVal ui dicoSignaturesToPointCollection |	signatures := self signaturesToLists: seuil.	"a quoi cela sert ? Ce n'est pas utilisÃ© !! "	dicoSignaturesToPointCollection := Dictionary new.	signatures keysAndValuesDo: 			[:cellSignatureKey :collectionPointsImages |			points := collectionPointsImages collect: [:asso | asso key].			newVal := Array with: collectionPointsImages first value with: points.			dicoSignaturesToPointCollection at: cellSignatureKey put: newVal].	"end of unused code "	ui := UICellShow new.	ui open.	ui load: signatures.	^ui</body></methods><methods><class-id>AlgoDis.CellClassifier</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	dictionary := Bag new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.CellClassifier class</class-id> <category>instance creation</category><body package="PickCell">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="PickCell">on: cell	| classifier |	classifier := self new.	classifier cell: cell.	^classifier</body></methods><methods><class-id>QuickLayer</class-id> <category>accessing</category><body package="QuickMap">zoom	^zoom</body><body package="QuickMap">zoom: anObject	zoom := anObject</body></methods><methods><class-id>QuickLayer</class-id> <category>bounds accessing</category><body package="QuickMap">preferredBounds	" *** This method was defined by VisualComponent as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>QuickLayer</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	zoom := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.CellSignature</class-id> <category>accessing</category><body package="PickCell">max	^max</body><body package="PickCell">max: anObject	max := anObject</body><body package="PickCell">mean	^mean</body><body package="PickCell">mean2	^mean2</body><body package="PickCell">mean2: anObject	mean2 := anObject</body><body package="PickCell">mean: anObject	mean := anObject</body><body package="PickCell">min	^min</body><body package="PickCell">min: anObject	min := anObject</body><body package="PickCell">performer	performer isNil ifTrue: [^#eq0:].	^performer</body><body package="PickCell">performer: anObject	performer := anObject</body><body package="PickCell">seuil	^seuil</body><body package="PickCell">seuil: anObject	seuil := anObject</body></methods><methods><class-id>AlgoDis.CellSignature</class-id> <category>comparing</category><body package="PickCell">= obj	"generic use with a test method "	^self perform: self performer with: obj</body><body package="PickCell">eq0: obj	| ok1 ok2 ok3 |	ok1 := (self min red - obj min red) abs = 0.	ok1 := ok1 and: [(self min green - obj min green) abs = 0].	ok1 := ok1 and: [(self min blue - obj min blue) abs = 0].	ok2 := (self max red - obj max red) abs = 0.	ok2 := ok2 and: [(self max green - obj max green) abs = 0].	ok2 := ok2 and: [(self max blue - obj max blue) abs = 0].	ok3 := (self mean red - obj mean red) abs = 0.	ok3 := ok3 and: [(self mean green - obj mean green) abs = 0].	ok3 := ok3 and: [(self mean blue - obj mean blue) abs = 0].	^(ok1 and: [ok2]) and: [ok3]</body><body package="PickCell">eq1: obj	| ok1 ok2 ok3 |	ok1 := (self min red - obj min red) abs &lt;= (self seuil * 4).	ok1 := ok1 and: [(self min green - obj min green) abs &lt;= (self seuil * 4)].	ok1 := ok1 and: [(self min blue - obj min blue) abs &lt;= (self seuil * 4)].	ok2 := (self max red - obj max red) abs &lt;= (self seuil * 4).	ok2 := ok2 and: [(self max green - obj max green) abs &lt;= (self seuil * 4)].	ok2 := ok2 and: [(self max blue - obj max blue) abs &lt;= (self seuil * 4)].	ok3 := (self mean red - obj mean red) abs &lt;= (self seuil * 4).	ok3 := ok3				and: [(self mean green - obj mean green) abs &lt;= (self seuil * 4)].	ok3 := ok3 and: [(self mean blue - obj mean blue) abs &lt;= (self seuil * 4)].	^(ok1 and: [ok2]) and: [ok3]</body><body package="PickCell">eq2: obj	"is variance in the same range "	| ok1 ok2 ok3 seuilVar |	seuilVar := self seuil / 2.	ok1 := (self mean2 red - obj mean2 red) abs &lt;= seuilVar.	ok2 := (self mean2 green - obj mean2 green) abs &lt;= seuilVar.	ok3 := (self mean2 blue - obj mean2 blue) abs &lt;= seuilVar.	ok1 := (ok1 and: [ok2]) and: [ok3].	ok3 := (self mean red - obj mean red) abs &lt;= self seuil.	ok3 := ok3 and: [(self mean green - obj mean green) abs &lt;= self seuil].	ok3 := ok3 and: [(self mean blue - obj mean blue) abs &lt;= self seuil].	^ok1 and: [ok3]</body><body package="PickCell">eq3: obj	"is variance in the same range "	| ok1 ok2 ok3 seuilVar | 	seuilVar := self seuil / 4.	ok1 := (self mean2 red - obj mean2 red) abs &lt;= seuilVar.	ok2 := (self mean2 green - obj mean2 green) abs &lt;= seuilVar.	ok3 := (self mean2 blue - obj mean2 blue) abs &lt;= seuilVar.	ok1 := (ok1 and: [ok2]) and: [ok3].	^ok1</body></methods><methods><class-id>AlgoDis.CellSignature</class-id> <category>computing</category><body package="PickCell">indexFor: aColour partition: nbPart" compute 3D coordinate for aColour "	| index componentOffset redIndex greenIndex blueIndex partitionDictionary |	partitionDictionary := self partitionsIntervFor: nbPart.	componentOffset := aColour red - min red.	index := Array new: 3.	(partitionDictionary at: #red) &gt; 0		ifTrue: 			[redIndex := (componentOffset / (partitionDictionary at: #red)) truncated						+ 1.			index at: 1 put: redIndex].	componentOffset := aColour green - min green.	(partitionDictionary at: #green) &gt; 0		ifTrue: 			[greenIndex := (componentOffset / (partitionDictionary at: #green))						truncated + 1.			index at: 2 put: greenIndex].	componentOffset := aColour blue - min blue.	(partitionDictionary at: #blue) &gt; 0		ifTrue: 			[blueIndex := (componentOffset / (partitionDictionary at: #blue)) truncated						+ 1.			index at: 3 put: blueIndex].	^index</body><body package="PickCell">partitionsIntervFor: nbPart	" nbPart diveide each coulour component giving a 3D space for classes "	| intervals redInterv greenInterv blueInterv |	intervals := Dictionary new.	redInterv := max red - min red.	greenInterv := max green - min green.	blueInterv := max blue - min blue.	intervals at: #red put: redInterv / nbPart.	intervals at: #green put: greenInterv / nbPart.	intervals at: #blue put: blueInterv / nbPart.	^intervals</body><body package="PickCell">rgbCoordinateFor: aColour partitions: nbPart	" compute 3D coordinate for aColour "	| index componentOffset redIndex greenIndex blueIndex partitionDictionary |	partitionDictionary := self partitionsIntervFor: nbPart.	componentOffset := aColour red - min red.	index := Array new: 3.	(partitionDictionary at: #red) &gt; 0		ifTrue: 			[redIndex := (componentOffset / (partitionDictionary at: #red)) truncated						+ 1.			index at: 1 put: redIndex].	componentOffset := aColour green - min green.	(partitionDictionary at: #green) &gt; 0		ifTrue: 			[greenIndex := (componentOffset / (partitionDictionary at: #green))						truncated + 1.			index at: 2 put: greenIndex].	componentOffset := aColour blue - min blue.	(partitionDictionary at: #blue) &gt; 0		ifTrue: 			[blueIndex := (componentOffset / (partitionDictionary at: #blue)) truncated						+ 1.			index at: 3 put: blueIndex].	^index</body></methods><methods><class-id>AlgoDis.CellSignature</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	min := nil.	max := nil.	mean := nil.	mean2 := nil.	"r g b"	seuil := 0.0.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>AlgoDis.CellSignature class</class-id> <category>instance creation</category><body package="PickCell">min: min max: max mean: mean	| sig |	sig := self new.	sig		min: min;		max: max;		mean: mean.	^sig</body><body package="PickCell">min: min max: max mean: mean mean2: mean2	| sig |	sig := self new.	sig		min: min;		max: max;		mean: mean ;mean2: mean2.	^sig</body><body package="PickCell">new	"Answer a newly created and initialized instance."	| cs |	cs := super new initialize.	cs		min: 0;		max: 0;		mean: 0.	^cs</body></methods><methods><class-id>QuickTileProxySenegal</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>QuickTileProxySenegal</class-id> <category>private</category><body package="QuickMap">getUri: anInteger x: x y: y zoom: zoom	" *** This method was defined by QuickTileProxy as a subclass responsibility.	Replace its body with a proper implementation. *** "	"self error: 'Subclass responsibility stub not reimplemented'"	| string |	string :=super baseWsn, '/osm_senegal/' , zoom printString , '/'				, x printString , '/'				, y printString , '.png'.	Transcript		show: string;		cr.	^string asURI</body></methods><methods><class-id>QuickTileOverlay</class-id> <category>initialize-release</category><body package="QuickMap">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	x := nil.	y := nil.	zoom := nil.	container := nil.	prx := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>QuickTileOverlay</class-id> <category>accessing</category><body package="QuickMap">cacheGC	cacheGC isNil ifFalse: [cacheGC handle isNil ifFalse: [^cacheGC]].	cacheGC := Mask extent: 256 @ 256.	"Pixmap"	cacheGC background: CoverageValue transparent.	(prx dicoCompositeAtZoom: zoom) displayOn: cacheGC graphicsContext		at: (x @ y * 256) negated.	^cacheGC</body><body package="QuickMap">container	^container</body><body package="QuickMap">container: anObject	container := anObject</body><body package="QuickMap">prx	^prx</body><body package="QuickMap">prx: anObject	prx := anObject</body><body package="QuickMap">x	^x</body><body package="QuickMap">x: anObject	x := anObject</body><body package="QuickMap">y	^y</body><body package="QuickMap">y: anObject	y := anObject</body><body package="QuickMap">zoom	^zoom</body><body package="QuickMap">zoom: anObject	zoom := anObject</body></methods><methods><class-id>QuickTileOverlay</class-id> <category>displaying</category><body package="QuickMap">displayOn: aGraphicsContext	| tileSize |	tileSize := 256.	self cacheGC displayOn: aGraphicsContext at: x @ y * tileSize.	"aGraphicsContext primDisplayUninterpretedImageBits: self cacheGC at: x @ y * tileSize"	"aGraphicsContext displayPixelArray: self cacheGC at: x @ y * tileSize"</body></methods><methods><class-id>QuickTileOverlay class</class-id> <category>instance creation</category><body package="QuickMap">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="QuickMap">x: x y: y zoom: zoom	"Answer a newly created and initialized instance."	^(self new)		x: x;		y: y;		zoom: zoom;		yourself</body></methods><methods><class-id>GPSTrackingStream</class-id> <category>accessing</category><body package="PickCell">aGPSTrackingInterface	^aGPSTrackingInterface</body><body package="PickCell">aGPSTrackingInterface: anObject	aGPSTrackingInterface := anObject</body></methods><methods><class-id>GPSTrackingStream</class-id> <category>initialize-release</category><body package="PickCell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	aGPSTrackingInterface new.	^self</body></methods><methods><class-id>GPSTrackingStream class</class-id> <category>instance creation</category><body package="PickCell">new	^super new initialize</body></methods><methods><class-id>UILocation</class-id> <category>actions</category><body package="PickCell">defineCorner</body><body package="PickCell">defineOrigin</body><body package="PickCell">getOrigin	^self origine value</body><body package="PickCell">saveFile	| name fname ws |	name := Dialog requestNewFileName: 'Image file name'				default: self imageName value.	name isEmpty		ifFalse: 			[fname := name asFilename.			ws := fname writeStream.			self image isNil				ifFalse: 					[self image storeOn: ws.					ws close]]</body><body package="PickCell">sendToPickCell	| uiPickCell pm |	self image isNil		ifFalse: 			[uiPickCell := UIPickCellNodes new.			pm := uiPickCell pickModel value.			pm filename: nil.			pm points: OrderedCollection new.			pm bounds: self image bounds.			pm mapOrigin: self getOrigin.	 			uiPickCell pickModel value: pm.			uiPickCell laVue image: self image.			uiPickCell open]</body><body package="PickCell">setDelay	| sec |	sec := Dialog request: 'screenshot in seconds' initialAnswer: '10'.	sec isEmpty		ifFalse: 			[sec := sec asNumber.			0 to: 10				do: 					[:i |					(Delay forSeconds: sec / 10) wait.					self delayPerCent value: i / 10].			image := Image fromUser].	image inspect</body></methods><methods><class-id>UILocation</class-id> <category>accessing</category><body package="PickCell">corner: anObject	^corner := anObject</body><body package="PickCell">image	^image</body><body package="PickCell">image: anObject	image := anObject</body><body package="PickCell">mercator	^mercator</body><body package="PickCell">mercator: anObject	mercator := anObject</body><body package="PickCell">origine: anObject	^origine := anObject</body></methods><methods><class-id>UILocation</class-id> <category>aspects</category><body package="PickCell">coordinateMode	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^coordinateMode isNil		ifTrue:			[coordinateMode := #GPS asValue]		ifFalse:			[coordinateMode]</body><body package="PickCell">corner	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^corner isNil		ifTrue:			[corner := String new asValue]		ifFalse:			[corner]</body><body package="PickCell">delayPerCent	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^delayPerCent isNil		ifTrue:			[delayPerCent := 0 asValue]		ifFalse:			[delayPerCent]</body><body package="PickCell">elevation	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^elevation isNil		ifTrue:			[elevation := String new asValue]		ifFalse:			[elevation]</body><body package="PickCell">imageName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^imageName isNil		ifTrue:			[imageName := 'image.png' asValue]		ifFalse:			[imageName]</body><body package="PickCell">leX	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leX isNil		ifTrue:			[leX := String new asValue]		ifFalse:			[leX]</body><body package="PickCell">leXGeo	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leXGeo isNil		ifTrue:			[leXGeo := String new asValue]		ifFalse:			[leXGeo]</body><body package="PickCell">leY	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leY isNil		ifTrue:			[leY := String new asValue]		ifFalse:			[leY]</body><body package="PickCell">leYGeo	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leYGeo isNil		ifTrue:			[leYGeo := String new asValue]		ifFalse:			[leYGeo]</body><body package="PickCell">origine	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^origine isNil		ifTrue:			[origine := String new asValue]		ifFalse:			[origine]</body><body package="PickCell">parameters	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parameters isNil		ifTrue:			[parameters := String new asValue]		ifFalse:			[parameters]</body></methods><methods><class-id>UILocation</class-id> <category>changing</category><body package="PickCell">updateOrigin: lonLatOrigin corner: lonLatCorner	| ws string adJustBlock |	ws := (String new: 100) writeStream.	adJustBlock :=			[:doub |			string := doub printString.			string := string copyFrom: 1 to: string size - 1.			ws nextPutAll: string].	adJustBlock value: lonLatOrigin y.	ws nextPut: $,.	adJustBlock value: lonLatOrigin x.	self origine value: ws contents.	ws := (String new: 100) writeStream.	adJustBlock value: lonLatCorner y.	ws nextPut: $,.	adJustBlock value: lonLatCorner x.	self corner value: ws contents</body></methods><methods><class-id>MapAccessView</class-id> <category>displaying</category><body package="MapAccess">displayOn: aGraphicsContext	| originX originY offsetX offsetY component |	self model value displayOn: aGraphicsContext.	component := self model value component.	component isNil		ifFalse: 			[originX := self model value xTile.			originY := self model value yTile.			offsetX := (originX * 256) negated.			offsetY := (originY * 256) negated.			aGraphicsContext translateBy: offsetX @ offsetY.			component displayOn: aGraphicsContext "at: (offsetX @ offsetY scaledBy: -1)"]</body></methods><methods><class-id>MapAccessView</class-id> <category>initialize-release</category><body package="MapAccess">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><initialize><class-id>AlgoDis.ElevationReader</class-id></initialize><initialize><class-id>UIQuickMap</class-id></initialize><initialize><class-id>AlgoDis.KnownMapUrl</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>SelectionTracker</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>HttpRequest</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class></st-source>