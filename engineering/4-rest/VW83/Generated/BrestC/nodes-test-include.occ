-- spreading model for OCCAM based cellular automata generated from PickCell
-- CellNode is the program for each cell
-- Mux is the painting procedure
-- Images are output, ppm format, then assembled into an MP4 movie
-- See Makefile

#INCLUDE "rastergraphics.module"
#INCLUDE "rasterio.module"
#INCLUDE "string.module"

-- Constantes de la simulation spreading
VAL INT MaxTour IS 280:
VAL INT NbGeneratedFactor IS 5:
VAL INT Density IS 1:
VAL INT OutGoingDivider IS 4:
VAL INT InitialPopu IS 50:

-- Constantes dependantes du systeme de cellules
VAL INT cellSizeX IS systemOrganization[cellWidth]:
VAL INT cellSizeY IS systemOrganization[cellHeight]:
VAL INT ImageDimX IS (systemOrganization[ImageDimX]):
VAL INT ImageDimY IS (systemOrganization[ImageDimY]):

-- Protocole decrivant les echanges physiques : rien, ou des objets mobiles
PROTOCOL diam.proto 
  CASE
    number; INT
    null; INT
:

-- Programme des cellules
PROC CellNode([]CHAN OF diam.proto in,out, VAL INT id, CHAN OF BYTE toMux)
  CellPosition position:
  [MaxFanOut] INT bufIn,bufOut:
  [MaxFanOut] BOOL voisinsDansLaMer:
  [MaxFanOut] INT  exports:
  INT nbVoisinsMer:
  BOOL isSource,cellDansLaMer:
  Location myLoc:
  REAL64 elevation:
  INT integerElevation,outgoing,population:

  PROC GetIdFromLocation(INT xLoc,yLoc,identity)
    -- correction against the data code produced (ids)
    -- to be removed later
    CellPosition position:
    Location loc:
    SEQ
      identity := -1
      SEQ i=0 FOR MaxNodes
        SEQ
          position := Cells[i][position]
          IF
            (position[x] = xLoc) AND (position[y] = yLoc)
              identity := i
            TRUE
              SKIP
  :


  PROC SetUpPopulation(INT population, Location loc)
    -- set a population >0 if cells is part of MyShape
    GeometricPoint   myShapeFirstPoint, shapeCell:
    BOOL inShape:
    SEQ
      cellDansLaMer := integerElevation <=0
      isSource := FALSE
      inShape := FALSE
      -- InShape(loc, inShape)
      IF 
        inShape
          SEQ
            population := InitialPopu
            isSource := TRUE
        TRUE
          population:=0
  :
        
  PROC ExploreVoisinage( [] BOOL voisinsValides, INT voisinsMer, BOOL cellDansLaMer)
    [MaxFanOut] INT bufIn,bufOut:
    SEQ
      voisinsMer := 0
      SEQ j=0 FOR SIZE voisinsValides
        voisinsValides[j] := FALSE
      PAR
        PAR j=0 FOR SIZE in
          in[j] ? CASE
            null ; bufIn[j] -- in the ground
              SKIP
            number ; bufIn[j] -- in the sea
              SEQ
                voisinsValides[j] := TRUE
                voisinsMer:=voisinsMer +1
        PAR j=0 FOR SIZE out
          -- emit a null if we are on the ground, a number in the other cases
          IF
            cellDansLaMer
              out[j] ! number ;  integerElevation
            TRUE
              out[j] ! null ; integerElevation
  :

  PROC ExportNumbers(VAL BOOL cellDansLaMer, [] INT exports, [] BOOL valid, INT MaxExport)
    -- quantites de poissons exportes pour chaque voisin dans la mer
    INT seed,nbExport:
    SEQ
      seed := id
      nbExport := 0 -- somme des exportations
      SEQ i=0 FOR SIZE out
        IF 
          cellDansLaMer AND valid[i]
            SEQ
              exports[i], seed := random (InitialPopu, seed)
              nbExport := nbExport + exports[i]
          TRUE
            exports[i] := 0
      SEQ  i=0 FOR SIZE out -- on ajuste les quantites exportees
        IF
          nbExport>0
            exports[i] := ( exports[i] * MaxExport)  / nbExport
          TRUE
            exports[i] :=0
  :

  INT GoodId: -- pour garder l'id effectif dans le fichier DATA
  SEQ

    myLoc := NetLocation [id]
    GetIdFromLocation(myLoc[xLoc],myLoc[yLoc],GoodId)
    position := Cells [GoodId][position]
    elevation := position[elevation]
    integerElevation := ( INT ROUND ( elevation + 1.0)) -1
    cellDansLaMer := integerElevation <=0
    ExploreVoisinage(voisinsDansLaMer, nbVoisinsMer, cellDansLaMer)
    SetUpPopulation(population, myLoc)
    -- compute outgoing population for first round
    IF 
      cellDansLaMer AND (nbVoisinsMer>0)
        outgoing := ( population/OutGoingDivider) / nbVoisinsMer
      TRUE
        outgoing:=0  -- not InTheSea or no neighbour working

    -- share outgoing between neighbours
    ExportNumbers(cellDansLaMer, exports, voisinsDansLaMer, outgoing)

    -- fill buffers for neighbours, first round
    SEQ i=0 FOR SIZE out
      IF 
        (NOT cellDansLaMer) OR (NOT voisinsDansLaMer[i])
          bufOut [i] := 0
        TRUE      
          SEQ
            bufOut [i] := exports[i]
            population := population - bufOut [i]
    SEQ tours = 0 FOR  MaxTour
      SEQ
        PAR -- communications synchrones
          PAR i=0 FOR SIZE in
            in[i] ? CASE
              number ; bufIn[i]
                population:= population + bufIn[i]
              null ; bufIn[i]
                SKIP
          PAR j=0 FOR SIZE out
            IF
              voisinsDansLaMer[j] AND cellDansLaMer
                out[j] ! number ; bufOut [j]
              TRUE
                out[j] ! null ; 0

        -- generate new fishes on sources
        IF
          isSource
            population := population + (NbGeneratedFactor * (tours / 4))
          TRUE
            SKIP


        -- compute outgoing population for this round
        IF 
          cellDansLaMer AND (nbVoisinsMer>0)
            outgoing := ( population/OutGoingDivider) / nbVoisinsMer
          TRUE
            outgoing:=0  -- not InTheSea or no neighbour working
    
        -- share outgoing between neighbours
        ExportNumbers(cellDansLaMer, exports, voisinsDansLaMer, outgoing)
   
        -- fill buffers  
        SEQ i=0 FOR SIZE out
          IF 
            (NOT cellDansLaMer) OR (NOT voisinsDansLaMer[i])
              bufOut [i] := 0
            TRUE      
              SEQ
                bufOut [i] :=  exports[i]
                population := population - bufOut [i]
        toMux ! '.'
        out.number(integerElevation,0,toMux)
        toMux ! ' '
        out.number(position [x],0,toMux)
        toMux ! ' '
        out.number(position [y],0,toMux)
        toMux ! ' '
        out.number(myLoc [xLoc],0,toMux)
        toMux ! ' '
        out.number(myLoc [yLoc],0,toMux)
        toMux ! ' '
        out.number(id ,0,toMux)
        toMux ! ' '
        out.number(position [identity],0,toMux)
        toMux ! ' '
        out.number(population,0,toMux)
        toMux ! '*n'
    
:


--DATA TYPE SystemOrganization
--  RECORD
--    INT width, height: -- in pixels
--    INT cellWidth, cellHeight: -- in pixels
--    REAL64 longitude, latitude:
--    INT zoom: -- web mercator depth
--:
--VAL SystemOrganization systemOrganization WAS [782 , 675 , 15 , 15 , -4.5275688171387 , 48.398436885272 , 13 ]: 


PROC Mux([]CHAN OF BYTE fromProc, CHAN OF BYTE out)
  INT maxX, maxY:
  VAL INT MaxString IS 200:
  [ImageDimY*cellSizeY][ImageDimX*cellSizeX] INT  raster: 
  [MaxString] BYTE fileName:
  INT nameLen:
  PROC PrintSystem()
    SEQ
      out.number(ImageDimX,4,out)
      out ! '*n'
      out.number(cellSizeX,4,out)
      out ! '*n'
      out.number(ImageDimY,4,out)
      out ! '*n'
      out.number(cellSizeY,4,out)
      out ! '*n'
      out.number((ImageDimY*cellSizeY)*(ImageDimX*cellSizeX),8,out)
      out ! '*n'
  :
  -- produce a name in fileName for current image n
  PROC MakeString(VAL INT n, [] BYTE fileName, INT nameLen)
    VAL [] BYTE name IS "image":
    SEQ
      nameLen:=0
      SEQ i=0 FOR MaxString
        fileName[i] := (BYTE 0)
      append.text (nameLen, fileName,name) 
      append.int (nameLen, fileName , n , 0 )
      append.text (nameLen, fileName, ".ppm")
  :

  -- copy the cell image to a local equivalent raster
  PROC RGBToRaster( Depth24ByteArray rgbArray, [cellSizeY][cellSizeX]INT cellRaster)
    RGBPixel rgb:
    INT rgbColour:

    SEQ
      SEQ j=0 FOR cellSizeY
        SEQ i=0 FOR cellSizeX
          SEQ
            rgb := rgbArray[(j*cellSizeY) + i]
            rgbColour := pack.colour(rgb[red],rgb[green],rgb[blue])
            cellRaster[j][i] := rgbColour
  :

  PROC GetIdFromLocation(INT xLoc,yLoc,identity)
    CellPosition position:
    Location loc:
    SEQ
      identity := -1
      SEQ i=0 FOR MaxNodes
        SEQ
          -- loc := NetLocation[i]
          position := Cells[i][position]
          IF
            -- (loc[xLoc] = xLoc) AND (loc[yLoc] = yLoc)
            (position[x] = xLoc) AND (position[y] = yLoc)
              identity := i
            TRUE
              SKIP
  :


  PROC Draw()
    CellPosition cell:
    [cellSizeY][cellSizeX] INT cellRaster:
    CellImage image:
    INT x,y:
    SEQ
      SEQ i=0 FOR SIZE Cells
        SEQ
          cell := Cells[i][position]
          x:=  (cell[x]-1) *cellSizeX
          y:=  (cell[y]-1) *cellSizeY
          image := Cells[i][image]
          RGBToRaster(image[pixelArray],cellRaster)
          copy.raster(cellRaster,x,y,0,0,raster)
  :
  PROC UpDate(VAL INT id, INT popu, INT xLoc,yLoc,nbVoisinsMer)
    CellPosition position,cell:
    CellImage image:
    [cellSizeY][cellSizeX] INT cellRaster:
    INT colour, width, height:
    INT x,y:
    INT xOffset,yOffset:
    INT xRand,yRand,seed,identity:
    SEQ
      -- position := Cells[id][position]
      GetIdFromLocation(xLoc,yLoc,identity)
      seed := identity
      cell := Cells[identity][position]
      x:=  (xLoc-1) *cellSizeX
      y:=  (yLoc-1) *cellSizeY
      image := Cells[identity][image]
      RGBToRaster(image[pixelArray],cellRaster)
      width := cellSizeX
      height := cellSizeY
      colour := COLOUR.RED
      IF
        nbVoisinsMer>0
          draw.rectangle (1, 1, width-2, height-2, colour,  cellRaster)
        TRUE
          SKIP
      colour := COLOUR.NAVY
      SEQ i=0 FOR popu*Density
        SEQ
          xRand,seed := random(cellSizeX, seed)
          yRand,seed := random(cellSizeY, seed)
          fill.circle.diameter(xRand,yRand,1, colour, cellRaster) 
      copy.raster(cellRaster,x,y,0,0,raster)
  :


  BYTE ch,digit:
  INT popu,xPos,yPos,xLoc,yLoc,idVal, idStored,nbVoisinsMer:
  BOOL ok:
  SEQ
    PrintSystem()
    popu:=0
    nbVoisinsMer := 0
    -- draw map for this cell no dot
    SEQ i=1 FOR ImageDimY
      SEQ j=1 FOR ImageDimX
        SEQ
          xLoc := j
          yLoc := i
          UpDate(0,popu,xLoc,yLoc,nbVoisinsMer)
    SEQ tour=0 FOR MaxTour
      SEQ
        SEQ i=0 FOR MaxNodes
          ALT canalIndex = 0 FOR SIZE fromProc
            fromProc [canalIndex] ? ch
              SEQ
                -- still debug information
                file.in.int (nbVoisinsMer , 5, ok,fromProc [canalIndex]) 
                file.in.int (xPos , 5, ok,fromProc [canalIndex]) 
                file.in.int (yPos , 5, ok,fromProc [canalIndex]) 
                file.in.int (xLoc , 5, ok,fromProc [canalIndex]) 
                file.in.int (yLoc , 5, ok,fromProc [canalIndex]) 
                file.in.int (idVal , 5, ok,fromProc [canalIndex]) 
                file.in.int (idStored , 5, ok,fromProc [canalIndex]) 
                file.in.int (popu , 5, ok,fromProc [canalIndex]) 
                --draw this cell, and plot population
                IF
                  popu>0
                    SEQ
                      UpDate(canalIndex,popu,xLoc,yLoc,nbVoisinsMer)
-- Adapt this if you need textual debug
--                      out ! 'X'
--                      out ! ' '
--                      out.number(canalIndex,6,out)
--                      out.number(xPos,6,out)
--                      out.number(yPos,6,out)
--                      out.number(xLoc,6,out)
--                      out.number(yLoc,6,out)
--                      out.number(popu,6,out)
--                      out ! '*n'
                  TRUE
                    SKIP
        -- output an image on a file        
        MakeString(tour, fileName, nameLen )
        fileName[nameLen] := (BYTE 0)
        out.string(fileName,nameLen,out)
        out ! '*n'
        write.raster.ppm(fileName,raster)
        out ! '*n'
:
