<?xml version="1.0"?><st-source><!-- Name: GHFindDialogNotice: © Copyright 2008-2012 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Author: Holger GuhlComment: This parcel implements a Find Dialog for VisualWorks text editors, designed to replace the simple find dialog from ParagraphEditor. Use of this advanced Find Dialog is configurable. See VisualWorksSettings page "Tools> Find Dialog".Features are known from various applications dealing with text, such as editors or internet browsers. The basic features provided are+ Input field for search string, combined with a Combobox remembering entered search strings+ Option checkboxes for selecting    - case-sensitive/-insensitive search   - word search   - wildcard match   - regular expression search, with the search string interpreted as regular expression to match      (this feature requires Regex support parcel from the distribution)+ Search buttons with search direction control (search forward or backward)The new FindDialog stays opened as long as the user does not close with an extra Cancel button (opposed to the default dialog from ParagraphEditor which accepts a single request, closes and processes the search operation). The user can proceed finding occurrences of the search string, while the dialog stays open and makes the underlying text editor track the selection according to found matches.A special feature is the match lookahead: The dialog automatically searches the next and the previous match, and enables search buttons accordingly. This gives immediate feedback for the user whether it is useful to request a next or previous search. The typical dialog after unsuccessful search ('no more matches found') is not necessary for this implementation.Author: Holger GuhlVersion history:===========================================================7.10 - 2	(23-MAY-2014) Maintenance: No longer call deprecated method ParagraphEditor class>>currentSelection===========================================================7.10 - 1	(27-FEB-2013) Internationalization: Open code for #ghFindDialog message catalogs===========================================================7.9 - 1	(16-MAR-2012)Update for VW 7.9 (shift editor implementation from ParagraphEditor to TextEditorController)Fix handling of initial search string for non-interactive #findAgain / #findAgainPrevious (policy setting was not used)===========================================================1.12	(8. Juni 2010)Updated the Copyright notice===========================================================1.11	(8. Juni 2010)++ Fix SubscriptOutOfBoundsError in FindInTableDialog- bad start point based on improper computation of selection index could have negative coordinates- #findNextMatch, #findPreviousMatch (use #selectionIndex or (if not assigned) #targetIndex; selectionChannel is not reliable)++ Enhance FindDialog API for non-interactive mode (reuse by other components)- #findNext(RestartFromTop), #findPrevious(RestartFromBottom) (return true/false for search success)- add #initForController: (extract from #openForController:find:)- add class #lastSearchString (access recently searched string)- #enableNextPreviousButtons:, #hideRolloverFeedback, #notifyRollover: (check for existence of widgets)- add #wrapperAt: (compatibility for VW versions prior to 7.4, where the method failed with absent builder)++ Enhance FindDialog: Add configurable policy for how to initialize the search string- add shared var. PolicyForInitialSearchString plus accessor #policyForInitialSearchString- add class #defaultPolicyForInitialSearchString (answer the default policy on the platform)- add class #initialStringToBeFoundForController: (evaluate initialization policy)- class #openCommonDialogForController: (apply initialization policy)- add VisualWorksSettings class #ghFindDialogSearchStringPolicy (settings page for new policy)- VisualWorksSettings class #ghFindDialogPage (use radio buttons for enumerations)++ Enhance ParagraphEditor to use FindDialog features for repeated search- override #findAgain / #findAgainPrevious (use FindDialog if preference is configured)- add #findAgainAdvanced, #findAgainPreviousAdvanced (methods to do advanced search with reuse of FindDialog)===========================================================1.10	(17. Juli 2009)Fix FindDialog>>findNextAndPreviousMatch (discard superfluous return)===========================================================1.9	(17. Juli 2009) Fixes, Optimizations, Enhance FindInListDialog to support RolloverPolicy, Add Finder for TableView++ Fix precheck: No longer show confusing wait cursor while  typing search pattern- add #precheckOccurrenceSilently (rename of #precheckOccurrence, w/o cursor, to be used in preemptive precheck)- add #precheckOccurrence (precheck with cursor, for non-preemptive precheck)++ Optimize FindInListDialog performance: Add found matches cache- add inst.var #matches, add #initialize, #resetMatchesCache (for initialization)- add #checkSelectionMatch, #checkSelectionMatchAtIndex: (complete match positions cache)- add #changedSearchOption, #changedSearchString (flush cache after search parameter changes)++ Enhance FindInListDialog to support RolloverPolicy- add #findNextRestartFromTop, #findPreviousRestartFromBottom (central roll-over action)- add #findAllMatchesInList:from:to:, #findUnknownMatchesFromTop, #findUnknownMatchesToEnd (complete match positions cache after roll-over)- add #precheckOccurrenceSilently (reimplement inherited)++ Add class FindInTableDialog (in-list finder for TableView)- add #findDialogClass in UI.TableView + UI.SelectionView (for package List-Utils to determine the proper in-list finder to be started from the utilities menu)++ Review FindDialog- update/refine FindDialog class comment- add #findNextMatch, #findPreviousMatch, #findNextAndPreviousMatch (polymorphic abstraction, for better reuse in class hierarchy)- add #finderDo:onRegexError: (new pattern for handling regex exceptions)- #positionTo: (add #precheckOccurrence; discard call from all other methods)- #findNextRestartFromTop, #findPreviousRestartFromBottom (discard call for precheck)- #findNext, #findPrevious (reuse new #findNextMatch / #findPreviousMatch)- #preBuildWith: (replace improper #and: with #ifTrue:)- REMOVED #getNextAndPreviousMatch, #getNextAndPreviousRegexMatch (replaced with #findNextAndPreviousMatch)++ Review FindInListDialog- add #findNextMatch, #findPreviousMatch (reimplement inherited)- add #listToBeExamined (abstract list access)- add #masterController: (initialize new inst.var. #selectionIndex from controller)- #positionTo: (add #precheckOccurrence; track selection index change in new inst.var. #selectionIndex)- REMOVED -  #findNext, #findPrevious (now inherited)-  #getNextAndPreviousMatch, #getNextAndPreviousRegexMatch (replaced with inherited #findNextAndPreviousMatch)===========================================================1.8	(21. September 2008) Fixes, Optimization+ Fix FindInListDialog>>positionTo: (MultiSelectionSequenceView selection could be left in inconsistent state)+ Fix FindInListDialog>>getNextAndPreviousMatch (use 'selectionChannel value'; #selectionIndex is not correct for MultiSelectionSequenceView)+ Fix FindInListDialog>>getNextAndPreviousRegexMatch (use #targetIndex for MultiSelectionSequenceView, #selectionIndex otherwise)+ Optimize FindDialog to use BackgroundSearchDriver for occurrence pre-check- new inst.var. searchDriver- #initialize adds BackgroundSearchDriver setup, #changedSearchString triggers search activity+ Optimize StringFinder regular expression search- add inst.var. StringFinder.rxMatcher to cache regular expression matcher for repeated application- add #rxMatcher (accessor for late initialization)- #stringToBeExamined: (inline flushing of occurrences cache, keep regular expression matcher cache)- #changedSearchOption, #changedSearchString (flush regular expression matcher cache)+ Optimize StringFinder occurrences finding- extend search method #find:start:stop:, add #find:start:stop:do: with new block argument allowing fast return on match- add #findRegex:start:stop:do: (analog to #find:start:stop:do:)- add #firstMatchPosition (do not search all occurrences, return first possible match)- #hasMatchWithString: (use new optimized method #firstMatchPosition)++ New: Enhance FindDialog feedback on bad regular expression pattern (warning triangle icon)- #getNextAndPreviousRegexMatch, +#warningForRegexException:, +#resetWarningForRegexException, class #optionsSpec, +#regexErrorIcon++ New: Add configurable FindDialog policy to stop search or continue at opposite text end (rollover at top or bottom of text)- shared var. #RolloverPolicy- #findNext, #findPrevious, #precheckOccurrence- add #findNextRestartFromTop, #findPreviousRestartFromBottom, #hideRolloverFeedback, #rolloverPolicy, #isRolloverDesired, #notifyRollover:- see Settings Tool, page "Tools" and "Find Dialog" (VisualWorksSettings class>>ghFindDialogUsage, #ghFindDialogRolloverPolicy)===========================================================1.7	(28. Februar 2008) FixesFix FindInListDialog getNextAndPreviousRegexMatch- UHE #selectionIndex sent to model (should be view) and index bounds violation ===========================================================1.6	(27. Februar 2008) Abolish cache for reused/common dialog; Fixes; add find support for UI lists+ Fix FindDialog>>acceptParameters (old version forgot to remember string to be found)+ Fix FindDialog>>noticeOfWindowClose:, #openDialogInterface: (release window kept by builder; we saw applications stuck to reused dialogs)+ Fix initial string to be found: #preBuildWith: should force first history entry if string to be found is empty+ Add class FindInListDialog to support find with options on GUI lists; see class comment for details+ Refactor #windowSpec[ForRequest]; extract common options widgets into one reusable subcanvas #optionsSpec+ Abolish reused dialog cache. Just keep options and history and open new dialogs with saved values- class>>commonDialog (create a new instance with remembered values)- add shared DefaultStringFinder (to keep recently used options) and ToBeFoundHistory (for common history)- add FindDialog>>stringFinder: (to assign cached options)REMOVED from FindDialog- shared CommonDialog- class>>releaseCommonDialog (no longer necessary)- class>>open:forController: (class based opener no longer supported)- class>>open:forController:find: (moved to instance side)===========================================================1.5	(20. Februar 2008) add StringFinder>>optionsString===========================================================1.4	(14. Februar 2008) Add hint on VisualWorksSettings page "Tools> Find Dialog".===========================================================1.3	(14. Februar 2008) Release as GH contribution- move classes FindDialog and StringFinder to namespace Heeg===========================================================1.2	(14. Februar 2008) Add config switch for overall use of FindDialog- add settings page in VisualWorksSettings===========================================================1.1	(13. Februar 2008) Review, Fixes- Fix minor layout mismatch- Fix "eternal" RxParser message in help text, which was not reset when disabling regex mode- Fix and improve various method comments (e.g. #acceptParameters, #preBuildWith:, #rememberSearchString)- Fix/Remove misplaced function return ^ in #beWordSearch:, #beWildcardSearch:, #beCaseSensitive:- Fix StringFinder>>release (keep start position)===========================================================1.0	(12. Februar 2008) first releaseDbIdentifier: magdi.heeg.de.postgresDbTrace: 48769DbUsername: holgerDbVersion: 7.10 - 2DevelopmentPrerequisites: #(#(#any 'Tools-Settings-VW' '') #(#any 'GHNamespaces' '') #(#any 'I18nRuntime' ''))DialectVersion: VisualWorks 7.9HideSource: falseMailto: Holger.Guhl@heeg.dePackageName: GHFindDialogParcel: #('GHFindDialog')ParcelDirectory: c:\visworks\vw8.0 sep14.2\image\HeegContributions-vw8.0-2014-09-25-2\GHFindDialogParcelName: GHFindDialogPrerequisiteDescriptions: #(#(#name 'Tools-Settings-VW') #(#name 'GHNamespaces') #(#name 'I18nRuntime' #componentType #package))PrerequisiteParcels: #(#('Tools-Settings-VW' '') #('GHNamespaces' '') #('I18nRuntime' ''))PrintStringCache: (7.10 - 2,holger)SaveSource: trueVersion: 7.10 - 2Date: 3:30:47 PM September 25, 2014 --><time-stamp>From VisualWorks®, 8.0 of 15. September 2014 on 25. September 2014 at 15:30:47</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StringFinder</name><environment>Heeg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>toBeFound toBeExamined startPosition isCaseSensitive isWordSearch isRegexSearch isWildcardSearch occurrences rxMatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HG-FindDialog</category><attributes><package>GHFindDialog</package></attributes></class><comment><class-id>Heeg.StringFinder</class-id><body>StringFinder is the helper or search agent for FindDialog. It serves as configurable and reusable part for finding occurrences of search strings within some larger text. The basic implementation supports the most common search modes - case-sensitive/-insensitive search - word search - wildcard match - regular expression search, with the search string interpreted as regular expression to match (requires the Regex support parcel from the distribution)A special feature is look-ahead to answer the question if there are next or previous occurrences after/before current search start position.Instance Variables:	isCaseSensitive	&lt;Boolean&gt;	switches case-sensitive or case-insensitive search mode	isRegexSearch	&lt;Boolean&gt;	switches regular expression search mode	isWildcardSearch	&lt;Boolean&gt;	switches wildcard search	isWordSearch 	&lt;Boolean&gt;	switches word search	occurrences	&lt;OrderedCollection of: Interval&gt;	chache for text positions or ranges where occurrences of search string has been found	rxMatcher 		&lt;RxMatcher&gt; 	cache for repeated application of the same regular expression	startPosition	&lt;Interval&gt; 	holds the start position for the next search; we use an Interval to model the text range of the match which is essential for regular expression match	toBeExamined	&lt;CharacterArray&gt;	holds the text to be scanned for occurrences of search strings	toBeFound	&lt;String&gt;	holds the string or search pattern to be found</body></comment><class><name>FindDialog</name><environment>Heeg</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stringFinder toBeFoundHistory searchDriver masterController </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HG-FindDialog</category><attributes><package>GHFindDialog</package></attributes></class><comment><class-id>Heeg.FindDialog</class-id><body>FindDialog is a VisualWorks implementation for a string finder dialog as it is very common for contemporary text applications. The implementation is thought as replacement for the simple find dialog known from ParagraphEditor. Features are known from various applications dealing with text, such as editors or internet browsers. The general purpose is - of course - locating a string interactively entered by the user in some larger text. The basic features provided are(1) Input field for string to be searched for(2) Combobox to remember a limited list of previously entered search strings(3) Option checkboxes for selecting 	- case-sensitive/-insensitive search	- word search	- wildcard match	- regular expression search, with the search string interpreted as regular expression to match	  (requires loading parcel Regex11 from the distribution)(4) Search buttons with search direction control (search forward or backward)The FindDialog stays opened as long as the user does not close with an extra Cancel button (opposed to the default dialog from ParagraphEditor which accepts a single request, closes and processes the search operation). The user can proceed finding occurrences of the search string, while the dialog stays open and makes the underlying text editor track the selection according to found matches.A special feature is the match lookahead: The dialog automatically searches the next and the previous match, and enables search buttons accordingly. This gives immediate feedback for the user whether it is useful to request a next or previous search. The typical dialog after unsuccessful search ('no more matches found') is not necessary for this implementation.This feature can be refined by configuration (see VisualWorks Settings, section "Tools", page "Find Dialog"). The setting for Rollover Policy can be- Rollover: Restart search at opposite end of text if a next match does not exist in the search direction- Stop (default): Do not rollover, stop searching at last match position and disable the button for finding another match if there is none in the search direction.Another setting is available to disable the use of FindDialog.Instance Variables:	masterController	&lt;ParagraphEditor&gt;	the underlying controller that holds the text to be scanned for occurrences of search strings; typically the requestor of the find dialog	searchDriver 	&lt;BackgroundSearchDriver&gt; 	when entering a string to be found we pre-check whether there are matches; we use background search technique to allow preempting the precheck while typing the searched string	stringFinder 	&lt;StringFinder&gt; 	helper for the working part of finding matches; holds all data and parameters (options) to do the search	toBeFoundHistory	&lt;ValueHolder on: (List of: String)&gt;	model of the Combobox to remember previously entered search strings</body></comment><class><name>FindInListDialog</name><environment>Heeg</environment><super>Heeg.FindDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionIndex stringAccessor matches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HG-FileUpdate</category><attributes><package>GHFindDialog</package></attributes></class><comment><class-id>Heeg.FindInListDialog</class-id><body>FindInListDialog is a specialization which collaborates with SequenceController/SequenceView. The idea is that every element in the underlying list has text to be examined for occurrence of text to be found. In the simplest case this will be the display string itself. To examine text different from plain display text we provide the option to configure the text access.The typical find operation is straight forward: First we try to find a list element that has an occurrence of the string to be found, then we select the element.The pre-check for next/previous occurrence is also available for list oriented search. But for huge lists we have seen significant time consumption. In order to speed up we avoid unnecessary search. A simple cache remembers match positions. On each next/previous match, we add the matching element index to the cache. Searching for the next/previous match first checks the cache for a remembered match index greater/less than the current position. Only if the check does not return a remembered match index, a search effectively takes places. It stops immediately at the next match and registers the successfully matched index. If no more matches are found in the search direction, this is remembered by adding 'list size+1' (find next) or 0 (find previous) to the cache. Since the FindInListDialog is modal, the cache grows incrementally from the "middle" (the initial selection index of the list controller). Each 'find next' reuses the cache or adds a high index on the "right"; each 'find previous' reuses the cache or adds a low index on the "left".Instance Variables:	matches	&lt;OrderedCollection of: (Integer | Point)&gt; 	cache match positions, i.e. indexes of list elements that matched the search criteria	selectionIndex	&lt;Integer | Point&gt;	the current selectionIndex of the underlying list controller	stringAccessor	&lt;Symbol&gt; 	defines how to access the string to be examined; the symbol is the name of a method sent to an element in the underlying list view, returning the string to be examined. If no string accessor is given we use the #displayString held by the sequence view</body></comment><class><name>FindInTableDialog</name><environment>Heeg</environment><super>Heeg.FindInListDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GHFindDialog</package></attributes></class><comment><class-id>Heeg.FindInTableDialog</class-id><body>FindInTableDialog is a specialization to support GeneralSelectionTableView, the lightweight GUI widget for tables. The selection and position model is based on Points - as opposed to SequenceView which works with Integer indexes.</body></comment><shared-variable><name>PolicyForInitialSearchString</name><environment>Heeg.FindDialog</environment><private>false</private><constant>false</constant><category>settings</category><initializer>#(#ControllerSelection #ClipboardContents #LastSearch) at: 1</initializer><attributes><package>GHFindDialog</package></attributes></shared-variable><shared-variable><name>ToBeFoundHistory</name><environment>Heeg.FindDialog</environment><private>false</private><constant>false</constant><category>reuse</category><initializer>List new</initializer><attributes><package>GHFindDialog</package></attributes></shared-variable><shared-variable><name>RolloverPolicy</name><environment>Heeg.FindDialog</environment><private>false</private><constant>false</constant><category>settings</category><initializer>#stop</initializer><attributes><package>GHFindDialog</package></attributes></shared-variable><shared-variable><name>DefaultStringFinder</name><environment>Heeg.FindDialog</environment><private>false</private><constant>false</constant><category>reuse</category><initializer>StringFinder new</initializer><attributes><package>GHFindDialog</package></attributes></shared-variable><shared-variable><name>UseAdvancedFindDialog</name><environment>UI.TextEditorController</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>GHFindDialog</package></attributes></shared-variable><methods><class-id>Heeg.StringFinder</class-id> <category>accessing</category><body package="GHFindDialog">isCaseSensitive: aBoolean 	"Configure option to do case-sensitive search according to &lt;aBoolean&gt;."	isCaseSensitive := aBoolean.	self changedSearchOption</body><body package="GHFindDialog">isRegexSearch: aBoolean 	"Configure option to do regular expression search according to &lt;aBoolean&gt;."	(aBoolean and: [#{RxParser} isDefined not]) 		ifTrue: 			[| msg |			msg := #RegularExpressionSupportNotLoaded &lt;&lt; #ghFindDialog 						&gt;&gt; 'Regular expression support not loaded'.			self error: msg asString].	isRegexSearch := aBoolean.	self changedSearchOption</body><body package="GHFindDialog">isWildcardSearch: aBoolean 	"Configure option to do wildcard-matching according to &lt;aBoolean&gt;."	isWildcardSearch := aBoolean.	self changedSearchOption</body><body package="GHFindDialog">isWordSearch: aBoolean 	"Configure option to do word-match search according to &lt;aBoolean&gt;."	isWordSearch := aBoolean.	self changedSearchOption</body><body package="GHFindDialog">optionsString	"Answer assigned search options as String::	- c = case-insensitive (default, may be omitted)	- C = case-sensitive	- w = no word match (default, may be omitted)	- W = word match	- * = wildcard match	- R = regular expression match "	| result |	result := (String new: 4) writeStream.	#(#isCaseSensitive #isWordSearch #isWildcardSearch #isRegexSearch) 		with: 'CW*R' asIs		do: 			[:test :optionChar | 			(self perform: test) 				ifTrue: [result nextPut: optionChar]				ifFalse: ["no output for option defaults"]].	^result contents</body><body package="GHFindDialog">startPosition	"Answer the start position.	This may either be an initial position or one from the last find operation.	Return: Interval"	^startPosition</body><body package="GHFindDialog">startPosition: integerOrInterval 	"Assign the startPosition for the next search.	The argument is an Interval to be compatible with find results.	We accept an Integer to specifiy a simple start index in the string to be examined."	startPosition := integerOrInterval isInteger 				ifTrue: [integerOrInterval to: integerOrInterval]				ifFalse: [integerOrInterval]</body><body package="GHFindDialog">stringToBeExamined	"Answer the string to be scanned for occurrences of search strings.	Return: CharacterArray"	^toBeExamined</body><body package="GHFindDialog">stringToBeExamined: aString 	"Assign the string to be scanned for occurrences of search strings."	toBeExamined := aString asString.	occurrences := nil.	self resetPosition</body><body package="GHFindDialog">stringToBeFound	"Answer the string or search pattern to be found.	Return: String"	^toBeFound</body><body package="GHFindDialog">stringToBeFound: aString 	"Assign the string or search pattern to be found."	toBeFound := aString asString.	self changedSearchString</body></methods><methods><class-id>Heeg.StringFinder</class-id> <category>testing</category><body package="GHFindDialog">hasMatchWithString: aString 	"This is a shortcut used for applying the receiver for repeated test on a list of strings:	Assign &lt;aString&gt; as string to be examined and check for match from the beginning.	Answer true if a match is found, false otherwise."	self stringToBeExamined: aString.	^self firstMatchPosition notNil</body><body package="GHFindDialog">hasNextMatchPosition	"Answer true if there is an occurrence of search pattern after current search start position.	Return: Boolean"	^self nextMatchPosition notNil</body><body package="GHFindDialog">isCaseSensitive	"Answer the value of option to do case-sensitive search.	Return: Boolean"	^isCaseSensitive</body><body package="GHFindDialog">isRegexSearch	"Answer the value of option to do regular expression search.	Return: Boolean"	^isRegexSearch</body><body package="GHFindDialog">isWildcardSearch	"Answer the value of option to do wildcard-match.	Return: Boolean"	^isWildcardSearch</body><body package="GHFindDialog">isWordSearch	"Answer the value of option to do word-match search.	Return: Boolean"	^isWordSearch</body></methods><methods><class-id>Heeg.StringFinder</class-id> <category>private</category><body package="GHFindDialog">changedSearchOption	"A search option has been changed. Flush occurrences cache."	occurrences := nil.	rxMatcher := nil</body><body package="GHFindDialog">changedSearchString	"The search pattern has been changed. Flush occurrences cache."	occurrences := nil.	rxMatcher := nil</body><body package="GHFindDialog">find: aString start: startInteger stop: stopInteger 	"Find next occurrence of &lt;aString&gt; within range defined by &lt;startInteger&gt; and &lt;stopInteger&gt;.	The search range restricts only the first match position, the last character of the match may be beyond stop.	Return: Interval (nil if no occurrence found)"	self 		find: aString		start: startInteger		stop: stopInteger		do: [:interval | ^interval].	^nil</body><body package="GHFindDialog">find: aString start: startInteger stop: stopInteger do: aBlock	"Find occurrences of &lt;aString&gt; within range defined by &lt;startInteger&gt; and &lt;stopInteger&gt;.	The search range restricts only the first match position, the last character of the match may be beyond stop.	For each match evaluate &lt;aBlock&gt; with the Interval with first/last position within the string to be examined.	Terminate the scan as soon as no more matches found or start &gt; stop, and return nil."	| start |	start := startInteger.		[| interval |	start &gt; stopInteger ifTrue: [^nil].	interval := self stringToBeExamined 				findString: aString				startingAt: start				ignoreCase: self isCaseSensitive not				useWildcards: self isWildcardSearch.	interval first isZero ifTrue: [^nil].	(self isWordSearch not or: [self isWordMatch: interval]) 		ifTrue: [aBlock value: interval].	start := interval first + 1] 			repeat</body><body package="GHFindDialog">findAllNormalOccurrences	"Find all simple (non regular-expression) occurrences of search pattern.	Return: OrderedCollection of: Interval"	| intervals |	intervals := OrderedCollection new.	self 		find: self stringToBeFound		start: 1		stop: self stringToBeExamined size		do: [:interval | intervals add: interval].	^intervals</body><body package="GHFindDialog">findAllRegexMatches	"Find all matches of regular expression search pattern.	Assume: Regex option is inhibited if parcel 'Regex11' is not loaded.	Return: OrderedCollection of: Interval	Exception: RxParser&gt;&gt;regexErrorSignal if string to be found is not a valid regular expression"	| intervals aString |	intervals := OrderedCollection new.	(aString := self stringToBeFound) isEmpty ifTrue: [^intervals].	self 		findRegex: aString		start: 1		stop: self stringToBeExamined size		do: [:interval | intervals add: interval].	^intervals</body><body package="GHFindDialog">findRegex: aString start: startInteger stop: stopInteger do: aBlock 	"Find matches of regular expression search pattern &lt;aString&gt; within range defined by &lt;startInteger&gt; and &lt;stopInteger&gt;.	The search range restricts only the first match position, the last character of the match may be beyond stop.	For each match evaluate &lt;aBlock&gt; with the Interval with first/last position within the string to be examined.	Terminate the scan as soon as no more matches found or start &gt; stop, and return nil.	Assume: Regex option is inhibited if parcel 'Regex11' is not loaded.	Exception: RxParser&gt;&gt;regexErrorSignal if string to be found is not a valid regular expression"	| aStream |	aString isEmpty ifTrue: [^nil].	aStream := self stringToBeExamined readStream.	aStream position: startInteger - 1.	self rxMatcher matchesOnStream: aStream		do: 			[:match | 			| start stop |			stop := aStream position.			start := stop - match size + 1.			start &gt; stopInteger ifTrue: [^nil].			aBlock value: (start to: stop)].	^nil</body><body package="GHFindDialog">isWordMatch: anInterval 	"The given interval is a match. Return true if it is a word match, false otherwise."	| aString start left stop right |	aString := self stringToBeExamined.	((start := anInterval first) &gt; 1 		and: [(left := aString at: start - 1) isLetter or: [left isDigit]]) 			ifTrue: [^false].	(stop := anInterval last) = aString size ifTrue: [^true].	^(right := aString at: stop + 1) isLetter not and: [right isDigit not]</body><body package="GHFindDialog">rxMatcher	"Answer the RxMatcher which finds regular expression matches.	Parsing the regex string and construction of a regex matcher is quite costly,	so we keep the matcher in a cache for repeated application on the same regular expression string."	^rxMatcher isNil 		ifTrue: 			[rxMatcher := self isCaseSensitive 						ifTrue: [self stringToBeFound asRegex]						ifFalse: [self stringToBeFound asRegexIgnoringCase]]		ifFalse: [rxMatcher]</body></methods><methods><class-id>Heeg.StringFinder</class-id> <category>initialize-release</category><body package="GHFindDialog">initialize	toBeFound := String new.	toBeExamined := String new.	self		setDefaultOptions;		resetPosition</body><body package="GHFindDialog">release	"Get rid of references to objects that usually are owned by others. 	Leave entered search string and option settings intact."	super release.	toBeExamined := String new.	occurrences := nil</body><body package="GHFindDialog">resetPosition	"Assign the initial position."	startPosition := 0 to: 0</body><body package="GHFindDialog">setDefaultOptions	"Initialize search options with common values: 	(1) case-insensitive, (2) no word search, (3) no wildcard match, (4) no regular expression search."	isCaseSensitive := false.	isWordSearch := false.	isWildcardSearch := false.	isRegexSearch := false</body><body package="GHFindDialog">setOptions: aString 	"Assign search options according to characters in &lt;aString&gt;:	- c = case-insensitive (default, may be omitted)	- C = case-sensitive	- w = no word match (default, may be omitted)	- W = word match	- * = wildcard match	- R = regular expression match "	| setters |	self setDefaultOptions.	setters := #(#isCaseSensitive: #isWordSearch: #isCaseSensitive: #isWordSearch: #isWildcardSearch: #isRegexSearch:).	aString do: 			[:char | 			| idx msg |			(idx := 'cwCW*R' asIs indexOf: char) = 0 				ifTrue: 					[msg := #InvalidStringFinderOption &lt;&lt; #ghFindDialog 								&gt;&gt; 'Invalid &lt;1s&gt; option "&lt;2p&gt;"' expandMacrosWith: self class name with: char.					self error: msg].			self perform: (setters at: idx) with: idx &gt; 2]</body></methods><methods><class-id>Heeg.StringFinder</class-id> <category>accessing-matches</category><body package="GHFindDialog">allOccurrences	"Find all simple occurrences or regular-expression matches of search pattern according to search mode.	Find matches and keep them in a local cache for repeated requests.	Return: OrderedCollection of: Interval"	^occurrences isNil 		ifTrue: 			[occurrences := self isRegexSearch 						ifTrue: [self findAllRegexMatches]						ifFalse: [self findAllNormalOccurrences]]		ifFalse: [occurrences]</body><body package="GHFindDialog">firstMatchPosition	"Find first occurrence of search pattern.	This is for optimized search that just wants to know whether there is at least one match.	Match positions are not cached.	Return: Interval (nil if no such position found)"	occurrences notNil ifTrue: [^occurrences notEmpty].	self isRegexSearch 		ifTrue: 			[self 				findRegex: self stringToBeFound				start: 1				stop: self stringToBeExamined size				do: [:interval | ^interval]]		ifFalse: 			[self 				find: self stringToBeFound				start: 1				stop: self stringToBeExamined size				do: [:interval | ^interval]].	^nil</body><body package="GHFindDialog">nextMatchPosition	"Find next occurrence of search pattern after current search start position.	Return: Interval (nil if no such position found)"	^self nextMatchPositionAfter: self startPosition</body><body package="GHFindDialog">nextMatchPositionAfter: anInterval 	"Answer the next occurrence of the string to be found after position &lt;anInteger&gt;.	Note: If the given interval end is zero, then we are right before the string to be found	and we may regard a match right at &lt;anInterval&gt; start as the next match.	Return: Interval (nil if no more occurrences found)"	| start noSelection |	start := anInterval first.	noSelection := anInterval last isZero.	^self allOccurrences detect: 			[:interval | 			interval first &gt; start or: [noSelection and: [interval first = start]]]		ifNone: []</body><body package="GHFindDialog">prevMatchPosition	"Find a previous occurrence of search pattern before current search start position.	Return: Interval (nil if no such position found)"	^self prevMatchPositionBefore: self startPosition</body><body package="GHFindDialog">prevMatchPositionBefore: anInterval 	"Answer the previous occurrence of the string to be found before position &lt;anInterval&gt;.	Return: Interval (nil if no such occurrence found)"	| start all idx |	(start := anInterval first) &lt;= 1 ifTrue: [^nil].	all := self allOccurrences.	idx := all findLast: [:interval | interval first &lt; start].	^idx isZero ifTrue: [] ifFalse: [all at: idx]</body></methods><methods><class-id>Heeg.StringFinder</class-id> <category>actions</category><body package="GHFindDialog">findNext	"Find next occurrence of search pattern after current search start position.	If successful, change start position to the match position.	Return: Interval (nil if no such position found)"	| next |	(next := self nextMatchPosition) notNil ifTrue: [self startPosition: next].	^next</body><body package="GHFindDialog">findPrevious	"Find previous occurrence of search pattern before current search start position.	If successful, change start position to the match position.	Return: Interval (nil if no such position found)"	| prev |	(prev := self prevMatchPosition) notNil ifTrue: [self startPosition: prev].	^prev</body></methods><methods><class-id>Heeg.StringFinder class</class-id> <category>instance creation</category><body package="GHFindDialog">new	^super new initialize</body><body package="GHFindDialog">withOptions: aString 	"Answer a new instance with search options assigned according to &lt;aString&gt;."	^self new setOptions: aString</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>accessing</category><body package="GHFindDialog">masterController: aController 	"Assign the text controller that called this dialog to help searching."	masterController := aController</body><body package="GHFindDialog">startPosition	"Answer the start position.	This may either be an initial position or the one from the last find operation.	Return: Interval"	^self stringFinder startPosition</body><body package="GHFindDialog">startPosition: integerOrInterval 	"Assign the startPosition for the next search.	The argument is an Interval to be compatible with find results.	We accept an Integer to specifiy a simple start index in the string to be examined."	self stringFinder startPosition: integerOrInterval</body><body package="GHFindDialog">stringFinder	"Answer the StringFinder used as helper/agent to lookup matching text positions.	Return: StringFinder"	^stringFinder</body><body package="GHFindDialog">stringToBeExamined	"Answer the string to be scanned for occurrences of search strings.	Return: String"	^self stringFinder stringToBeExamined</body><body package="GHFindDialog">stringToBeExamined: aString 	"Assign the string to be scanned for occurrences of search strings."	self stringFinder stringToBeExamined: aString</body><body package="GHFindDialog">stringToBeFound	"Answer the string or search pattern to be found.	Return: String"	^self stringFinder stringToBeFound</body><body package="GHFindDialog">stringToBeFound: aString 	"Assign the string or search pattern to be found."	self stringFinder stringToBeFound: aString</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>testing</category><body package="GHFindDialog">isCaseSensitive	"Answer the value of the option to do case-sensitive search.	Return: Boolean"	^self stringFinder isCaseSensitive</body><body package="GHFindDialog">isRegexSearch	"Answer the value of the option to do regular expression search.	Return: Boolean"	^self stringFinder isRegexSearch</body><body package="GHFindDialog">isRolloverDesired	"Answer whether rollover policy demands to rollover, i.e. restart search at opposite end of text."	^self rolloverPolicy == #rollover</body><body package="GHFindDialog">isWildcardSearch	"Answer the value of the option to do wildcard-match search.	Return: Boolean"	^self stringFinder isWildcardSearch</body><body package="GHFindDialog">isWordSearch	"Answer the value of the option to do word-match search.	Return: Boolean"	^self stringFinder isWordSearch</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>interface opening</category><body package="GHFindDialog">openDialogForRequestOnCancel: aBlock 	"Open the receiver in request mode, i.e. just accept search options without performing search.	The dialog should be preconfigured by the caller.	Return: FindDialog (with options set by the user) | nil (if user cancels request)."	| accepted |	accepted := self openDialogInterface: #windowSpecForRequest.	^accepted ifTrue: [self] ifFalse: [aBlock value]</body><body package="GHFindDialog">openDialogInterface: aSymbol 	"s. super implementor; enforce #preBuildWith:/#postBuildWith:, release string finder references afterwards."	| dialog |	(dialog := SimpleDialog new)		preBuildBlock: [:dlg :bld | self preBuildWith: bld];		postBuildBlock: [:dlg :bld | self postBuildWith: bld].	self builder: dialog builder.	^[dialog openFor: self interface: aSymbol] 		ensure: [self noticeOfWindowClose: nil]</body><body package="GHFindDialog">openForController: aController find: aString	"Open this FindDialog to help &lt;aController&gt; finding strings entered by the user.	Start with selection range of &lt;aController&gt; as start position, show &lt;aString&gt; as initial search string.	Return: FindDialog"	^self		initForController: aController;		stringToBeFound: aString;		openDialogInterface: #windowSpec;		yourself</body><body package="GHFindDialog">postBuildWith: aBuilder 	"We want continuous accept on the input field for the string to be found.	Make the regex match button visible if Regular Expression support is loaded."	super postBuildWith: aBuilder.	(aBuilder componentAt: #txtSearchString) widget controller 		continuousAccept: true.	(aBuilder componentAt: #cbRegex) isVisible: #{RxParser} isDefined.	self changedSearchString.	"enforce pre-check and button enablement"	self changedSearchOption	"enforce check box enablement"</body><body package="GHFindDialog">preBuildWith: aBuilder 	"Install the ValueHolder required by StringFinder attribute widgets.	Thus the builder will not send #stringFinder, expecting a ValueHolder,	and we can implement #stringFinder to return the StringFinder directly, 	without the need of appending #value to get the instance."	super preBuildWith: aBuilder.	aBuilder aspectAt: #stringFinder put: self stringFinder asValue.	self stringToBeFound isEmpty 		ifTrue: 			[| list |			(list := self toBeFoundHistory value) notEmpty 				ifTrue: [self stringToBeFound: list first]]</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>aspects</category><body package="GHFindDialog">changedSearchOption	"A search option has been changed. Check whether next or previous find are possible.	Additionally, disable options for word and wildcard match, if regex search is checked."	| regex |	regex := self isRegexSearch.	#(#cbWordMatch #cbWildcardMatch) 		do: [:aSymbol | (self wrapperAt: aSymbol) isEnabled: regex not].	self resetWarningForRegexException. 	"reset possible error text from RxParser error"	self precheckOccurrence</body><body package="GHFindDialog">changedSearchString	"This is the change notification callback from the ComboBox to enter the string to be found.	The search pattern has been changed. Check whether next or previous find are possible.	Use BackgroundSearchDriver to allow preempting pre-check with continued search pattern input."	self resetWarningForRegexException. 	"reset possible error text from RxParser error"	self enableNextPreviousButtons: #(nil nil). 	"block find buttons while searching"	searchDriver searchBlock: [:s2bFound | self precheckOccurrenceSilently].	searchDriver patternChanged.	self enableAcceptButton: self stringToBeFound notEmpty</body><body package="GHFindDialog">toBeFoundHistory	"Answer the ValueHolder with the list of recently used search patterns.	Return: ValueHolder on: (List of: String)"	^toBeFoundHistory isNil 		ifTrue: [toBeFoundHistory := List new asValue]		ifFalse: [toBeFoundHistory]</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>private</category><body package="GHFindDialog">enableAcceptButton: aBoolean 	"Enable/disable accept button (if available) according to &lt;aBoolean&gt;.	Note: The accept button is available only in request mode."	| btn |	(btn := self builder componentAt: #btnAccept) notNil 		ifTrue: [btn isEnabled: aBoolean]</body><body package="GHFindDialog">enableNextPreviousButtons: nextAndPrevious 	"The argument is an Array with Intervals found as next/previous find position, each of them may be nil.	Enable buttons to find next/previous position according to the matching interval; disable if the interval is nil.	Note: In request mode, these buttons are not existent."	self builder isNil ifTrue: [^self 	"non-interactive mode"].	nextAndPrevious with: #(#btnFindNext #btnFindPrevious)		do: 			[:anInterval :aSymbol | 			| btn |			(btn := self wrapperAt: aSymbol) notNil 				ifTrue: [btn isEnabled: anInterval notNil]]</body><body package="GHFindDialog">hideRolloverFeedback	"Make the label component to give user feedback invisible."	| widget |	(widget := self widgetAt: #lblFeedback) notNil 		ifTrue: [widget isVisible: false]</body><body package="GHFindDialog">notifyRollover: aSymbol 	"Give feedback for the user that a rollover has happened, i.e. search restarted at opposite end of text.	&lt;aSymbol&gt; = #findNext means that the rollover is forward, otherwise it is back from high position to end of text."	| restartFromTop iconName anOpaqueImageWithEnablement widget |	restartFromTop := aSymbol == #findNext.	iconName := restartFromTop ifTrue: [#toTopOfText] ifFalse: [#toEndOfText].	anOpaqueImageWithEnablement := ToolbarIconLibrary visualFor: iconName.	(widget := self widgetAt: #lblFeedback) isNil ifTrue: [^self].	widget		label: anOpaqueImageWithEnablement;		isVisible: true</body><body package="GHFindDialog">rememberSearchString	"Add the current search pattern to the history of recently used search patterns.	Add with policy MRU (most recently used), i.e. insert at front; discard old entries exceeding search history size."	| aString theList |	aString := self stringToBeFound.	(theList := self toBeFoundHistory value)		remove: aString ifAbsent: [];		addFirst: aString.	theList size &gt; self class searchHistorySize ifTrue: [theList removeLast]</body><body package="GHFindDialog">resetWarningForRegexException	"Hide the icon to signal a regex syntax error; reset help texts to display the error."	| widget |	(widget := self widgetAt: #cbRegex) isNil ifTrue: [^self].	widget helpText: nil.	self setHelpTextForSearchString: nil.	widget := self widgetAt: #lblRegexError.	widget isVisible: false</body><body package="GHFindDialog">rolloverPolicy	"Answer how to proceed if last search did not find a match in search direction:	- #rollover = restart at opposite end of text, i.e. position to first/last occurrence when searching next/previous	- #stop "	^RolloverPolicy</body><body package="GHFindDialog">setHelpTextForSearchString: aString 	"Assign the fly-by help text of the input field for the search string."	| aComboBoxView |	aComboBoxView := self widgetAt: #txtSearchString.	aComboBoxView editor helpText: aString</body><body package="GHFindDialog">warningForRegexException: anException 	"A Regex exception has occurred. Give feedback by showing a warning icon.	Set the error message as help text of the search string input field help text (avoid opening a warning dialog)."	| msg widget |	msg := #SyntaxErrorInRegularExpression &lt;&lt; #ghFindDialog 				&gt;&gt; 'Not a proper regular expression (&lt;1s&gt;)' 					expandMacrosWith: anException description.	self setHelpTextForSearchString: msg.	(widget := self widgetAt: #lblRegexError) isNil ifTrue: [^self].	widget isVisible: true.	(widget := self widgetAt: #cbRegex) helpText: msg</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>actions</category><body package="GHFindDialog">acceptParameters	"This is the OK button action to accept current input. It is only available in modal dialog for request mode.	Remember that in this case FindDialog is embedded in a SimpleDialog with accept/cancel/close channel.	We trigger the accept ValueHolder which makes the SimpleDialog close."	self rememberSearchString.	(self builder aspectAt: #accept) value: true</body><body package="GHFindDialog">cancel	"Close the finder window."	^self closeRequest</body><body package="GHFindDialog">findNext	"Find next occurrence of search pattern. Advance search start position to the position of the match.	Answer true if an occurrence was found, false otherwise."	| next rollover |	self rememberSearchString.	rollover := self isRolloverDesired.	(next := self findNextMatch) isNil 		ifTrue: 			[rollover ifFalse: [^false].			^self findNextRestartFromTop].	rollover ifTrue: [self hideRolloverFeedback].	self positionTo: next.	^true</body><body package="GHFindDialog">findPrevious	"Find previous occurrence of search pattern. Go back with search start position to the position of the match.	Answer true if an occurrence was found, false otherwise."	| prev rollover |	self rememberSearchString.	rollover := self isRolloverDesired.	(prev := self findPreviousMatch) isNil 		ifTrue: 			[rollover ifFalse: [^false].			^self findPreviousRestartFromBottom].	rollover ifTrue: [self hideRolloverFeedback].	self positionTo: prev.	^true</body><body package="GHFindDialog">positionTo: anInterval 	"Set own start position to &lt;anInterval&gt; and let the master controller select accordingly."	self stringFinder startPosition: anInterval.	masterController notNil 		ifTrue: [masterController selectAndScrollFrom: anInterval first to: anInterval last].	self precheckOccurrence</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>initialize-release</category><body package="GHFindDialog">initForController: aController	"Setup the receiver to help &lt;aController&gt; finding strings. Use &lt;aController&gt;'s selection range as start position."	| selectRange |	selectRange := aController selectionStartIndex to: aController selectionStopIndex - 1.	self		masterController: aController;		stringToBeExamined: aController text;		startPosition: selectRange</body><body package="GHFindDialog">initialSearchStringForController: aController	"Determine the initial search string, in particular for non-interactive mode and find-again requests.	The PolicyForInitialSearchString setting tells the preference. If the policy determines an empty search word,	we continue with the last search word because it makes no sense to continue searching without pattern."	| lastSearchString policy initialSearchString |	lastSearchString := self class lastSearchString.	policy := self class policyForInitialSearchString.	initialSearchString := policy == #ControllerSelection				ifTrue: [aController selection]				ifFalse: 					[policy == #ClipboardContents						ifTrue: [TextEditorController currentSelection asString]						ifFalse: [lastSearchString]].	^initialSearchString isEmpty ifTrue: [lastSearchString] ifFalse: [initialSearchString]</body><body package="GHFindDialog">initialize	"Use BackgroundSearchDriver for occurrence pre-check. 	This allows preempting the search while typing the search pattern, especially when finding in large text.	We have seen significant delays when finding in texts larger than 1 MB.	Neither BackgroundSearchDriver patternHolder is needed (we trigger search ativity explicitly via local change callback)	nor resultHolder (result evaluation is done at the end of our search block).	For details see #changedSearchString."		super initialize.	stringFinder := StringFinder new.	(searchDriver := BackgroundSearchDriver new) 		patternHolder: nil asValue		resultHolder: [:results | ]</body><body package="GHFindDialog">initializeSearchStringForControllerAndPolicy	"Determine the initial search string, in particular for non-interactive mode and find-again requests.	The PolicyForInitialSearchString setting tells the preference. If the policy determines an empty search word,	we continue with the last search word because it makes no sense to continue searching without pattern."	| initialSearchString |	initialSearchString := self initialSearchStringForController: masterController.	self stringToBeFound: initialSearchString</body><body package="GHFindDialog">stringFinder: aStringFinder 	"Assign the StringFinder (i.e. the search options) to be used.	This is useful if you want to feed reused options or different match algorithms into your dialog.	Note: This must be called after #initialize (which initializes the inst.var.) and before #preBuildWith:."	stringFinder := aStringFinder</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>interface closing</category><body package="GHFindDialog">noticeOfWindowClose: aWindow 	"Release references to other objects."	masterController := nil.	searchDriver release.	self stringFinder release.	self builder setWindow: nil.	super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>accessing-options</category><body package="GHFindDialog">beCaseSensitive: aBoolean 	"Configure option to do case-sensitive search according to &lt;aBoolean&gt;."	self stringFinder isCaseSensitive: aBoolean</body><body package="GHFindDialog">beRegexSearch: aBoolean 	"Configure option to do regular expression search according to &lt;aBoolean&gt;."	self stringFinder isRegexSearch: aBoolean</body><body package="GHFindDialog">beWildcardSearch: aBoolean 	"Configure option to do wildcard-match according to &lt;aBoolean&gt;."	self stringFinder isWildcardSearch: aBoolean</body><body package="GHFindDialog">beWordSearch: aBoolean 	"Configure option to do word-match search according to &lt;aBoolean&gt;."	self stringFinder isWordSearch: aBoolean</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>private-finding</category><body package="GHFindDialog">findNextAndPreviousMatch	"For pre-check: Retrieve next and previous match positions."	^self finderDo: 			[| next prev |			next := self findNextMatch.			prev := self findPreviousMatch.			Array with: next with: prev]		onRegexError: 			[:ex | 			self warningForRegexException: ex.			ex return: #(nil nil)]</body><body package="GHFindDialog">findNextMatch	"Delegate to StringFinder to find the next occurrence of search pattern after current search start position.	Return: Interval (nil if no match found)"	^self stringFinder nextMatchPosition</body><body package="GHFindDialog">findNextRestartFromTop	"Find next occurrence of search pattern. Start searching from top of text.	Advance search start position to the position of the match.	Answer true if an occurrence was found, false otherwise."	| next |	(next := self stringFinder nextMatchPositionAfter: (0 to: 1)) isNil 		ifTrue: [^false].	next = self stringFinder startPosition ifTrue: [^true].	self notifyRollover: #findNext.	self positionTo: next.	^true</body><body package="GHFindDialog">findPreviousMatch	"Delegate to StringFinder to find the previous occurrence of search pattern before current search start position.	Return: Interval (nil if no match found)"	^self stringFinder prevMatchPosition</body><body package="GHFindDialog">findPreviousRestartFromBottom	"Find previous occurrence of search pattern. Start searching from bottom of text. 	Go back with search start position to the position of the match.	Answer true if an occurrence was found, false otherwise."	| sz prev |	sz := self stringToBeExamined size.	(prev := self stringFinder prevMatchPositionBefore: (sz to: sz)) isNil 		ifTrue: [^false].	prev = self stringFinder startPosition ifTrue: [^true].	self notifyRollover: #findPrevious.	self positionTo: prev.	^true</body><body package="GHFindDialog">finderDo: aBlock onRegexError: exceptionBlock 	"Perform &lt;aBlock&gt; with StringFinder search operation.	Searching for a regular expression may raise RxParser&gt;&gt;regexErrorSignal if input is not a valid regular expression.	Handle such an exception by evaluating &lt;exceptionBlock&gt;.	Answer the result of &lt;aBlock&gt;."	self isRegexSearch ifFalse: [^aBlock value].	"Assume: Button enablement prevents from arriving here if Regular expression support is not loaded."	^aBlock on: #{RxParser} value regexErrorSignal do: exceptionBlock</body><body package="GHFindDialog">precheckOccurrence	"Check whether next or previous find are possible and enable/disable find buttons accordingly.	This method is for use cases where the user should know that he must wait. Show the wait Cursor."	Cursor execute showWhile: [self precheckOccurrenceSilently]</body><body package="GHFindDialog">precheckOccurrenceSilently	"Check whether next or previous find are possible and enable/disable find buttons accordingly.	This method is for internal use cases (background search). No wait Cursor to be shown."	| nextAndPrevious |	nextAndPrevious := self findNextAndPreviousMatch.	self isRolloverDesired 		ifTrue: 			[| sf sz next prev |			sf := self stringFinder.			self finderDo: 					[(nextAndPrevious first isNil and: 							[(next := sf nextMatchPositionAfter: (0 to: 1)) notNil 								and: [next ~= sf startPosition]]) 						ifTrue: [nextAndPrevious at: 1 put: next].					(nextAndPrevious last isNil and: 							[sz := self stringToBeExamined size.							(prev := sf prevMatchPositionBefore: (sz to: sz)) notNil 								and: [prev ~= sf startPosition]]) 						ifTrue: [nextAndPrevious at: 2 put: prev]]				onRegexError: 					[:ex | 					self warningForRegexException: ex.					ex return].			nextAndPrevious = #(nil nil) ifTrue: [self hideRolloverFeedback]].	self enableNextPreviousButtons: nextAndPrevious</body></methods><methods><class-id>Heeg.FindDialog</class-id> <category>view accessing</category><body package="GHFindDialog">wrapperAt: aSymbol 	"see super implementor; answer nil if there is no builder."	^builder isNil ifTrue: [] ifFalse: [super wrapperAt: aSymbol]</body></methods><methods><class-id>Heeg.FindDialog class</class-id> <category>constants</category><body package="GHFindDialog">searchHistorySize	"Answer the maximum number of search strings to remember in the search history list."	^20</body></methods><methods><class-id>Heeg.FindDialog class</class-id> <category>utility</category><body package="GHFindDialog">initialStringToBeFoundForController: aController	"Answer the string to be found according to PolicyForInitialSearchString and current controller."	| lastSearch policy theSelection |	lastSearch := self lastSearchString.	(policy := self policyForInitialSearchString) == #LastSearch		ifTrue: [lastSearch notEmpty ifTrue: [^lastSearch]].	policy == #ClipboardContents		ifTrue: [^TextEditorController currentSelection].	(aController isNil or: [(theSelection := aController selection) isEmpty])		ifTrue: [theSelection := TextEditorController currentSelection].	^theSelection</body><body package="GHFindDialog">openCommonDialogForController: aController 	"Open the commonly used FindDialog to help &lt;aController&gt; finding strings entered by the user.	The search string is initialized with controller's selection or (if empty) with current clipboard contents.	Return: FindDialog"	| searchString |	searchString := self initialStringToBeFoundForController: aController.	^self commonDialog openForController: aController find: searchString asString</body><body package="GHFindDialog">openForController: aController find: aString 	"Open a new Finder Dialog to help &lt;aController&gt; finding strings entered by the user."	^self new openForController: aController find: aString</body></methods><methods><class-id>Heeg.FindDialog class</class-id> <category>resources</category><body package="GHFindDialog">feedbackLabel	"Answer the image to show as special user feedback.	Define an empty image, just to make the builder happy.	Real feedback will use better images."	^Image extent: 0 @ 0 depth: 1 palette: MappedPalette whiteBlack</body><body package="GHFindDialog">regexErrorIcon	"Answer the icon to show if the regular expression entered by the user has a syntax error."	^ListIconLibrary visualFor: #warning</body></methods><methods><class-id>Heeg.FindDialog class</class-id> <category>accessing</category><body package="GHFindDialog">commonDialog	"Answer a newly created instance with search options from the last search.	Return: FindDialog"	| inst |	inst := self new.	inst stringFinder: DefaultStringFinder.	inst toBeFoundHistory value: ToBeFoundHistory.	^inst</body><body package="GHFindDialog">defaultPolicyForInitialSearchString	"This policy is platform dependent. On MacOS X, there is a system wide Clipboard for search terms. 	Searching for something in one application changes the search term in other applications as well.	On Windows the default search string is the current selection.	Return: one of #(#ControllerSelection #ClipboardContents #LastSearch)"	^(OSHandle currentPlatformID includes: 'MacOSX' asIs)		ifTrue: [#LastSearch]		ifFalse: [#ControllerSelection]</body><body package="GHFindDialog">lastSearchString	"Answer the string that was used during last search as string to be found.	Return: String (empty if history is empty)"	^ToBeFoundHistory isEmpty ifTrue: [String new] ifFalse: [ToBeFoundHistory first]</body><body package="GHFindDialog">policyForInitialSearchString	"Answer the policy how to initialize the search string when opening a FindDialog:	- Controller Selection: The currently selected text in the editor	- Clipboard Contents: Current contents of the global Clipboard	- Last Search String: The search string that was used during last search.	Return: one of #(#ControllerSelection #ClipboardContents #LastSearch)"	^PolicyForInitialSearchString</body></methods><methods><class-id>Heeg.FindInListDialog</class-id> <category>initialize-release</category><body package="GHFindDialog">initialize	super initialize.	self resetMatchesCache</body><body package="GHFindDialog">resetMatchesCache	"Discard all cached match positions."	matches := OrderedCollection new: 64</body><body package="GHFindDialog">stringAccessor: aSymbol 	"Assign the string accessor. It is the name of a method sent to an element in the underlying list view.	The method must return the string to be examined.	If no string accessor is given we use the displayString held by the sequence view."	stringAccessor := aSymbol</body></methods><methods><class-id>Heeg.FindInListDialog</class-id> <category>actions</category><body package="GHFindDialog">findNextRestartFromTop	"Find next occurrence of search pattern. Start searching from top of text.	Advance search start position to the position of the match.	Ensure that adding new match positions does not create holes between 	the 'known land' in the middle and the fringes near upper/lower bound."	| next |	(matches size &lt; 2 or: [matches first isZero not])		ifTrue: [^self 	"cache not safe for front part"].	(next := matches at: 2) &gt; selectionIndex		ifTrue: [^self 	"no next element between top of list and current position"].	self notifyRollover: #findNext.	self positionTo: next</body><body package="GHFindDialog">findPreviousRestartFromBottom	"Find previous occurrence of search pattern. Start searching from bottom of text. 	Go back with search start position to the position of the match.	Ensure that adding new match positions does not create holes between 	the 'known land' in the middle and the fringes near upper/lower bound."	| theList sz prev |	theList := self listToBeExamined.	((sz := matches size) &lt; 2 or: [matches last &lt;= theList size])		ifTrue: [^self 	"cache not safe for front part"].	(prev := matches at: sz - 1) &lt; selectionIndex		ifTrue: [^self 	"no previous element between end of list and current position"].	self notifyRollover: #findPrevious.	self positionTo: prev</body><body package="GHFindDialog">positionTo: anInteger 	"Set own start position to &lt;anInteger&gt; and let the master controller select accordingly."	masterController isNil ifTrue: [^self].	masterController requestValueChange ifFalse: [^self].	masterController		toggleAt: anInteger;		valueChange.	masterController view		targetIndex: anInteger;		makeVisible: anInteger.	selectionIndex := anInteger.	self precheckOccurrence</body></methods><methods><class-id>Heeg.FindInListDialog</class-id> <category>accessing</category><body package="GHFindDialog">listToBeExamined	"Answer the list to be scanned for occurrences of search strings.	Return: SequenceableCollection"	^masterController model value</body><body package="GHFindDialog">masterController: aController 	"Assign the list controller that called this dialog to help searching.	Initialize the current selection index according to the controllers selection."	| selection |	super masterController: aController.	selection := aController view selectionChannel value.	selectionIndex := selection isInteger 		ifTrue: [selection	"normal SelectionView, single select"]		ifFalse: [selection respondsToArithmetic 			ifTrue: [selection	"Point for GeneralSelectionTableView"]			ifFalse: [selection isEmpty ifTrue: [0] ifFalse: [selection asSortedCollection first]]]</body></methods><methods><class-id>Heeg.FindInListDialog</class-id> <category>aspects</category><body package="GHFindDialog">changedSearchOption	"See super implementor. Additionally flush matches cache.	Do super call at last, otherwise implicitly called #precheckOccurrence uses stale cache."	self resetMatchesCache.	self checkSelectionMatch.	super changedSearchOption</body><body package="GHFindDialog">changedSearchString	"See super implementor. Additionally flush matches cache.	Do super call at last, otherwise implicitly called #precheckOccurrence uses stale cache."	self resetMatchesCache.	self checkSelectionMatch.	super changedSearchString</body></methods><methods><class-id>Heeg.FindInListDialog</class-id> <category>private-finding</category><body package="GHFindDialog">checkSelectionMatch	"For pre-check: Check whether element at &lt;anInteger&gt; matches. 	Add the position to match cache if it matches. Answer true/false accordingly."	^self checkSelectionMatchAtIndex: selectionIndex</body><body package="GHFindDialog">checkSelectionMatchAtIndex: anInteger 	"For pre-check: Check whether element at &lt;anInteger&gt; matches. 	Add the position to match cache if it matches. Answer true/false accordingly."	| theList next |	anInteger isZero ifTrue: [^false].	(matches includes: anInteger) ifTrue: [^true].	theList := self listToBeExamined.	next := self finderDo: [self findMatchInList: theList from: anInteger to: anInteger]				onRegexError: 					[:ex | 					self warningForRegexException: ex.					ex return].	^next notNil and: [matches add: next. true]</body><body package="GHFindDialog">findAllMatchesInList: aList from: startIndex to: stopIndex 	"Run through the given list from &lt;startIndex&gt; to &lt;stopIndex&gt;.	For each element and its string check whether the stringFinder has a match.	Return all indexes of matching elements."	| result start next |	result := OrderedCollection new.	start := startIndex.		[start &lt;= stopIndex		and: [(next := self findMatchInList: aList from: start to: stopIndex) notNil]] 			whileTrue: 				[result add: next.				start := next + 1].	^result</body><body package="GHFindDialog">findMatchInList: aList from: startIndex to: stopIndex 	"Run through the given list from &lt;startIndex&gt; to &lt;stopIndex&gt;.	For each element and its string check whether the stringFinder has a match.	Return the index of the first element found in the given direction; return nil if no matching element found."	| step sf theView useDisplayString |	step := startIndex &lt; stopIndex ifTrue: [1] ifFalse: [-1].	sf := self stringFinder.	theView := masterController view.	useDisplayString := stringAccessor isNil.	startIndex to: stopIndex		by: step		do: 			[:idx | 			| aString |			aString := useDisplayString 						ifTrue: [theView displayStringAt: idx]						ifFalse: [(aList at: idx) perform: stringAccessor].			(sf hasMatchWithString: aString) ifTrue: [^idx]].	^nil</body><body package="GHFindDialog">findNextMatch	"Find the next occurrence of search pattern after current search start position.	Try to find a remembered match position from the cache, before really searching through the list.	Return: Integer (nil if no match found)"	| theList start max next |	theList := self listToBeExamined.	(start := selectionIndex) = (max := theList size)		ifTrue: ["at end of list, no further match is possible"]		ifFalse: 			[next := matches detect: [:anInteger | anInteger &gt; start]						ifNone: 							[next := self findMatchInList: theList from: start + 1 to: max.							next isNil ifTrue: [matches add: max + 1] ifFalse: [matches add: next]].			next &gt; max ifTrue: [next := nil]].	^next</body><body package="GHFindDialog">findPreviousMatch	"Find the previous occurrence of search pattern before current search start position.	Try to find a remembered match position from the cache, before really searching through the list.	Return: Integer (nil if no match found)"	| start theList prev |	(start := selectionIndex) &lt;= 1		ifTrue: ["at top of list, no previous match is possible"]		ifFalse: 			[prev := matches findLast: [:anInteger | anInteger &lt; start].			prev isZero				ifTrue:					[theList := self listToBeExamined.					prev := self findMatchInList: theList from: start - 1 to: 1.					prev isNil ifTrue: [matches addFirst: 0] ifFalse: [matches addFirst: prev]]				ifFalse: [(prev := matches at: prev) isZero ifTrue: [prev := nil]]].	^prev</body><body package="GHFindDialog">findUnknownMatchesFromTop	"Find all matches from top of list to the first cached match position.	Add new found matches to the cache. Add also the 0 to denote that the list has completely been searched from top.	Return: SequenceableCollection of: Integer"	| firstKnown theList stop newMatches |	matches isEmpty 		ifTrue: [firstKnown := selectionIndex]		ifFalse: 			[(firstKnown := matches first) isZero 				ifTrue: [^#()	"cache is complete for front part"]].	theList := self listToBeExamined.	stop := firstKnown isZero ifTrue: [theList size] ifFalse: [firstKnown - 1].	newMatches := stop &gt; 0 				ifTrue: 					[self 						findAllMatchesInList: theList						from: 1						to: stop]				ifFalse: [OrderedCollection new].	newMatches isEmpty 		ifTrue: [matches addFirst: 0]		ifFalse: 			[newMatches addFirst: 0.			matches := newMatches , matches.			newMatches removeFirst].	^newMatches</body><body package="GHFindDialog">findUnknownMatchesToEnd	"Find all matches after the last cached match position to the end of the list.	Add new found matches to the cache. Add also the element to denote that the list has completely been searched forward.	Return: SequenceableCollection of: Integer"	| lastKnown theList endOfList newMatches |	lastKnown := matches isEmpty ifTrue: [selectionIndex] ifFalse: [matches last].	theList := self listToBeExamined.	lastKnown &gt; (endOfList := theList size) ifTrue: [^#()	"cache is complete"].	newMatches := lastKnown &lt; endOfList 				ifTrue: 					[self 						findAllMatchesInList: theList						from: lastKnown + 1						to: endOfList]				ifFalse: [#()].	matches		addAll: newMatches;		add: endOfList + 1.	^newMatches</body><body package="GHFindDialog">precheckOccurrenceSilently	"See super implementor.	Ensure that adding new match positions does not create holes between 	the 'known land' in the middle and the fringes near upper/lower bound."	| nextAndPrevious |	nextAndPrevious := self findNextAndPreviousMatch.	self isRolloverDesired 		ifTrue: 			[| next prev sz |			self finderDo: 					[nextAndPrevious first isNil 						ifTrue: 							["no natural next match; try to find a match searching from top of list"							self findUnknownMatchesFromTop.							(matches size &gt; 1 and: [(next := matches at: 2) &lt; selectionIndex]) 								ifTrue: [nextAndPrevious at: 1 put: next]].					nextAndPrevious last isNil 						ifTrue: 							["no natural previous match; try to find a match searching backwards from end of list"							self findUnknownMatchesToEnd.							((sz := matches size) &gt; 1 								and: [(prev := matches at: sz - 1) &gt; selectionIndex]) 									ifTrue: [nextAndPrevious at: 2 put: prev]]]				onRegexError: 					[:ex | 					self warningForRegexException: ex.					ex return].			nextAndPrevious = #(nil nil) ifTrue: [self hideRolloverFeedback]].	self enableNextPreviousButtons: nextAndPrevious</body></methods><methods><class-id>Heeg.FindInListDialog</class-id> <category>interface opening</category><body package="GHFindDialog">openForController: aController find: aString 	"Reimplement inherited method which assumes that the controller is a ParagraphEditor.	The receiver collaborates with SequenceController only.	Return: self"	^self		masterController: aController;		stringToBeExamined: String new;		stringToBeFound: aString;		openDialogInterface: #windowSpec;		yourself</body></methods><methods><class-id>Heeg.FindInTableDialog</class-id> <category>testing</category><body package="GHFindDialog">isRolloverDesired	"Answer false. Rollover is not supported."	^false</body></methods><methods><class-id>Heeg.FindInTableDialog</class-id> <category>private-finding</category><body package="GHFindDialog">findMatchInList: aTableAdaptor from: startPoint to: stopPoint	"Run through the given list from &lt;startPoint&gt; to &lt;stopPoint&gt;.	For each element and its string check whether the stringFinder has a match.	Return the index of the first element found in the given direction; return nil if no matching element found."	| step sf theView useDisplayString startX |	step := startPoint &lt;= stopPoint ifTrue: [1] ifFalse: [-1].	sf := self stringFinder.	theView := masterController view.	useDisplayString := stringAccessor isNil.	startX := startPoint x.	startPoint y to: stopPoint y		by: step		do: 			[:rowIndex |			startX to: stopPoint x				by: step				do: 					[:colIndex |					| xy aString |					xy := colIndex @ rowIndex.					aString := useDisplayString								ifTrue: [theView displayStringAt: xy]								ifFalse: [(aTableAdaptor at: xy) perform: stringAccessor].					(sf hasMatchWithString: aString) ifTrue: [^xy]].			startX := step positive ifTrue: [1] ifFalse: [aTableAdaptor columnSize]].	^nil</body><body package="GHFindDialog">findNextMatch	"For pre-check: Retrieve next and previous match positions. Start at current selection index (point).	Search all table cells, each in a row before advancing to the next row."	| selectionPoint aTableAdaptor xColumns yRows start next |	(selectionPoint := masterController view selectionIndex) isZero		ifTrue: [selectionPoint := masterController view targetIndex].	aTableAdaptor := self listToBeExamined.	xColumns := aTableAdaptor columnSize.	yRows := aTableAdaptor rowSize.	start := selectionPoint x = xColumns		ifTrue: [1 @ (selectionPoint y + 1) 	"next row, column 1"]		ifFalse: [selectionPoint x + 1 @ (selectionPoint y max: 1) 	"next column, same row"].	next := start y &gt; yRows 		ifFalse: [self findMatchInList: aTableAdaptor from: start to: xColumns @ yRows].	^next</body><body package="GHFindDialog">findPreviousMatch	"For pre-check: Retrieve previous match position. Start at current selection index (point).	Search all table cells, each in a row before advancing to the next row."	| selectionPoint aTableAdaptor start |	(selectionPoint := masterController view selectionIndex) isZero		ifTrue: [selectionPoint := masterController view targetIndex].	aTableAdaptor := self listToBeExamined.	start := selectionPoint x = 1		ifTrue: [aTableAdaptor columnSize @ (selectionPoint y - 1) 	"previous row, last column"]		ifFalse: [selectionPoint x - 1 @ (selectionPoint y max: 1) 	"previous column, same row"].	^start y &lt; 1		ifTrue: [nil "at top of list; no previous match is possible"]		ifFalse: [self findMatchInList: aTableAdaptor from: start to: 1 @ 1]</body></methods><methods><class-id>UI.SelectionView</class-id> <category>accessing</category><body package="GHFindDialog">findDialogClass	"Answer the class to be used when running the GH FindDialog on the receiver."	^Heeg.FindInListDialog</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="GHFindDialog">find	"Open the find dialog. If the user picks Cancel, then do nothing.	Otherwise, search for the next occurrence of the text from the dialog."	| searchString whereToStart |	self useAdvancedFindDialog ifTrue: [^self openAdvancedFindDialog].	whereToStart := self selectionStopIndex.	self deselect.	searchString := self openFindOnlyDialog.	searchString == nil ifTrue: [^self select].	(self find: searchString startingAt: whereToStart)		ifFalse: [Dialog warn: (#notFound &lt;&lt; #dialogs &gt;&gt; 'Not found') for: view].	^self selectAndScroll</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>editing-functions</category><body package="GHFindDialog">findAgain	"Find the next instance after the selection of		a) the selection if it is non-empty		b) the paste buffer if the selection is empty	Override to use last FindDialog search settings to find the next occurrence."	| searchString |	self useAdvancedFindDialog ifTrue: [^self findAgainAdvanced].	searchString := self selection.	searchString isEmpty ifTrue: [searchString := self currentSelection].	self deselect.	(self find: searchString startingAt: self selectionStopIndex)		ifFalse: [Dialog warn: (#notFound &lt;&lt; #dialogs &gt;&gt; 'Not found') for: view].	^self selectAndScroll</body><body package="GHFindDialog">findAgainAdvanced	"Find the next occurrence according to last advanced search settings."	| theDialog |	(theDialog := Heeg.FindDialog commonDialog)		initForController: self;		stringToBeFound: theDialog class lastSearchString.	theDialog findNext ifFalse: [Dialog warn: (#notFound &lt;&lt; #dialogs &gt;&gt; 'Not found') for: view]</body><body package="GHFindDialog">findAgainPrevious	"Find the previous substring instance before 		a) the selection if it is non-empty		b) the paste buffer  if the selection is empty	Override to use last FindDialog search settings to find the next occurrence."	| searchString |	self useAdvancedFindDialog ifTrue: [^self findAgainPreviousAdvanced].	searchString := self selection.	searchString isEmpty ifTrue: [searchString := self currentSelection].	self deselect.	(self find: searchString startingAt: self selectionStopIndex - searchString size direction: false)		ifFalse: [Dialog warn: (#notFound &lt;&lt; #dialogs &gt;&gt; 'Not found') for: view].	^self selectAndScroll</body><body package="GHFindDialog">findAgainPreviousAdvanced	"Find the previous occurrence according to last advanced search settings."	| theDialog |	(theDialog := Heeg.FindDialog commonDialog)		initForController: self;		stringToBeFound: theDialog class lastSearchString.	theDialog findPrevious ifFalse: [Dialog warn: (#notFound &lt;&lt; #dialogs &gt;&gt; 'Not found') for: view]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>private</category><body package="GHFindDialog">openAdvancedFindDialog	"Open an advanced find dialog with search string history and options for search direction and matching.	If the user picks Cancel, or if the returned value is empty, then answer nil. Otherwise, answer the returned value."	Heeg.FindDialog openCommonDialogForController: self</body><body package="GHFindDialog">useAdvancedFindDialog	"Answer true if the advanced find dialog with search string history 	and options for search direction and matching should be used."	^TextEditorController basicNew useAdvancedFindDialog</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="GHFindDialog">find	"Open the find dialog. If the user picks Cancel, then do nothing.	Otherwise, search for the next occurrence of the text from the dialog."	| searchString whereToStart |	self useAdvancedFindDialog ifTrue: [^self openAdvancedFindDialog].	whereToStart := self selectionStopIndex.	self deselect.	searchString := self openFindOnlyDialog.	searchString == nil ifTrue: [^self select].	(self find: searchString startingAt: whereToStart)		ifFalse: [Dialog warn: #notFound &lt;&lt; #dialogs &gt;&gt; 'Not found' for: view].	^self selectAndScroll</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>editing-functions</category><body package="GHFindDialog">findAgain	"Find the next instance after the selection of		a) the selection if it is non-empty		b) the paste buffer if the selection is empty	Override to use last FindDialog search settings to find the next occurrence."	| searchString |	self useAdvancedFindDialog ifTrue: [^self findAgainAdvanced].	searchString := self selection.	searchString isEmpty ifTrue: [searchString := self currentSelection].	self deselect.	(self find: searchString startingAt: self selectionStopIndex)		ifFalse: [Dialog warn: #notFound &lt;&lt; #dialogs &gt;&gt; 'Not found' for: view].	^self selectAndScroll</body><body package="GHFindDialog">findAgainAdvanced	"Find the next occurrence according to last advanced search settings."	| theDialog |	(theDialog := Heeg.FindDialog commonDialog)		initForController: self;		initializeSearchStringForControllerAndPolicy.	theDialog findNext		ifFalse: [Dialog warn: #notFound &lt;&lt; #dialogs &gt;&gt; 'Not found' for: view]</body><body package="GHFindDialog">findAgainPrevious	"Find the previous substring instance before 		a) the selection if it is non-empty		b) the paste buffer  if the selection is empty	Override to use last FindDialog search settings to find the next occurrence."	| searchString |	self useAdvancedFindDialog ifTrue: [^self findAgainPreviousAdvanced].	searchString := self selection.	searchString isEmpty ifTrue: [searchString := self currentSelection].	self deselect.	(self		find: searchString		startingAt: self selectionStopIndex - searchString size		direction: false)			ifFalse: [Dialog warn: #notFound &lt;&lt; #dialogs &gt;&gt; 'Not found' for: view].	^self selectAndScroll</body><body package="GHFindDialog">findAgainPreviousAdvanced	"Find the previous occurrence according to last advanced search settings."	| theDialog |	(theDialog := Heeg.FindDialog commonDialog)		initForController: self;		initializeSearchStringForControllerAndPolicy.	theDialog findPrevious ifFalse: [Dialog warn: (#notFound &lt;&lt; #dialogs &gt;&gt; 'Not found') for: view]</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="GHFindDialog">openAdvancedFindDialog	"Open an advanced find dialog with search string history and options for search direction and matching.	If the user picks Cancel, or if the returned value is empty, then answer nil. Otherwise, answer the returned value."	Heeg.FindDialog openCommonDialogForController: self</body><body package="GHFindDialog">useAdvancedFindDialog	"Answer true if the advanced find dialog with search string history 	and options for search direction and matching should be used."	^UseAdvancedFindDialog = true</body></methods><methods><class-id>UI.TableView</class-id> <category>accessing</category><body package="GHFindDialog">findDialogClass	"Answer the class to be used when running the GH FindDialog on the receiver."	^Heeg.FindInTableDialog</body></methods><methods><class-id>Heeg.FindDialog class</class-id> <category>interface specs</category><body package="GHFindDialog">optionsSpec	"Tools.UIPainter new openOnClass: self andSelector: #optionsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage}	#key: #FindOptions	#defaultString: 'Find Options'	#catalogID: #ghFindDialog) 			#min: #(#{Core.Point} 350 100 ) 			#max: #(#{Core.Point} 600 100 ) 			#bounds: #(#{Graphics.Rectangle} 840 525 1190 625 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 0 0 ) 					#name: #cbCaseSensitive 					#model: #'stringFinder isCaseSensitive' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedSearchOption ) 					#label: #(#{Kernel.UserMessage}	#key: #CaseSensitive	#defaultString: 'Case sensitive'	#catalogID: #ghFindDialog) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 103 0 ) 					#name: #cbWordMatch 					#model: #'stringFinder isWordSearch' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedSearchOption ) 					#label: #(#{Kernel.UserMessage}	#key: #WordMatch	#defaultString: 'Word match'	#catalogID: #ghFindDialog) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 193 0 ) 					#name: #cbWildcardMatch 					#model: #'stringFinder isWildcardSearch' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedSearchOption ) 					#label: #(#{Kernel.UserMessage}	#key: #Wildcards	#defaultString: 'Wildcards'	#catalogID: #ghFindDialog) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 273 0 ) 					#name: #cbRegex 					#flags: 16 					#model: #'stringFinder isRegexSearch' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedSearchOption ) 					#label: #(#{Kernel.UserMessage}	#key: #Regex	#defaultString: 'Regex'	#catalogID: #ghFindDialog) ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 322 0 342 20 ) 					#name: #lblRegexError 					#flags: 16 					#label: #regexErrorIcon 					#hasCharacterOrientedLabel: false ) ) ) )</body><body package="GHFindDialog">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage}	#key: #Find	#defaultString: 'Find'	#catalogID: #ghFindDialog) 			#min: #(#{Core.Point} 350 100 ) 			#max: #(#{Core.Point} 600 100 ) 			#bounds: #(#{Graphics.Rectangle} -32000 -32000 -31650 -31900 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 27 0 ) 					#name: #txtSearchString 					#model: #'stringFinder stringToBeFound' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedSearchString ) 					#helpText: #(#{Kernel.UserMessage}	#key: #emptyString	#defaultString: ''	#catalogID: #ghFindDialog) 					#isReadOnly: false 					#comboList: #toBeFoundHistory ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 36 0 -5 1 60 0 ) 					#name: #optionsGroup 					#flags: 0 					#minorKey: #optionsSpec ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 -28 1 86 0 -5 1 ) 					#name: #btnFindNext 					#flags: 40 					#model: #findNext 					#label: #(#{Kernel.UserMessage}	#key: #FindNext	#defaultString: 'Find Next'	#catalogID: #ghFindDialog) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 96 0 -28 1 176 0 -5 1 ) 					#name: #btnFindPrevious 					#flags: 40 					#model: #findPrevious 					#label: #(#{Kernel.UserMessage}	#key: #FindPrevious	#defaultString: 'Find Previous'	#catalogID: #ghFindDialog) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -65 1 -28 1 -5 1 -5 1 ) 					#name: #btnCancel 					#model: #cancel 					#label: #(#{Kernel.UserMessage}	#key: #Cancel	#defaultString: 'Cancel'	#catalogID: #ghFindDialog) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutFrame} 180 0 -28 1 200 0 -6 1 ) 					#name: #lblFeedback 					#flags: 16 					#label: #feedbackLabel 					#hasCharacterOrientedLabel: false ) ) ) )</body><body package="GHFindDialog">windowSpecForRequest	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecForRequest"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage}	#key: #Find	#defaultString: 'Find'	#catalogID: #ghFindDialog) 			#min: #(#{Core.Point} 350 100 ) 			#max: #(#{Core.Point} 600 100 ) 			#bounds: #(#{Graphics.Rectangle} 840 605 1190 705 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 27 0 ) 					#name: #txtSearchString 					#model: #'stringFinder stringToBeFound' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedSearchString ) 					#helpText: #(#{Kernel.UserMessage}	#key: #emptyString	#defaultString: ''	#catalogID: #ghFindDialog) 					#isReadOnly: false 					#comboList: #toBeFoundHistory ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 36 0 -5 1 60 0 ) 					#name: #optionsGroup 					#flags: 0 					#minorKey: #optionsSpec ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 -28 1 66 0 -5 1 ) 					#name: #btnAccept 					#model: #acceptParameters 					#label: #(#{Kernel.UserMessage}	#key: #OK	#defaultString: 'OK'	#catalogID: #ghFindDialog) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 -28 1 140 0 -5 1 ) 					#name: #btnCancel 					#model: #cancel 					#label: #(#{Kernel.UserMessage}	#key: #Cancel	#defaultString: 'Cancel'	#catalogID: #ghFindDialog) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="GHFindDialog">textFind16x16	"Tools.UIMaskEditor new openOnClass: self andSelector: #textFind16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(321 321 321)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4786 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 8094 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(867 867 867)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6199 6970 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7837 7837 7837)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 6070 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 6584 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5396 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4657 4657 4657)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4978 4978 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1316 1316)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 1638 1638)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5203 5203 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5974 6809 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5524 5524 5524)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3083 3083)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LC@1LSD1LSD1LC@0LC@0LC@0LS@0LC@0LSD@LC@0LC@0LCD0LFA XCD0LP@0LC@0LC@0,C@0LC@0,NC 8C@0LC@0LQ@1HRD LC@0LE@0LC@0LCCPLC@0LC@0LC@PLC@0LC@0HDB (JB (JA@@C@0LC@0LLB@ HB@ HB@ @@0LC@0LCEAP@@0LC@0LTE@@C@0LCE@$IBP@C@0LTBP$I@@LCE@$C@0$I@@@TBPLCBP$@@1PI@0$IBP@O@@$CBP$I@@L@BP$IBP\@@0@IBP$IA0@C@0@IBP\@C0LC@@$IA0@O@0LC@@@@C0LC@0L@@@@O@0@a'))</body><body package="GHFindDialog">textFind16x16mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #textFind16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 31 192 0 0 31 224 0 0 31 240 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 252 0 0 63 254 0 0 127 255 0 0 127 255 0 0 127 127 0 0 63 63 0 0 30 30 0 0])</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="GHFindDialog">toEndOfText20x20	"UIMaskEditor new openOnClass: self andSelector: #toEndOfText20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 32 scaledGreen: 2601 scaledBlue: 6584); yourself)) usingBits: #[85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 106 149 0 0 0 85 85 85 85 101 0 0 0 85 0 0 85 101 0 0 0 85 85 85 85 101 0 0 0 85 0 0 85 101 0 0 0 85 85 85 85 101 0 0 0 85 0 0 85 101 0 0 0 85 85 85 85 101 0 0 0 85 0 0 86 101 0 0 0 85 85 85 90 101 0 0 0 85 0 0 106 149 0 0 0 85 85 85 90 85 0 0 0 85 85 85 86 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0])</body><body package="GHFindDialog">toEndOfText20x20mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #toEndOfText20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 0 64 0 15 240 64 0 0 0 64 0 15 240 64 0 0 0 64 0 15 240 64 0 0 0 64 0 15 241 64 0 0 3 64 0 15 247 128 0 0 3 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="GHFindDialog">toTopOfText20x20	"UIMaskEditor new openOnClass: self andSelector: #toTopOfText20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 32 scaledGreen: 2601 scaledBlue: 6584); yourself)) usingBits: #[85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 149 85 85 85 0 0 0 85 165 85 85 85 0 0 0 86 169 0 0 85 0 0 0 89 165 85 85 85 0 0 0 89 149 0 0 85 0 0 0 89 85 85 85 85 0 0 0 89 85 0 0 85 0 0 0 89 85 85 85 85 0 0 0 89 85 0 0 85 0 0 0 89 85 85 85 85 0 0 0 89 85 0 0 85 0 0 0 89 85 85 85 85 0 0 0 86 169 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0])</body><body package="GHFindDialog">toTopOfText20x20mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #toTopOfText20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 12 0 0 0 30 255 0 0 44 0 0 0 40 255 0 0 32 0 0 0 32 255 0 0 32 0 0 0 32 255 0 0 32 0 0 0 32 255 0 0 32 0 0 0 30 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-find dialog</category><body package="GHFindDialog">ghFindDialogPage	&lt;settingsPage: #(#tools #ghFindDialog)&gt;	^(ModularSettingsPage new)		label: #titleFindDialog &lt;&lt; #ghFindDialog &gt;&gt; 'Find Dialog';		icon: (ListIconLibrary visualFor: #textFind);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(#ghFindDialog))</body><body package="GHFindDialog">ghFindDialogRolloverPolicy	&lt;setting: #(#ghFindDialog #rolloverPolicy) position: 2&gt;	| typeDescription |	typeDescription := EnumerationSetting choices: #(#rollover #stop)				labels: (Array with: #Rollover &lt;&lt; #ghFindDialog &gt;&gt; 'Rollover'						with: #Stop &lt;&lt; #ghFindDialog &gt;&gt; 'Stop').	^(typeDescription on: #{Heeg.FindDialog.RolloverPolicy})		default: #stop;		label: #FindDialogRolloverPolicy &lt;&lt; #ghFindDialog &gt;&gt; 'RolloverPolicy';		helpText: #FindDialogRolloverPolicyHelpText &lt;&lt; #ghFindDialog					&gt;&gt; 'Defines how to proceed if no more occurrences of search string can be found:- Rollover: Restart at opposite end of text, i.e. position to first/last occurrence when searching next/previous- Stop: Do not rollover, stop searching at last match position.'</body><body package="GHFindDialog">ghFindDialogSearchStringPolicy	&lt;setting: #(#ghFindDialog #searchStringPolicy) position: 3&gt;	| typeDescription |	typeDescription := EnumerationSetting				choices: #(#ControllerSelection #ClipboardContents #LastSearch)				labels: (Array						with: #ControllerSelection &lt;&lt; #ghFindDialog &gt;&gt; 'Controller Selection'						with: #ClipboardContents &lt;&lt; #ghFindDialog &gt;&gt; 'Clipboard Contents'						with: #LastSearchString &lt;&lt; #ghFindDialog &gt;&gt; 'Last Search String').	^(typeDescription on: #{Heeg.FindDialog.PolicyForInitialSearchString})		default: Heeg.FindDialog defaultPolicyForInitialSearchString;		label: #FindDialogSearchStringPolicy &lt;&lt; #ghFindDialog					&gt;&gt; 'Initial Search String';		helpText: #FindDialogSearchStringPolicyHelpText &lt;&lt; #ghFindDialog					&gt;&gt; 'Defines which search string is used when the dialog is opened:- Controller Selection: The currently selected text in the editor- Clipboard Contents: Current contents of the global Clipboard- Last Search String: The search string that was used during the last search.'</body><body package="GHFindDialog">ghFindDialogUsage	&lt;setting: #(ghFindDialog usage) position: 1&gt;	^(BooleanSetting on: #{TextEditorController.UseAdvancedFindDialog})		default: true;		label: #UseAdvancedFindDialog &lt;&lt; #ghFindDialog 					&gt;&gt; 'Use Advanced FindDialog in all text editors';		helpText: #UseAdvancedFindDialogHelpText &lt;&lt; #ghFindDialog 					&gt;&gt; 'If true all text editors will use the advanced FindDialog on menu item ''Find...''.'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ParagraphEditor</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>TableView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state table columnInfo rowInfo selectionChannel selectionIndex targetIndex grid columnWidths rowHeights visualBlock textStyle displayStringSelector showCGrid showRGrid strokedSelection isSlave lpDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher selectable maxChars nextUndoBlock currentUndo </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>SelectionView</name><environment>UI</environment><super>UI.ScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence selectionChannel selectionIndex targetIndex grid textStyle displayStringSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class></st-source>