<?xml version="1.0"?><st-source><!-- Name: Xtreams-TerminalsNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: Terminals are the objects at the bottom of stream stacks. These are the ultimate sources of elements produced by read streams or ultimate consumers of elements written into write streams. This package provides support for various kinds of terminals available in VisualWorks. Eventual ports to other dialects may support different set of terminals although there will likely be significant overlap. However, implementations may have subtle differences as well. For example streams in Squeak/Pharo do not use become: when they grow the underlying collection of a collection stream. Therefore code assuming that identity of a collection stream terminal will be preserved may not be portable.	== Collections ==Collections are traditional stream terminals. Read streams are created by sending #reading to a collection.{{{	(1 to: 10000) reading ++ 1000; read: 5}}}Similarly write streams are created by sending #writing to a collection. The collection is grown automatically to accommodate any elements written. Closing a collection write stream will truncate the collection to the current stream position. This behavior is useful as a replacement for the traditional #contents message. The contents can be accessed with the #terminal message after the stream is closed. The advantage is that the sequence #close and #terminal (or the shortcut #conclusion) can be sent to arbitrary stream stack and behaves consistently.{{{	String new writing write: 'Hello World'; -  6; conclusion}}}Note that while the read streams generally require a sequenceable collection, the write streams allow non-sequenceable terminals as well.{{{	Bag new writing write: 'abbcccdaabdda'; conclusion}}}	== Block Closures ==Streaming over block closures is proving to be "xtremely" versatile tool, allowing to stream over result sets of arbitrary computations, modelling infinite streams, etc.{{{	"inifinite stream of ones"	[ 1 ] reading read: 20}}}{{{	"Fibonacci"	| a b | a := 0. b := 1.	[ | x | x := a. a := b. b := x + a. x ] reading ++ 500; get}}}{{{	"Streaming over ObjectMemory"	x := ObjectMemory someObject.	[ x := ObjectMemory nextObjectAfter: x ] reading read: 5}}}Single argument blocks can be used as read terminals too, which turn an iterative process in to a stream.{{{	"In this example, we have a -hard- loop, not using collection protocol, which will only run one element at a time."	[:out | 1 to: 10 do: [:i | out put: i]] reading read: 5.}}}Single argument blocks can be used as write terminals.{{{	"Transcript as an xtream"	[ :x | Transcript nextPut: x ] writing write: 'Hello World!'}}}{{{	"/dev/null"	[ :x | ] writing write: 'Hello World!'}}}Combined with stream transforms like #doing: and #limiting:, a block closure stream can be used to transform arbitrary loop into a stream and the streaming API can provide fine grained control over the execution of the loop body.	== Files ==File read streams are created by sending #reading to a Filename. However the actual terminal is an IOAccessor. The original filename is accessible through the IOAccessor.{{{	| file |	file := ObjectMemory imageName asFilename reading.	[ file read: 13 ] ensure: [ file close ]}}}As a convenience, sending #reading to a Filename of a directory will create a stream of all filenames in that directory.{{{	'/tmp' asFilename reading rest}}}File write streams can be created via the usual #writing message or via #appending which opens the file in appending mode. In appending mode, you cannot position the stream before the end of the file contents, so you can never overwrite existing contents. In writing mode, the file will be truncated at stream's current position when #close is called. To keep the entire contents of the file, use -= 0 to skip to the end before closing. This behavior is different from the classic streams which would erase the contents of the file on open.{{{	| file |	file := '/dev/shm/xtreams-test' asFilename.	[	file writing write: 'Hello'; close.		file appending write: ' World!'; close.		file contentsOfEntireFile.	] ensure: [ file delete ]}}}It is also possible to send #reading or #writing to a pre-opened IOAcccessor if some other opening mode configuration is desirable. For example to emulate the classic write stream opening behavior, you can use the following:{{{	(IOAccessor openFileNamed: '/dev/shm/xtreams-test' 		direction: IOAccessor writeOnly		creation: IOAccessor truncateOrCreate	) writing close}}}Bare file streams are always binary. An encoding transform has to be applied to translate bytes into characters, which is discussed in more detail in [Xtreams-Transforms]. However for some types of encoding it is possible to use ByteStrings instead of ByteArrays to get similar effect. E.g reading from a file into a ByteString is like applying ISO8859-1 encoding on the fly. It can also be quite a bit faster than full blown encoding layer. However it does not do line-end translation and only few single-byte encodings are available (see the ByteString hierarchy). Similarly writing into a bare file stream from a ByteString works as if the characters were automatically encoded with ISO-8859-1. This is again without line end translation, so normally you would end up with CRs (code 13) in your file, which these days does not match any OS convention (Unixes and MacOS use LF, and Windows uses CRLFs).{{{	| file header |	file := ObjectMemory imageName asFilename reading.	header := ByteString new writing.	[ header write: 20 from: file ] ensure: [ file close ].	header conclusion}}}	== Sockets and Pipes ==Sockets and Pipes are very similar, both accessed via IOAccessors again. The examples below show how data can be sent through a TCP or pipe connection by setting up a read stream and a write stream on a pair of connected accessors.{{{	[ :in :out |		[	out writing write: 'Hello'; close.			in reading read: 5		] ensure: [ in close. out close ]	] valueWithArguments: SocketAccessor openPair}}}{{{	[ :in :out |		[	out writing write: 'Hello'; close.			in reading read: 5		] ensure: [ in close. out close ]	] valueWithArguments: OSSystemSupport concreteClass pipeAccessorClass openPair}}}Same rules regarding binary vs text reading/writing applies to socket and pipe streams as was discussed with regards to file streams above.There is also a variation of these streams that allows to attach a specific timeout value to the stream. If a given read or write operation doesn't return within the specified timeout a Timeout exception is signaled. These streams are created with #reading: or #writing: message where the argument is the timeout duration.{{{	pipe := OSSystemSupport concreteClass pipeAccessorClass openPair.	[	(pipe first reading: 1 seconds) get	] ensure: [ pipe do: #close ]}}}Finally, note that unlike pipes, sockets are full-duplex, i.e. a socket is really two independent pipes one for each direction. Consequently closing a socket read or write stream does not close and release the socket itself. A stream close just shuts down the corresponding pipe (using the appropriate socket shutdown: call). It is important to explicitly close the socket itself when it is not needed anymore. 	== Buffers ==Buffers are used internally by Xtreams, but they could be useful in other circumstances too. There are several kinds and they can be used as both read and write stream terminals at the same time (not concurrently by multiple processes though, process synchronization has to managed explicitly via an external semaphore if necessary). For example writing into ElasticBuffer will grow it as much as necessary, but reading frees the space back up and it is immediately reused for further writes. So with interleaved reads and writes the size of the buffer will only grow to accommodate the maximum size written but not read yet.{{{	buffer := ElasticBuffer on: String new.	bufferIn := buffer writing.	bufferOut := buffer reading.	100000 timesRepeat: [ bufferIn write: 'Hello World'. bufferOut read: 11 ].	buffer cacheSize  }}}	== SharedQueues ==SharedQueues are primarily used for data transfer between processes, their API is rather spartan though. Streams over SharedQueues provide the convenience of full streaming API.{{{	queue := SharedQueue new.	in := queue reading.	out := queue writing.	received := Array new writing.	done := Semaphore new.	consumer :=			[ | size |			[	(size := in get) isZero			] whileFalse: [ | word |				word := ByteString new: size.				in read: size into: word.				received put: word ].			done signal.		] fork.	#(one two three four) do: [ :word | out put: word size; write: word ].	out put: 0.	done wait.	received conclusion}}}	== Exotic streams ==There are also a few special purpose terminal streams that could be useful at times.A random number read stream can be easily created from an instance of Random.{{{	Random new reading read: 10}}}An efficient stream of a constant (identical) object can be created with message #repeating. This stream is more efficient than equivalent block stream.{{{	String new writing write: 100 from: $- repeating; close; terminal}}}A write stream on Transcript allows using Xtreams APIs for simple transcript logging.{{{	Transcript writing cr; write: 'Hello World!'	}}}A special read stream on top of a listening socket provides a new socket for each incoming connection.{{{	| socket |	socket := SocketAccessor newTCP.	socket listenFor: 1.	[	socket accepting do: [:client | client close]	] ensure: [socket close]}}}A write stream on nil is a highly efficient bit bucket.{{{	nil writing write: Object comment}}}A reading stream on nil is the canonical empty stream{{{	nil reading rest}}}A read stream on a Context walks up the sender chain allowing for easy stack traversal.{{{	thisContext reading rest}}}A read stream on ObjectMemory enumerates all non-immediate objects in the image.{{{	ObjectMemory reading inject: 0 into: [ :total :object | total + 1 ]}}}DbIdentifier: bear73DbTrace: 490637DbUsername: jkottDbVersion: 8.2 - 2DevelopmentPrerequisites: #(#(#any 'Xtreams-Core' '') #(#any 'Xtreams-Support' '') #(#any 'Xtreams-Transforms' ''))DialectVersion: VisualWorks 7.9MonticelloPrefix: XTNamespace: Smalltalk.XtreamsPackageName: Xtreams-TerminalsParcel: #('Xtreams-Terminals')ParcelName: Xtreams-TerminalsPrerequisiteDescriptions: #(#(#name 'Xtreams-Core') #(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Core' '') #('Xtreams-Support' '') #('Xtreams-Transforms' ''))PrintStringCache: (8.2 - 2,jkott)Url: http://www.squeaksource.com/Xtreams/Xtreams-Terminals-nice.13.mczVersion: 8.2 - 2Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ExternalReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>cache cachePosition cacheDataSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.ExternalReadStream</class-id><body>Used to read from BlockableIOAccessors (e.g sockets or pipes). Elements are read-ahead but only what's available. This is a binary stream (produces bytes/ByteArrays).{{{	[ :in :out |		[	out writing write: 'Hello'; close.			in reading read: 5		] ensure: [ in close. out close ]	] valueWithArguments: SocketAccessor openPair}}}{{{	[ :in :out |		[	out writing write: 'Hello'; close.			in reading read: 5		] ensure: [ in close. out close ]	] valueWithArguments: OSSystemSupport concreteClass pipeAccessorClass openPair}}}Instance Variables	cache	&lt;ByteArray | ByteString&gt; read-ahead buffer	cachePosition	&lt;SmallInteger&gt; position in the buffer	cacheDataSize	&lt;SmallInteger&gt; size of valid data in the buffer</body></comment><class><name>FileReadStream</name><environment>Xtreams</environment><super>Xtreams.ExternalReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.FileReadStream</class-id><body>Reads from a file. The stream is usually created by sending #reading to a Filename. However the actual terminal is an IOAccessor. The original filename is accessible through the IOAccessor. The stream is binary and is naturally positionable.{{{	| file |	file := ObjectMemory imageName asFilename reading.	[ file read: 13 ] ensure: [ file close ]}}}As a convenience, sending #reading to a Filename of a directory will create a stream of all filenames in that directory.{{{	'/tmp' asFilename reading rest}}}Instance Variables	position	&lt;Integer&gt; current position of the stream</body></comment><class><name>NullWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><class><name>SharedQueueWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.SharedQueueWriteStream</class-id><body>Write stream on a SharedQueue. Primarily used for data transfer between processes.{{{	queue := SharedQueue new.	in := queue reading.	out := queue writing.	received := Array new writing.	done := Semaphore new.	consumer :=			[ | size |			[	(size := in get) isZero			] whileFalse: [ | word |				word := ByteString new: size.				in read: size into: word.				received put: word ].			done signal.		] fork.	#(one two three four) do: [ :word | out put: word size; write: word ].	out put: 0.	done wait.	received conclusion}}}Instance Variables	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream</body></comment><class><name>BlockClosureWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>contentsSpecies closeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.BlockClosureWriteStream</class-id><body>Write stream on a single argument block, the block is evaluated for each element written with the element assigned as the argument of the evaluation.{{{	"Transcript as an xtream"	[ :x | Transcript nextPut: x ] writing write: 'Hello World!'}}}{{{	"/dev/null"	[ :x | ] writing write: 'Hello World!'}}}Instance Variables	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream	closeBlock	&lt;BlockClosure&gt; invoked in response to the #close message, allows customizing the close behavior</body></comment><class><name>ExternalTimeoutReadStream</name><environment>Xtreams</environment><super>Xtreams.ExternalReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.ExternalTimeoutReadStream</class-id><body>This is an external stream with built in timeout support. A read operation will signal a Timeout if there is no data available longer than the preconfigured timeout duration. The Timeout exception is resumable which will make the operation continue to wait for another timeout period.Instance Variables	timeout	&lt;Duration&gt; how long we're willing to wait for incoming data</body></comment><class><name>SharedQueueReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.SharedQueueReadStream</class-id><body>Read stream on a SharedQueue. Primarily used for data transfer between processes.{{{	queue := SharedQueue new.	in := queue reading.	out := queue writing.	received := Array new writing.	done := Semaphore new.	consumer :=			[ | size |			[	(size := in get) isZero			] whileFalse: [ | word |				word := ByteString new: size.				in read: size into: word.				received put: word ].			done signal.		] fork.	#(one two three four) do: [ :word | out put: word size; write: word ].	out put: 0.	done wait.	received conclusion}}}Instance Variables	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream</body></comment><class><name>BufferWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.BufferWriteStream</class-id><body>Write stream on a Buffer. Usually used in tandem with a read stream to access buffer contents conveniently.{{{	buffer := ElasticBuffer on: String new.	bufferIn := buffer writing.	bufferOut := buffer reading.	100000 timesRepeat: [ bufferIn write: 'Hello World'. bufferOut read: 11 ].	buffer cacheSize  }}}</body></comment><class><name>CollectionWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.CollectionWriteStream</class-id><body>Write stream on a non-sequenceable collection. The collection is grown automatically to accommodate any elements written. Closing a collection write stream will truncate the collection to the current stream position. This behavior is useful as a replacement for the traditional #contents message. The contents can be accessed with the #terminal message after the stream is closed.{{{	String new writing write: 'Hello World'; -- 6; close; terminal}}}Instance Variables	position	&lt;Integer&gt; current position of the stream	length	&lt;Integer&gt; number of valid elements in the destination</body></comment><class><name>ExternalWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.ExternalWriteStream</class-id><body>Used to write to BlockableIOAccessors (e.g sockets or pipes). This is a binary stream (consumes bytes/ByteArrays).{{{	[ :in :out |		[	out writing write: 'Hello'; close.			in reading read: 5		] ensure: [ in close. out close ]	] valueWithArguments: SocketAccessor openPair}}}{{{	[ :in :out |		[	out writing write: 'Hello'; close.			in reading read: 5		] ensure: [ in close. out close ]	] valueWithArguments: OSSystemSupport concreteClass pipeAccessorClass openPair}}}Instance Variables	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream</body></comment><class><name>ExternalTimeoutWriteStream</name><environment>Xtreams</environment><super>Xtreams.ExternalWriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.ExternalTimeoutWriteStream</class-id><body>This is an external stream with built in timeout support. A write operation will signal a Timeout if there is no room to write the pending data (usually because the other side didn't read what was already written yet so associated buffers are still full) for longer than the preconfigured timeout duration. The Timeout exception is resumable which will make the operation continue to wait for another timeout period.Instance Variables	timeout	&lt;Duration&gt; how long we're willing to wait for room to write data</body></comment><class><name>SequenceableCollectionWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position length </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.SequenceableCollectionWriteStream</class-id><body>Write stream on a sequenceable collection. The collection is grown automatically to accommodate any elements written. Closing a collection write stream will truncate the collection to the current stream position. This behavior is useful as a replacement for the traditional #contents message. The contents can be accessed with the #terminal message after the stream is closed. Sequenceable collections can also seek past the end of their contents, or sparse writing.{{{	String new writing write: 'Hello World'; -- 6; close; terminal}}}Instance Variables	position	&lt;Integer&gt; current position of the stream	length	&lt;Integer&gt; number of valid elements in the destination</body></comment><class><name>BufferReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.BufferReadStream</class-id><body>Read stream on a Buffer. Usually used in tandem with a write stream to access buffer contents conveniently.{{{	buffer := ElasticBuffer on: String new.	bufferIn := buffer writing.	bufferOut := buffer reading.	100000 timesRepeat: [ bufferIn write: 'Hello World'. bufferOut read: 11 ].	buffer cacheSize  }}}</body></comment><class><name>Timeout</name><environment>Xtreams</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.Timeout</class-id><body>Signalled by external timeout read/write streams, when the read/write operation times out.{{{	pipe := OSSystemSupport concreteClass pipeAccessorClass openPair.	[	(pipe first reading: 1 seconds) get	] ensure: [ pipe do: #close ]}}}</body></comment><class><name>BlockClosureGenerateStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>process current contentsSpecies writing readingSemaphore writingSemaphore closed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.BlockClosureGenerateStream</class-id><body>Read stream on a one argument block, evaluates the block once for the life time of the stream. Once the block finishes execution, the stream is closed. The block is expected to write to the block argument, which will block exectuion until elements are read from the stream.{{{	"In this example, we have a -hard- loop, not using collection protocol, which will only run one element at a time."	[:out | 1 to: 10 do: [:i | out put: i]] reading read: 5.}}}{{{	"Fibonacci"	[:out | | a b x |	a := 0. b := 1.	[out put: a.	x := a.	a := b.	b := b + x] repeat] reading ++ 500; get.}}}Instance Variables	current	&lt;Object&gt;	the current element in the stream	closed	&lt;Boolean&gt;	true if the block has finished execution	contentsSpecies	&lt;Class&gt;	species for collections of elements of this stream	process	&lt;Process&gt;	the process executing the block	readingSemaphore	&lt;Semaphore&gt;	attempts to read will wait on this	writingSemaphore	&lt;Semaphore&gt;	attempts to write will wait on this, signaled when an attempt to read is performed</body></comment><class><name>BlockClosureReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>contentsSpecies closeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.BlockClosureReadStream</class-id><body>Read stream on a zero argument block, evaluates the block once for each requested element, the result of the block evaluation is the element.{{{	"inifinite stream of ones"	[ 1 ] reading read: 20}}}{{{	"Fibonacci"	| a b | a := 0. b := 1.	[ | x | x := a. a := b. b := x + a. x ] reading ++ 500; get}}}{{{	"Streaming over ObjectMemory"	x := ObjectMemory someObject.	[ x := ObjectMemory nextObjectAfter: x ] reading read: 5}}}Instance Variables	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream	closeBlock	&lt;BlockClosure&gt; invoked in response to the #close message, allows customizing the close behavior</body></comment><class><name>SequenceableCollectionReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.SequenceableCollectionReadStream</class-id><body>Read stream on a sequenceable collection.{{{	(1 to: 10000) reading ++ 1000; read: 5}}}Instance Variables	position	&lt;Integer&gt; current position of the stream</body></comment><class><name>ConstantReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.ConstantReadStream</class-id><body>Provides an efficient infinite stream of constant (identical) value. The value is the stream source.Instance Variables:	contentsSpecies	&lt;Class&gt;	description of contentsSpecies</body></comment><class><name>FileWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position isPositionable contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Terminals</package></attributes></class><comment><class-id>Xtreams.FileWriteStream</class-id><body>Writes to a file. File write streams can be created via the usual #writing message or via #appending which opens the file in appending mode. In appending mode, you cannot position the stream before the end of the file contents, so you can never overwrite existing contents. In writing mode, the file will be truncated at stream's current position when #close is called. To keep the entire contents of the file, use -= 0 to skip to the end before closing. This behavior is different from the classic streams which would erase the contents of the file on opening. The stream is binary and naturally positionable. File write streams that aren't in append mode can also seek past the end of the file, for sparse file writing.{{{	| file |	file := '/dev/shm/xtreams-test' asFilename.	[	file writing write: 'Hello'; close.		file appending write: ' World!'; close.		file contentsOfEntireFile.	] ensure: [ file delete ]}}}It is also possible to send #reading or #writing to a pre-opened IOAcccessor if some other opening mode configuration is desirable. For example to emulate the classic write stream opening behavior, you can use the following:{{{	(IOAccessor openFileNamed: '/dev/shm/xtreams-test' 		direction: IOAccessor writeOnly		creation: IOAccessor truncateOrCreate	) writing close}}}Instance Variables	position	&lt;Integer&gt; current position of the stream	isPositionable	&lt;Boolean&gt; indicates that the file is open in append mode	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream</body></comment><shared-variable><name>Log</name><environment>Xtreams</environment><private>true</private><constant>false</constant><category>tests</category><initializer>nil writing</initializer><attributes><package>Xtreams-Terminals</package></attributes></shared-variable><methods><class-id>Xtreams.ExternalReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	| saved |	cache isNil ifTrue: [^self].	source streamingReadClose.	saved := cache.	cache := nil.	saved == nil ifFalse: [ saved recycle ].</body><body package="Xtreams-Terminals">contentsSpecies	^cache class</body><body package="Xtreams-Terminals">contentsSpecies: aClass	cache ifNotNil: [ cache recycle ].	cache := aClass newRecycledDefaultSize.	cachePosition := 0.	cacheDataSize := 0.</body><body package="Xtreams-Terminals">on: anAccessor	super on: anAccessor.	self contentsSpecies: ByteArray</body></methods><methods><class-id>Xtreams.ExternalReadStream</class-id> <category>private</category><body package="Xtreams-Terminals">bytesForRead	^source bytesForRead</body><body package="Xtreams-Terminals">incompleteRead: incomplete	incomplete raise</body><body package="Xtreams-Terminals">nextBuffer	cachePosition := 0.	cacheDataSize := 0.	self readWait.	cacheDataSize := source readInto: cache startingAt: 1 for: cache size.</body><body package="Xtreams-Terminals">readWait	source readWait</body></methods><methods><class-id>Xtreams.ExternalReadStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">atEnd	^(cachePosition &lt; cacheDataSize or: [		self nextBuffer.		cacheDataSize &gt; 0 ]	) not</body><body package="Xtreams-Terminals">peek	cachePosition &lt; cacheDataSize ifFalse: [		self nextBuffer.		cacheDataSize isZero ifTrue: [ self incompleteRead: Incomplete zero ] ].	^cache at: cachePosition + 1</body></methods><methods><class-id>Xtreams.ExternalReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	cachePosition &lt; cacheDataSize ifFalse: [		self nextBuffer.		cacheDataSize isZero ifTrue: [ self incompleteRead: Incomplete zero ] ].	^cache at: (cachePosition := cachePosition + 1)</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	| index toRead |	anInteger isZero ifTrue: [^0].	index := startIndex.	toRead := anInteger.	[toRead &gt; 0] whileTrue: [ | amount |		cachePosition &lt; cacheDataSize ifFalse: [			self nextBuffer.			cacheDataSize isZero ifTrue: [ self incompleteRead: (Incomplete on: aSequenceableCollection count: anInteger - toRead at: startIndex) ] ].		amount := (cacheDataSize - cachePosition) min: toRead.		aSequenceableCollection replaceFrom: index to: index + amount - 1 with: cache startingAt: cachePosition + 1.		cachePosition := cachePosition + amount.		index := index + amount.		toRead := toRead - amount ].	^anInteger</body></methods><methods><class-id>Xtreams.FileReadStream</class-id> <category>testing</category><body package="Xtreams-Terminals">isPositionable	^true</body></methods><methods><class-id>Xtreams.FileReadStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">++ anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := self available min: anInteger.	position := position + count.	source seekTo: position.	cacheDataSize := cachePosition := 0.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Terminals">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := position min: anInteger.	position := position - count.	source seekTo: position.	cacheDataSize := cachePosition := 0.	anInteger = count ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Terminals">length	^source fileSize</body><body package="Xtreams-Terminals">position	^position</body><body package="Xtreams-Terminals">position: aPosition	| available |	aPosition &lt; 0 ifTrue: [ Incomplete zero raise ].	available := aPosition min: self length.	source seekTo: available.	position := available.	cacheDataSize := cachePosition := 0.	available = aPosition ifTrue: [^aPosition].	(Incomplete count: available) raise</body></methods><methods><class-id>Xtreams.FileReadStream</class-id> <category>private</category><body package="Xtreams-Terminals">bytesForRead	"Ideally we'd ask for the fileSize and subtract that from our position, but calling #fileSize is a slow primitive"	^cache size</body><body package="Xtreams-Terminals">incompleteRead: incomplete	position := position + incomplete count.	super incompleteRead: incomplete.</body></methods><methods><class-id>Xtreams.FileReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">on: anAccessor	super on: anAccessor.	position := 0</body></methods><methods><class-id>Xtreams.FileReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	| object |	object := super get.	position := position + 1.	^object</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	super read: anInteger into: aSequenceableCollection at: startIndex.	position := position + anInteger.	^anInteger</body></methods><methods><class-id>Xtreams.NullWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close</body><body package="Xtreams-Terminals">contentsSpecies	^Array</body><body package="Xtreams-Terminals">flush</body></methods><methods><class-id>Xtreams.NullWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex	^anInteger</body></methods><methods><class-id>Xtreams.SharedQueueWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Terminals">flush</body><body package="Xtreams-Terminals">on: aDestination	super on: aDestination.	contentsSpecies := Array</body></methods><methods><class-id>Xtreams.SharedQueueWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex	startIndex to: startIndex + anInteger - 1 do: [:index | destination nextPut: (aSequenceableCollection at: index)].	^anInteger</body></methods><methods><class-id>Xtreams.BlockClosureWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	closeBlock cull: self</body><body package="Xtreams-Terminals">closeBlock	^closeBlock</body><body package="Xtreams-Terminals">closeBlock: aBlock	closeBlock := aBlock</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: anObject	contentsSpecies := anObject</body><body package="Xtreams-Terminals">flush</body><body package="Xtreams-Terminals">on: aBlockClosure	super on: aBlockClosure.	contentsSpecies := Array.	closeBlock := []</body></methods><methods><class-id>Xtreams.BlockClosureWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex	| count |	count := 0.	[[count &lt; anInteger] whileTrue:		[destination value: (aSequenceableCollection at: startIndex + count).		count := count + 1]]			on: Incomplete do: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.ExternalTimeoutReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">timeout	^timeout milliseconds</body><body package="Xtreams-Terminals">timeout: duration	timeout := duration asMilliseconds</body></methods><methods><class-id>Xtreams.ExternalTimeoutReadStream</class-id> <category>private</category><body package="Xtreams-Terminals">readWait	[	(source readWaitWithTimeoutMs: timeout) ifFalse: [^self].		Timeout raiseSignal	] repeat</body></methods><methods><class-id>Xtreams.ExternalTimeoutReadStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">-= anInteger"	If setting to the end of the stream, use the default ReadStream implementation."	anInteger isZero ifTrue: [ ^ super -= anInteger ].	self error: 'This stream is not positionable.'</body></methods><methods><class-id>Xtreams.SharedQueueReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Terminals">on: aSource	super on: aSource.	contentsSpecies := Array</body></methods><methods><class-id>Xtreams.SharedQueueReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	^source next</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	startIndex to: startIndex + anInteger - 1 do: [:index | aSequenceableCollection at: index put: source next].	^anInteger</body></methods><methods><class-id>Xtreams.SharedQueueReadStream</class-id> <category>private</category><body package="Xtreams-Terminals">streamingInsertInto: aWriteStream	self shouldNotImplement</body><body package="Xtreams-Terminals">streamingWriteInto: aWriteStream	self shouldNotImplement</body></methods><methods><class-id>Xtreams.BufferWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	destination close</body><body package="Xtreams-Terminals">contentsSpecies	^destination contentsSpecies</body><body package="Xtreams-Terminals">flush</body></methods><methods><class-id>Xtreams.BufferWriteStream</class-id> <category>testing</category><body package="Xtreams-Terminals">isPositionable	^true</body></methods><methods><class-id>Xtreams.BufferWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">insert: anInteger from: aSequenceableCollection at: startIndex	^destination insert: anInteger from: aSequenceableCollection at: startIndex</body><body package="Xtreams-Terminals">put: anObject	^destination put: anObject</body><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex	^destination write: anInteger from: aSequenceableCollection at: startIndex</body></methods><methods><class-id>Xtreams.BufferWriteStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">++ anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := destination writeSkip: anInteger.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Terminals">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := (destination writeSkip: anInteger negated) negated.	count = anInteger ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Terminals">available	^destination writeSize</body><body package="Xtreams-Terminals">length	^destination activeSize</body><body package="Xtreams-Terminals">position	^destination writePosition</body><body package="Xtreams-Terminals">position: aPosition	| available |	aPosition &lt; 0 ifTrue: [ Incomplete zero raise ].	available := aPosition min: destination activeSize.	destination writePosition: available.	available = aPosition ifTrue: [^aPosition ].	(Incomplete count: available) raise</body><body package="Xtreams-Terminals">skip: anInteger	| count |	count := destination writeSkip: anInteger.	count ~= anInteger ifTrue: [(Incomplete count: count) raise]</body></methods><methods><class-id>Xtreams.CollectionWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close</body><body package="Xtreams-Terminals">contentsSpecies	^destination species</body><body package="Xtreams-Terminals">flush</body></methods><methods><class-id>Xtreams.CollectionWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">put: anObject	destination add: anObject</body><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex	startIndex to: startIndex + anInteger - 1 do: [:index |		destination add: (aSequenceableCollection at: index)].	^anInteger</body></methods><methods><class-id>Xtreams.ExternalWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	destination isActive ifFalse: [^self].	destination streamingWriteClose</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Terminals">flush	destination isActive ifFalse: [^self].	destination commit</body><body package="Xtreams-Terminals">on: anAccessor	super on: anAccessor.	contentsSpecies := ByteArray</body></methods><methods><class-id>Xtreams.ExternalWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex	| count wrote |	anInteger isZero ifTrue: [^0].	count := 0.	[count &lt; anInteger] whileTrue:		[self writeWait.		wrote := destination writeFrom: aSequenceableCollection startingAt: startIndex + count for: anInteger - count.		wrote isZero ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].		count := count + wrote].	^anInteger</body></methods><methods><class-id>Xtreams.ExternalWriteStream</class-id> <category>private</category><body package="Xtreams-Terminals">writeWait	"This doesn't seem to work as expected at least on 64-bit Linux pipes,	looks like we need to pull this call at least for now.	destination writeWait"</body></methods><methods><class-id>Xtreams.ExternalTimeoutWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">timeout	^timeout milliseconds</body><body package="Xtreams-Terminals">timeout: duration	timeout := duration asMilliseconds</body></methods><methods><class-id>Xtreams.ExternalTimeoutWriteStream</class-id> <category>private</category><body package="Xtreams-Terminals">writeWait	[	(destination writeWaitWithTimeoutMs: timeout) ifFalse: [^self].		Timeout raiseSignal	] repeat</body></methods><methods><class-id>Xtreams.SequenceableCollectionWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">contents	^destination copyFrom: 1 to: position</body><body package="Xtreams-Terminals">insert: anInteger from: aSequenceableCollection at: startIndex	destination growToAtLeast: destination size + anInteger.	destination replaceFrom: position + anInteger + 1 to: length + anInteger with: destination startingAt: position + 1.	destination replaceFrom: position + 1 to: position + anInteger with: aSequenceableCollection startingAt: startIndex.	position := position + anInteger.	length := length + anInteger.	^anInteger</body><body package="Xtreams-Terminals">put: anObject		destination size - position &lt; 1 ifTrue: [destination growToAtLeast: position + 1].	position := position + 1.	destination at: position put: anObject.	position &gt; length ifTrue: [length := position].	^anObject</body><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex		destination size - position &lt; anInteger ifTrue: [destination growToAtLeast: position + anInteger].	destination replaceFrom: position + 1 to: position + anInteger with: aSequenceableCollection startingAt: startIndex.	position := position + anInteger.	position &gt; length ifTrue: [length := position].	^anInteger</body></methods><methods><class-id>Xtreams.SequenceableCollectionWriteStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">++ anInteger	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	position := position + anInteger.	^anInteger</body><body package="Xtreams-Terminals">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := position min: anInteger.	position := position - count.	count = anInteger ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Terminals">length	^length</body><body package="Xtreams-Terminals">position	^position</body><body package="Xtreams-Terminals">position: aPosition	aPosition &lt; 0 ifTrue: [ Incomplete zero raise ].	position := aPosition.	^position</body></methods><methods><class-id>Xtreams.SequenceableCollectionWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	destination become: (destination copyFrom: 1 to: (position min: length))</body><body package="Xtreams-Terminals">contentsSpecies	^destination species</body><body package="Xtreams-Terminals">flush</body><body package="Xtreams-Terminals">on: aSequenceableCollection	super on: aSequenceableCollection.	position := 0.	length := 0</body></methods><methods><class-id>Xtreams.SequenceableCollectionWriteStream</class-id> <category>printing</category><body package="Xtreams-Terminals">streamingPrintOn: aStream	| tail head |	super streamingPrintOn: aStream.	tail := position min: 5.	head := (destination size - position) min: (10 - tail).	aStream		write: ' position: ';		print: position;		write: ' size: ';		print: destination size;		cr; tab;		write: (position &gt; 5 ifTrue: ['...'] ifFalse: ['']);		print: (destination copyFrom: position + 1 - tail to: position);		write: '  |  ';		print: (destination copyFrom: position + 1 to: position + head);		write: (destination size - position &gt; (10 - tail) ifTrue: ['...'] ifFalse: [''])</body></methods><methods><class-id>Xtreams.SequenceableCollectionWriteStream</class-id> <category>private</category><body package="Xtreams-Terminals">streamingInsert: anInteger from: aStreamable	| reading |	reading := aStreamable reading.	destination growToAtLeast: destination size + anInteger.	destination replaceFrom: position + anInteger to: destination size with: destination startingAt: position.	[reading read: anInteger into: destination at: position + 1]		on: Incomplete do: [:error | position := position + error count. error pass].	position := position + anInteger</body><body package="Xtreams-Terminals">streamingInsertFrom: aStreamable	self error: 'Not Yet Implemented'</body><body package="Xtreams-Terminals">streamingWrite: anInteger from: aReadStream	| available |	available := destination size - position.	available &lt; anInteger ifTrue: [destination growToAtLeast: destination size + anInteger - available].	[aReadStream read: anInteger into: destination at: position + 1]		on: Incomplete do: [:error |			position := position + error count.			position &gt; length ifTrue: [length := position].			error pass].	position := position + anInteger.	position &gt; length ifTrue: [length := position].	^anInteger</body><body package="Xtreams-Terminals">streamingWriteFrom: aReadStream	| available count |	count := 0.	destination size = 0 ifTrue: [ destination growToAtLeast: DefaultBufferSize ].	^[	[	available := destination size - position.			aReadStream read: available into: destination at: position + 1.			position := position + available.			count := count + available.			destination growToAtLeast: destination size + (destination size min: DefaultBufferSize)		] repeat	] on: Incomplete do: [:exception |		position := position + exception count.		position &gt; length ifTrue: [length := position].		count + exception count]</body></methods><methods><class-id>Xtreams.SequenceableCollectionWriteStream</class-id> <category>testing</category><body package="Xtreams-Terminals">isPositionable	^true</body></methods><methods><class-id>Xtreams.BufferReadStream</class-id> <category>testing</category><body package="Xtreams-Terminals">isPositionable	^true</body></methods><methods><class-id>Xtreams.BufferReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close</body><body package="Xtreams-Terminals">contentsSpecies	^source contentsSpecies</body></methods><methods><class-id>Xtreams.BufferReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	^source get</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	source read: anInteger into: aSequenceableCollection at: startIndex.	^anInteger</body></methods><methods><class-id>Xtreams.BufferReadStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">++ anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := source readSkip: anInteger.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Terminals">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := (source readSkip: anInteger negated) negated.	count = anInteger ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Terminals">available	^source readSize</body><body package="Xtreams-Terminals">length	^source activeSize</body><body package="Xtreams-Terminals">position	^source readPosition</body><body package="Xtreams-Terminals">position: aPosition	| available |	aPosition &lt; 0 ifTrue: [ Incomplete zero raise ].	available := aPosition min: source activeSize.	source readPosition: available.	available = aPosition ifTrue: [^aPosition ].	(Incomplete count: available) raise</body></methods><methods><class-id>Xtreams.Timeout class</class-id> <category>testing</category><body package="Xtreams-Terminals">mayResume	^true</body></methods><methods><class-id>Xtreams.BlockClosureGenerateStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	writingSemaphore signal.	closed ifTrue: [Incomplete zero raise].	readingSemaphore wait.	^current</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	| count |	count := 0.	[[count &lt; anInteger] whileTrue:		[aSequenceableCollection at: startIndex + count put: self get.		count := count + 1]]			on: Incomplete do: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.BlockClosureGenerateStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	closed := true.	process terminate.	readingSemaphore signal</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Terminals">on: aBlockClosure	super on: aBlockClosure.	contentsSpecies := Array.	readingSemaphore := Semaphore new.	writingSemaphore := Semaphore new.	closed := false.	process :=		[aBlockClosure value: [:in |			writingSemaphore wait.			current := in.			readingSemaphore signal] writing.		closed := true] fork</body></methods><methods><class-id>Xtreams.BlockClosureReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	closeBlock cull: self</body><body package="Xtreams-Terminals">closeBlock	^closeBlock</body><body package="Xtreams-Terminals">closeBlock: aBlock	closeBlock := aBlock</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: anObject	contentsSpecies := anObject</body><body package="Xtreams-Terminals">on: aBlockClosure	super on: aBlockClosure.	contentsSpecies := Array.	closeBlock := []</body></methods><methods><class-id>Xtreams.BlockClosureReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	^source value</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	| count |	count := 0.	[[count &lt; anInteger] whileTrue:		[aSequenceableCollection at: startIndex + count put: source value.		count := count + 1]]			on: Incomplete do: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.SequenceableCollectionReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	position = source size ifTrue: [Incomplete zero raise].	position := position + 1.	^source at: position</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	| count |	count := anInteger min: self available.	aSequenceableCollection replaceFrom: startIndex to: startIndex + count - 1 with: source startingAt: position + 1.	position := position + count.	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.SequenceableCollectionReadStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">++ anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := self available min: anInteger.	position := position + count.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Terminals">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := position min: anInteger.	position := position - count.	count = anInteger ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Terminals">length	^source size</body><body package="Xtreams-Terminals">position	" Return a bookmark for the current stream state. "	^position</body><body package="Xtreams-Terminals">position: aPosition	aPosition &lt; 0 ifTrue: [ Incomplete zero raise ].	position := aPosition min: self length.	position = aPosition ifTrue: [^aPosition ].	(Incomplete count: position) raise</body></methods><methods><class-id>Xtreams.SequenceableCollectionReadStream</class-id> <category>private</category><body package="Xtreams-Terminals">streamingInsert: anInteger into: aWriteStream	| count |	anInteger isZero ifTrue: [^self].	count := anInteger min: self available.	aWriteStream insert: count from: source at: position + 1.	position := position + count.	count &gt;= anInteger ifTrue: [^self].	(Incomplete on: source count: count at: position - count + 1) raise</body><body package="Xtreams-Terminals">streamingInsertInto: aWriteStream	| count |	(count := self available) isZero ifTrue: [Incomplete zero raise].	self streamingInsert: count into: aWriteStream.	^count</body><body package="Xtreams-Terminals">streamingWrite: anInteger into: aWriteStream	| count |	anInteger isZero ifTrue: [^0].	count := anInteger min: self available.	aWriteStream write: count from: source at: position + 1.	position := position + count.	count = anInteger ifTrue: [^anInteger].	(Incomplete on: source count: count at: position - count + 1) raise</body><body package="Xtreams-Terminals">streamingWriteInto: aWriteStream	| count |	(count := self available) isZero ifTrue: [^self].	self streamingWrite: count into: aWriteStream.	^count</body></methods><methods><class-id>Xtreams.SequenceableCollectionReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close</body><body package="Xtreams-Terminals">contentsSpecies	^source species</body><body package="Xtreams-Terminals">on: aSequenceableCollection	super on: aSequenceableCollection.	position := 0</body></methods><methods><class-id>Xtreams.SequenceableCollectionReadStream</class-id> <category>printing</category><body package="Xtreams-Terminals">streamingPrintOn: aStream	| tail head |	super streamingPrintOn: aStream.	tail := position min: 5.	head := (source size - position) min: (10 - tail).	aStream		write: ' position: ';		print: position;		write: ' size: ';		print: source size;		cr; tab;		write: (position &gt; 5 ifTrue: ['...'] ifFalse: ['']);		print: (source copyFrom: position + 1 - tail to: position);		write: '  |  ';		print: (source copyFrom: position + 1 to: position + head);		write: (source size - position &gt; (10 - tail) ifTrue: ['...'] ifFalse: [''])</body></methods><methods><class-id>Xtreams.SequenceableCollectionReadStream</class-id> <category>testing</category><body package="Xtreams-Terminals">isPositionable	^true</body></methods><methods><class-id>Xtreams.ConstantReadStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">get	^source</body><body package="Xtreams-Terminals">read: anInteger into: aSequenceableCollection at: startIndex	| chunk start |	chunk := 16.	startIndex to: startIndex + (anInteger min: chunk) - 1 do: [ :i | aSequenceableCollection at: i put: source ].	anInteger &gt; chunk ifFalse: [ ^anInteger ].	start := startIndex + chunk.	[ chunk &lt; anInteger ] whileTrue: [		aSequenceableCollection replaceFrom: start to: ((start := start + chunk) - 1 min: anInteger) with: aSequenceableCollection startingAt: startIndex.		chunk := chunk bitShift: 1 ].	^anInteger</body></methods><methods><class-id>Xtreams.ConstantReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Terminals">on: anObject	super on: anObject.	contentsSpecies := Array</body></methods><methods><class-id>Xtreams.FileWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Terminals">close	destination isActive ifFalse: [^self].	destination truncateTo: position.	destination close</body><body package="Xtreams-Terminals">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Terminals">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Terminals">flush	destination isActive ifFalse: [^self].	destination commit</body><body package="Xtreams-Terminals">isPositionable: aBoolean	"Only set to false when the file is open in append mode."	isPositionable := aBoolean</body><body package="Xtreams-Terminals">on: anAccessor	super on: anAccessor.	contentsSpecies := ByteArray.	isPositionable := true.	position := 0</body></methods><methods><class-id>Xtreams.FileWriteStream</class-id> <category>testing</category><body package="Xtreams-Terminals">isPositionable	^isPositionable</body></methods><methods><class-id>Xtreams.FileWriteStream</class-id> <category>seeking</category><body package="Xtreams-Terminals">++ anInteger	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	position := position + anInteger.	destination seekTo: position.	^anInteger</body><body package="Xtreams-Terminals">-- anInteger	| count |	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := position min: anInteger.	position := position - count.	destination seekTo: position.	anInteger = count ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Terminals">length	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	^destination fileSize</body><body package="Xtreams-Terminals">position	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	^position</body><body package="Xtreams-Terminals">position: aPosition	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	aPosition &lt; 0 ifTrue: [ Incomplete zero raise ].	destination seekTo: aPosition.	position := aPosition.	^position</body></methods><methods><class-id>Xtreams.FileWriteStream</class-id> <category>accessing</category><body package="Xtreams-Terminals">insert: anInteger from: aSequenceableCollection at: startIndex	^self shouldNotImplement.	"While it might seem desireable to be able to insert in to a file, the reality is you can only do so if you can read and write to the file. if you can read and write to the file, the fileSize becomes indeterminate. The only reasonable way to insert in to a file is to memory map it and access it with a PointerWriteStream instead."</body><body package="Xtreams-Terminals">write: anInteger from: aSequenceableCollection at: startIndex	| count wrote |	anInteger isZero ifTrue: [^0].	count := 0.	[count &lt; anInteger] whileTrue:		[wrote := destination writeFrom: aSequenceableCollection startingAt: startIndex + count for: anInteger.		wrote isZero ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].		count := count + wrote.		position := position + wrote].	^anInteger</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^BufferReadStream on: self</body><body package="Xtreams-Terminals">writing	^BufferWriteStream on: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Xtreams-Terminals">repeating"Provides an infinite stream of itself.	5 repeating read: 5000"	^ConstantReadStream on: self</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	"Return a terminal stream over object memory. Reading from object memory is endless, do not attempt to 'read to the end' without specifying an end condition using #ending: or #limiting:, etc."	| next |	next := self someObject.	^[	| current |		current := next.		next := self nextObjectAfter: next.		current == 0 ifTrue: [ Incomplete zero raise].		current	] reading</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="Xtreams-Terminals">writing	^CollectionWriteStream on: self</body></methods><methods><class-id>UI.TextCollector</class-id> <category>converting</category><body package="Xtreams-Terminals">writing	^[:object | self nextPut: object] writing</body></methods><methods><class-id>OS.UnixDiskFileAccessor</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^FileReadStream on: self</body><body package="Xtreams-Terminals">writing	^FileWriteStream on: self</body></methods><methods><class-id>OS.Filename</class-id> <category>converting</category><body package="Xtreams-Terminals">appending	^(IOAccessor openFileNamed: self direction: IOAccessor appendOnly creation: IOAccessor mayCreate) writing		position: self fileSize;		isPositionable: false;		yourself</body><body package="Xtreams-Terminals">reading	self isDirectory ifFalse: [^(IOAccessor openFileNamed: self direction: IOAccessor readOnly creation: IOAccessor noCreate) reading].	"Return the directory contents as a stream of filenames"	^([self directoryContents]		on:	self errorReporter errorSignal		do:	[:ex | ex return: #()])			reading collecting: [:each | self construct: each asFilename]</body><body package="Xtreams-Terminals">writing	^(IOAccessor openFileNamed: self direction: IOAccessor writeOnly creation: IOAccessor mayCreate) writing</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>instance creation</category><body package="Xtreams-Terminals">writingDo: aBlock	| stream |	stream := self new writing.	aBlock value: stream.	^stream		close;		destination</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^SequenceableCollectionReadStream on: self</body><body package="Xtreams-Terminals">writing	^SequenceableCollectionWriteStream on: self</body></methods><methods><class-id>Core.SharedQueue</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^SharedQueueReadStream on: self</body><body package="Xtreams-Terminals">writing	^SharedQueueWriteStream on: self</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>xtreams</category><body package="Xtreams-Terminals">reading	^stream ioConnection input reading</body><body package="Xtreams-Terminals">reading: timeout	^stream ioConnection input reading: timeout</body><body package="Xtreams-Terminals">writing	^stream ioConnection output writing</body><body package="Xtreams-Terminals">writing: timeout	^stream ioConnection output writing: timeout</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="Xtreams-Terminals">reading"	nil reading get"	^[ Incomplete zero raise ] reading</body><body package="Xtreams-Terminals">writing	^NullWriteStream new</body></methods><methods><class-id>Core.ReadStream</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^[[self next]		on: EndOfStreamNotification		do: [:notification |			notification originator == self				ifTrue:	[Incomplete zero raise]				ifFalse:	[notification pass]]] reading		contentsSpecies: self contentsSpecies;		yourself</body></methods><methods><class-id>OS.PCPipeAccessor</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^ExternalReadStream on: self</body><body package="Xtreams-Terminals">reading: timeout"Create read stream with timeout support.	timeout &lt;Duration&gt; reads will wait at most @timeout for incoming data	^&lt;ExternalTimeoutReadStream&gt;"	^(ExternalTimeoutReadStream on: self)		timeout: timeout;		yourself</body><body package="Xtreams-Terminals">writing	^ExternalWriteStream on: self</body><body package="Xtreams-Terminals">writing: timeout"Create write stream with timeout support.	timeout &lt;Duration&gt; writes will wait at most @timeout for room to write data	^&lt;ExternalTimeoutWriteStream&gt;"	^(ExternalTimeoutWriteStream on: self)		timeout: timeout;		yourself</body></methods><methods><class-id>Core.Random</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^[self next] reading		contentsSpecies: self contentsSpecies;		yourself</body></methods><methods><class-id>OS.IOAccessor</class-id> <category>xtreams</category><body package="Xtreams-Terminals">streamingReadClose	self close</body><body package="Xtreams-Terminals">streamingWriteClose	self close</body></methods><methods><class-id>Core.WriteStream</class-id> <category>converting</category><body package="Xtreams-Terminals">writing	^[:object | self nextPut: object] writing		contentsSpecies: self contentsSpecies;		yourself</body></methods><methods><class-id>OS.PCDiskFileAccessor</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^FileReadStream on: self</body><body package="Xtreams-Terminals">writing	^FileWriteStream on: self</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	self numArgs = 0 ifTrue: [^BlockClosureReadStream on: self].	self numArgs = 1 ifTrue: [^BlockClosureGenerateStream on: self].	self error: 'More arguments than we can poke a stick at!'</body><body package="Xtreams-Terminals">writing	self numArgs = 1 ifTrue: [^BlockClosureWriteStream on: self].	self error: 'Must be a single argument block.'</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>converting</category><body package="Xtreams-Terminals">accepting	"Return a read stream that produces new sockets from incoming connections."	"^	ReadStream"	"Listen for connections and close those connections immediately.	| socket |	socket := SocketAccessor newTCP.	socket listenFor: 1.	[socket accepting do: [:client | client close]]		ensure: [socket close]	"	^[self accept] reading		closeBlock: [self close];		yourself</body><body package="Xtreams-Terminals">reading	^ExternalReadStream on: self</body><body package="Xtreams-Terminals">reading: timeout"Create read stream with timeout support.	timeout &lt;Duration&gt; reads will wait at most @timeout for incoming data	^&lt;ExternalTimeoutReadStream&gt;"	^(ExternalTimeoutReadStream on: self)		timeout: timeout;		yourself</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>xtreams</category><body package="Xtreams-Terminals">streamingReadClose	[	self shutdown: 0	] on: OS.OsError do: [ :ex |		" Various kinds of OsErrors can be raised by shutdown.		OsIllegalOperation can be provoked like this:		""	| sockets |			sockets := OS.SocketAccessor phonyPair.			[	sockets first shutdown: 1.				sockets first shutdown: 0.				sockets last shutdown: 1.				sockets last shutdown: 0.			] ensure: [ sockets do: #close ]		"" OsError can be provoked like this		""	| sockets |			sockets := OS.SocketAccessor phonyPair.			[	sockets first close.				sockets first shutdown: 0.			] ensure: [ sockets do: #close ]		"  ]</body><body package="Xtreams-Terminals">streamingWriteClose	[	self shutdown: 1	] on: OS.OsError do: [ :ex |		" Various kinds of OsErrors can be raised by shutdown.		OsIllegalOperation can be provoked like this:		""	| sockets |			sockets := OS.SocketAccessor phonyPair.			[	sockets first shutdown: 0.				sockets first shutdown: 1.				sockets last shutdown: 0.				sockets last shutdown: 1.				sockets last shutdown: 1.			] ensure: [ sockets do: #close ]		"" OsError can be provoked like this		""	| sockets |			sockets := OS.SocketAccessor phonyPair.			[	sockets first close.				sockets first shutdown: 1.			] ensure: [ sockets do: #close ]		"  ]</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>converting</category><body package="Xtreams-Terminals">writing	^ExternalWriteStream on: self</body><body package="Xtreams-Terminals">writing: timeout"Create write stream with timeout support.	timeout &lt;Duration&gt; writes will wait at most @timeout for room to write data	^&lt;ExternalTimeoutWriteStream&gt;"	^(ExternalTimeoutWriteStream on: self)		timeout: timeout;		yourself</body></methods><methods><class-id>OS.UnixPipeAccessor</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	^ExternalReadStream on: self</body><body package="Xtreams-Terminals">reading: timeout"Create read stream with timeout support.	timeout &lt;Duration&gt; reads will wait at most @timeout for incoming data	^&lt;ExternalTimeoutReadStream&gt;"	^(ExternalTimeoutReadStream on: self)		timeout: timeout;		yourself</body><body package="Xtreams-Terminals">writing	^ExternalWriteStream on: self</body><body package="Xtreams-Terminals">writing: timeout"Create write stream with timeout support.	timeout &lt;Duration&gt; writes will wait at most @timeout for room to write data	^&lt;ExternalTimeoutWriteStream&gt;"	^(ExternalTimeoutWriteStream on: self)		timeout: timeout;		yourself</body></methods><methods><class-id>Kernel.Context</class-id> <category>converting</category><body package="Xtreams-Terminals">reading	| context |	(context := self class new) sender: self.	^[	context := context sender.		context == nil ifTrue: [Incomplete raise].		context	] reading</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>IOAccessor</name><environment>OS</environment><super>OS.OSHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>PCDiskFileAccessor</name><environment>OS</environment><super>OS.PCIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>networkFamily </inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars>defaultGeneratorClass </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>UnixPipeAccessor</name><environment>OS</environment><super>OS.UnixIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>Buffer</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache readPosition writePosition dataLength </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Core</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>UnixDiskFileAccessor</name><environment>OS</environment><super>OS.UnixIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SharedQueue</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents accessProtect readSynch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>PCPipeAccessor</name><environment>OS</environment><super>OS.PCIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer bufferSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-PC</category><attributes><package>OS-ExternalProcess</package></attributes></class><class><name>StandardIOStream</name><environment>OS</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Standard I/O Streams</category><attributes><package>Standard IO Streams</package></attributes></class></st-source>