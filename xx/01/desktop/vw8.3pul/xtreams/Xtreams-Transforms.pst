<?xml version="1.0"?><st-source><!-- Name: Xtreams-TransformsNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: Transforms are streams on top of other streams. A stack of transforms on top of each other with a terminal stream at the bottom is called a *stream stack*. The usual purpose of a transform stream is transformation of the elements that are passing through it. Alternative it can be some sort of a side-effect while passing the elements through unchanged, e.g. counting, logging, hashing. A transform may also cause the number of elements to change, e.g. compression, encoding, filtering, etc.	== Collection enumeration analogs ==Following set of transforms emulates the popular collection enumerators, providing the same sort of benefits. Primary difference is that the enumeration happens incrementally, as elements are being written into or read from the stream. This avoids some of the overhead that the collection API incurs improving scalability of these operations on large datasets.	=== Element Conversion (#collecting:) ===This is the simplest form of transformation where elements are transformed one for one, i.e. the number of elements before and after transformation is the same.{{{	"squaring read input"	((1 to: 10) reading collecting: [ :e | e * e ]) rest}}}{{{	"normalizing output"	(String new writing collecting: #asLowercase) write: 'abcABC'; conclusion}}}	=== Element Filtering (#selecting:/#rejecting:) ===These transformations eliminate some of the elements flowing through the stream based on provided criteria. The number of elements after the transformation is same or smaller than before transformation.{{{	((1 to: 50) reading selecting: [ :e | e odd ]) rest}}}{{{	(String new writing rejecting: [ :c | c isLowercase ]) write: 'abABcC'; conclusion}}}	=== Additional Processing of Elements (#doing:) ===The #doing: transformation allows to perform additional activity with each element flowing through the stream. The elements can be counted, logged, copied into a different stream, etc.{{{	count := 0.	('abcdef' reading doing: [ :e | count := count + 1 ]) rest.	count}}}{{{	log := String new writing.	(String new writing doing: [ :e | log put: e ]) write: 'abcdef'.	log conclusion}}}	=== Per-Element Accumulation (#injecting:into:) ===The #inject:into: idiom is used to simplify the expression of a running value computed over a set of elements. In the streaming variant the resulting stream provides the subsequent states of the running value (not the elements). {{{	"e series"	x := 1.	integers := [ x := x + 1 ] reading.	((integers injecting: 1 into: [ :sum :next | sum + next factorial reciprocal ]) collecting: #asDouble) read: 20}}}{{{	(Array new writing injecting: 0 into: [ :total :each | each + total ]) write: (1 to: 10); conclusion}}}	== Specialized Transformations ==These are specific, commonly used transformations. They are often optimized via a dedicated stream class, but that is usually hidden behind the conventional creation methods on ReadStream.	=== Character encoding (#encoding:) ===Character encoding is a process of turning a sequence of characters into a sequence of bytes. The inverse process is called decoding. There are different kinds of character encoding often tailored to specific alphabets. Some are able to encode only a certain subset of characters, others are able to encode any character. These specific kinds of encodings are usually identified with their names, e.g. 'ASCII', 'UTF-8', 'ISO 8859-1'. When creating an encoding stream, the encoding name has to be specified. Any encoding name recognized by class Encoder can be used.{{{	(ByteArray new writing encoding: #iso8859_1) write: 'Hello'; conclusion}}}Encoding write stream consumes characters and converts them into bytes. Consequently the underlying write stream must be binary (i.e accept bytes (0..255)).The encoding stream also performs automatic conversion of CRs (Character cr) into the native line-end convention of the underlying platform, unless set into a different line-end convention mode.{{{	(ByteArray new writing encoding: #utf16)		setLineEndCRLF;		write: 'Hello World!\Bye World!' withCRs;		conclusion}}}An encoding read stream reads bytes from an underlying binary stream, decodes the bytes according to the pre-configured encoding and produces characters. It also performs automatic line end conversion from arbitrary platform convention to CRs, unless set into a transparent mode.{{{	(#[65 66 67 13 10 68 69 70 10 71 72 73 ] reading encoding: #ascii) rest	(#[65 66 67 13 10 68 69 70 10 71 72 73 ] reading encoding: #ascii) setLineEndTransparent; rest}}}	=== Base-64 encoding (#encodingBase64) ===Base-64 encoding is a commonly used encoding of bytes into characters, usually for the purpose of transporting bytes over text based protocols (e.g. MIME or XML). This is different from character encoding, the input and output type is inverted. The encoding has to be able to handle arbitrary sequence of bytes, but not every character sequence is valid base-64 encoding.Consequently the write stream consumes bytes and writes characters into the underlying stream. Note that base-64 encoding requires specific treatment at the end of the encoding sequence, so base-64 write stream must be closed at the end.{{{	encoded := String new.	encoded writing encodingBase64 write: (ByteArray withAll: (0 to: 255)); close.	encoded}}}The read stream reads characters from underlying stream and converts the characters into bytes.{{{	encoded reading encodingBase64 rest}}}The read stream ignores any intervening white space that might be used to format the base-64 characters for transport (e.g. base-64 encoding is often wrapped to certain line length with new-line characters interspersed with the base-64 characters. The read stream will automatically end when it encounters the base-64 termination sequence ($=). Note however that the sequence is not always present, so it cannot be used as a reliable stream terminator.	== General Transformations (#transforming:) ==This is the most general form of transformation. The block argument receives two streams, input and output. The block can read arbitrary number of elements from input (including none) and write arbitrary number of elements into the output (including none).With read streams the input is the underlying source stream and output is a virtual stream of elements to be produced by the stream. The block will be invoked as many times as necessary to produce the requested number of elements (requested by a read call), or until an Incomplete is raised. Consequently if the block handles Incomplete from the input, it has to raise an Incomplete at some point, otherwise the stream will never end (improper Incomplete handling can result in tight infinite loops).{{{	"Multiply each pair of input elements together and return the result"	((Array withAll: (1 to: 20)) reading transforming: [ :in :out | out put: in get * in get ]) rest}}}Note that if the contentSpecies of the source doesn't fit the output of the transformation, the contentsSpecies of the transform stream has to be set explicitly.{{{	"hex encoding: #[0 1 2 ... 255] -> '000102...FF' "	bytes := ByteArray withAll: (0 to: 255).	digits := '0123456789ABCDEF'.	byte2hex := [ :in :out || byte |			byte := in get.		out put: (digits at: (byte bitShift: -4) + 1).		out put: (digits at: (byte bitAnd: 15) + 1) ].	(bytes reading transforming: byte2hex)		contentsSpecies: String;		rest}}}In case of write streams, the input of the transform block is a virtual stream of written elements and the output is the underlying destination stream. The block will be invoked as many times as necessary to consume any written elements, or until an Incomplete is raised by the destination. Again depending on the specifics of the transformation the contentsSpecies may have to be set explicitly (the collection used by the buffer backing the virtual input stream must be able accommodate any written elements).{{{	(String new writing transforming: byte2hex)		contentsSpecies: ByteArray;		write: bytes;		conclusion}}}Note that in order to allow writing transformation blocks for write streams the same way as for read streams, the write stream has to be backed up by a background process, which allows suspending the execution of the transformation block in case it needs to wait for more elements to be written. The benefit is that the same transformation block can be used on both read and write stream without change to perform the same transformation. This highly elaborate implementation has its costs and complexities which are better to be avoided if possible. Therefore the transform stream should be used only easy tasks and prototyping. Especially for simple transformations it is highly recommended to create a dedicated transform stream class to simplify the runtime characteristics. Creating custom stream classes is intentionally very simple for these exact reasons.	== Duplicating ==Duplicating streams copy the contents flowing through into a provided write stream. The duplicate write stream is specified as an argument at creation.{{{		| copy |		copy := ByteArray new writing.		((0 to: 15) reading duplicating: copy) rest -> copy conclusion}}}{{{		| original copy |		original := Array new writing.		copy := ByteArray new writing.		(original duplicating: copy) write: (0 to: 15).		original conclusion -> copy conclusion	}}}	== CType Import/Export (Interpreting) ==Interpreting streams convert specific types of objects to/from bytes of corresponding primitive C-type, i.e. they assign designated "interpretation" to the bytes (terminology borrowed from UninterpretedBytes and associated suite of primitives employed by these streams). Supported C-types are defined by the Interpretations shared variable on class InterpretedBytes. The streams are created with message #interpreting: with argument being a Symbol denoting the C-type in the Interpretations registry, e.g. #float, #double, #unsignedChar, etc.InterpretedWriteStream converts consumed elements into bytes of pre-configured (primitive) CType, e.g. float, long etc. The type of written elements must match the C-type and the underlying destination must be binary. InterpretReadStream performs the inverse transformation, converting bytes from a binary source according to the pre-configured (primitive) CType, e.g. float, long etc. It produces elements of corresponding class, e.g. #float -> Float, #double -> Double, etc.{{{	doubles := [ Random new next ] reading.	bytes := (ByteArray new writing interpreting: #double)		write: 10 from: doubles;		conclusion.	(bytes reading interpreting: #double) read: 10}}}	== Marshaling ==Marshaling streams are used to encode arbitrary smalltalk objects into a sequence of bytes suitable for binary storage or transport. The format of the binary encoding is defined by an ObjectMarshaler and is identified by particular version ID. Custom marshalers can be derived from ObjectMarshaler. Custom marshaling formats must declare their own (unique) version ID.{{{	object := 5 @ 5 extent: 5 @ 5.	bytes := ByteArray new writing marshaling put: object; conclusion.	bytes reading marshaling get}}}DbIdentifier: bear73DbTrace: 499145DbUsername: tkoganDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Substreams' '') #(#any 'Protocols-Common' ''))MonticelloPrefix: XTPackageName: Xtreams-TransformsParcel: #('Xtreams-Transforms')ParcelName: Xtreams-TransformsPrerequisiteDescriptions: #(#(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package) #(#name 'Protocols-Common' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Support' '') #('Xtreams-Core' '') #('Xtreams-Substreams' '') #('Protocols-Common' ''))PrintStringCache: (8.3 - 2,tkogan)Url: http://www.squeaksource.com/Xtreams/Xtreams-Transforms-nice.7.mczVersion: 8.3 - 2Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>EncodeWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>encoder buffer bufferReading bufferWriting decodedLineEnd encodedLineEnd </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			private OS.*			</imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.EncodeWriteStream</class-id><body>Accepts characters, converts them to bytes (0..255) using pre-configured encoding and writes the bytes into destination. Unless set to lineEndTransparent, converts any CRs into configured line-end convention (LF or CRLF).Instance Variables	encoder	&lt;Encoder&gt; converts characters to bytes	buffer	&lt;Buffer on: ByteArray&gt; batch writing buffer	bufferReading	&lt;ReadStream&gt; read stream on buffer	bufferWriting	&lt;WriteStream&gt; write stream on buffer	decodedLineEnd	&lt;Character&gt; CR or nil if transparent	encodedLineEnd	&lt;ByteArray&gt; encoded bytes of CR in the configured convention (LF or CRLF), or nil if transparent</body></comment><class><name>TransformReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer bufferWriting sourceAtEnd block closeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.TransformReadStream</class-id><body>Transform read stream provides the most expressive form of transformation. The transformation is described by a binary block that is given two arguments, @input and @output. Both @input and @output are streams themselves. The block can read arbitrary amount of elements from @input (including none) and write arbitrary amount of elements into @output (including none).The block will be invoked as many times as necessary to produce the required number of elements, or until an Incomplete is raised. Consequently if the block handles Incomplete from the input, it has to raise another Incomplete at some point, otherwise the stream will never end.	Note that if the contentSpecies of the source doesn't fit the output of the transformation, the #contentsSpecies of the transform stream has to be set explicitly. The #contentSpecies determines the type of collection employed by the internal buffer that is used as the storage for the virtual output stream of the transformation block. In some cases it might be desirable to tweak the buffering strategy of the virtual output stream. In that case the buffer of the stream can be set manually to any kind of Buffer that matches the requirements of the transformation.	The closing behavior of the stream can be customized through the closeBlock. The default closeBlock simply propagates #close to the source as with any other transform stream.Instance Variables	buffer	&lt;Buffer&gt; holds the contents of the virtual ouput stream	bufferWriting	&lt;BufferWriteStream&gt; the virtual output stream that is passed to the transformation block as the second argument	sourceAtEnd	&lt;Boolean&gt; flag indicating that the source has signalled an Incomplete	block	&lt;BlockClosure&gt; binary transformation block that reads elements from input (first argument) and writes elements into output (second argument)	closeBlock	&lt;BlockClosure&gt; binary block invoked in response to the #close message, allows customizing the close behavior</body></comment><class><name>StoreStringMarshaler</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.StoreStringMarshaler</class-id><body>StoreStringMarshaler defines the utf8 encoded string format for various object types it is meant to support. this marshaler uses the Smalltalk storeString capability to store objects as utf8 on a stream. Its format is simple; the length of the storeString printed as an Integer, followed by a LF; then the storeString itself followed by an LF. The header of the stream is an ascii encoded name of the encoder used for the rest of the stream, the default being UTF8. This is followed by an LF.Unlike the generic ObjectMarshaler, this marshaler cannot marshal recursively, nor can it marshal CompiledMethods or Processes or the Transcript. Only objects that can be safely printed with #storeString can be marshaled using this marshaler.Instance Variables	encoding	&lt;ByteSymbol&gt;	description of encoding</body></comment><class><name>ASCIIEncoder</name><environment>Xtreams</environment><super>Xtreams.Encoder</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.ASCIIEncoder</class-id><body>Implements ASCII encoding.</body></comment><class><name>JSONReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.JSONReadStream</class-id><body>Instance Variables	next	&lt;Character&gt; look-ahead cache</body></comment><class><name>MessagePackMarshaler</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unmarshaling marshaling analysing </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Pragma			</imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.MessagePackMarshaler</class-id><body>MessagePackMarshaler defines the binary format of the MessagePack protocol ( http://wiki.msgpack.org/display/MSGPACK/Format+specification ), which is a binary JSON. It can marshal simple objects, but not whole classes, just like JSON. It is considered to be a very fast marshaler because of its lightweight protocol. It cannot handle circular references.Instance Variables	analysing	&lt;Object&gt;	analysing operations	marshaling	&lt;Dictionary&gt;	marshaling operations	unmarshaling	&lt;(Array of: (BlockClosure))&gt;	unmarshaling operations</body></comment><class><name>DuplicateWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>duplicate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.DuplicateWriteStream</class-id><body>Duplicates contents flowing through the stream into a secondary write stream.Instance Variables	duplicate	&lt;WriteStream&gt; stream to duplicate the content to</body></comment><class><name>ObjectReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>marshaler objects float double uint16 uint32 uint64 int64 int8 int16 int32 referenced realized </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.ObjectReadStream</class-id><body>Unmarshals objects from binary source, previously marshaled using the same ObjectMarshaler. The bytes must start with marshaler version ID.Instance Variables	marshaler	&lt;ObjectMarshaler&gt; performs marshaling of object bodies	objects		&lt;Array&gt; retains unmarshaled objects for resolution of backward references (to preserve identity)	longs		&lt;InterpretedReadStream&gt; (internal) for reading of longs	longlongs	&lt;InterpretedReadStream&gt; (internal) for reading of longlongs	floats		&lt;InterpretedReadStream&gt; (internal) for reading of floats	doubles		&lt;InterpretedReadStream&gt; (internal) for reading of doubles	realized		&lt;ByteArray&gt;	a bitfield that indicates if an object is realized in objects or if it's uninitialized still	referenced	&lt;ByteArray&gt;	a bitfield that indicates if an object has been referenced by another object to help optimize circular reference resolution</body></comment><class><name>JSON</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.JSON</class-id><body>Marshaler stand-in that creates JSON (http://www.ietf.org/rfc/rfc4627.txt) streams when passed as argument of #marshaling:. Also a utility class for JSON processing.</body></comment><class><name>CollectReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>block cache contentsSpecies direct </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.CollectReadStream</class-id><body>Converts elements being read using the provided conversion block. When the contentSpecies of the source doesn't match the desired contentSpecies of this stream, we optimize bulk reads by reading into an internal buffer.Instance Variables	block	&lt;BlockClosure&gt; collecting block (same style as collect: blocks)	cache	&lt;SequenceableCollection | nil&gt; caches elements before transformation when direct is false	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream	direct	&lt;Boolean&gt; are we using an intermediate buffer (when source's contentSpecies doesn't match ours)</body></comment><class><name>ObjectMarshaler</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes read write version rehash analyse immediate classesMutex </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Pragma			</imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.ObjectMarshaler</class-id><body>Marshaler defines the binary format for various object types it is meant to support. This one defines generic marshaling format for arbitrary Smaltalk objects, named STST 2.0. It is used as the default marshaler for marshaling streams. It is designed to be reasonably compact and fast to marshal / unmarshal. Objects have no persistent identity between transactions, but do within a transaction to allow for recursion.Record Format:	&lt;class record&gt; &lt;object record&gt;Class Format:	Class name is only included if this is the first reference to a class id that isn't known by the terminals.	&lt;class id : integer&gt; (&lt;class absoluteName : string&gt; &lt;class isMeta : 0 = false, 1 = true&gt;)?Object Format:	Object id is not included if the object is an immediate, in which case the object body is always included.	Object body is not included if the object is has previously been shared between the terminals in this transaction.	&lt;object id : integer&gt;? &lt;object body&gt;?		Object Body Formats:	integers:		0 .. 252											one byte		-2147483647 .. 2147483648						four bytes		-9223372036854775807 .. 9223372036854775808	eight bytes		larger integers									a stringified base 36 number		float												four bytes		double											eight bytes	true / false / nil:		No space beyond the record entry	class:		A repeat of the Class Format	characters:		&lt;character : integer&gt;	strings:		&lt;string size : integer&gt; &lt;characters : character&gt;*	bytes / uninterpreted bytes:		&lt;byte array size: integer&gt; &lt;bytes : one byte&gt;*	collection:		&lt;collection size : integer&gt; &lt;elements : record&gt;*	dictionary / keyed collection:		&lt;dictionary size : integer&gt; (&lt;key : record&gt; &lt;value : record&gt;)*	object:		The basicSize is only included if the object class isVariable		&lt;basicSize : integer&gt;? &lt;instance variables : record)* (basic variables : record)*Example Records:	true:		21 (true)	128:		19 (SmallInteger) 128	'test':		4 (ByteString) 1 (object id) 4 (string length) 116 $t 101 $e 115 $s 116 $t	5 asValue:		23 (ValueHolder) 29 (class name length) ...29.. ('Root.Smalltalk.UI.ValueHolder') 0 (not meta) 1 (object id)			22 (nil)			19 (SmallInteger) 5	(5 @ 6):		18 (Point) 1 (object id)			19 (SmallInteger) 5			19 (SmallInteger) 6	(Array with: 5 asValue with: 5 asValue):		1 (Array) 1 (object id) 2 (array length)			23 (ValueHolder) 29 (class name length) ...29.. ('Root.Smalltalk.UI.ValueHolder') 0 (not meta) 2 (object id)				22 (nil)				19 (SmallInteger) 5			23 (ValueHolder) 3 (object id)				22 (nil)				19 (SmallInteger) 5Instance Variables	classes	&lt;Array of: Class&gt; maps class IDs to classes	read	&lt;Dictionary key: Class value: Symbol&gt; maps classes to methods to use to unmarshal	write	&lt;Dictionary key: Class value: Symbol&gt; maps classes to methods to use to marshal	version	&lt;ByteArray&gt; version id, e.g. (STST 2.0)	rehash	&lt;Array of: Class&gt; list of classes that need to be rehashed after unmarshaling	analyse	&lt;Array of: Symbol&gt; maps class IDs to corresponding analysing method selector	immediate	&lt;Array of: Boolean&gt; maps class IDs to value of #hasImmediateInstances for that classHow to extend the class behaviorLet's take as an example Protocols.Struct objects. Do the following steps:- implement encoding: add method ObjectMarshaler&gt;&gt;put: writing struct: aStruct	&lt;writes: 'Protocols.Struct'&gt;	"implement encoding"- implement decoding: add method ObjectMarshaler&gt;&gt;get: reading struct: aStruct	&lt;reads: 'Protocols.Struct'&gt;	"implement decoding"- implement an analysis on the stream encoded contents to ensure it has integrityObjectMarshaler&gt;&gt;analyse: reading struct: aStruct	&lt;analyse: 'Protocols.Struct'&gt;Example:	"Encoding Struct"	marshaler := Xtreams.ObjectMarshaler new.	stream := ByteArray new writing.	marshaling := stream marshaling: marshaler.	marshaling put: ((Protocols.Struct name: 'Test')					x1: 'testX1';					x2: 'testX2';					yourself).	bytes := stream conclusion.	"Checking encoding"	log := String new writing.	(Xtreams.ObjectAnalyseStream on: bytes reading marshaler: marshaler class new) do: [:each | log write: each].	log conclusion inspect.'0+11	header11+93	class id: 38 class: Protocols.Struct object id: 2	11+1	class id: 38	12+1	object id: 2	13+91	struct: Protocols.Struct size: 2		14+7	name			14+7	class id: 5 class: Core.ByteString object id: 3 rehash				14+1	class id: 5.............................'	"Decoding Struct"	marshaling := bytes reading marshaling: marshaler class new.	marshaling get inspect</body></comment><class><name>InterpretedReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>elementSize cache cacheSize operation contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.InterpretedReadStream</class-id><body>Interprets bytes from a binary source as values of preconfigured (primitive) CType, e.g. float, long etc.Instance Variables	elementSize	&lt;Integer&gt; byte size of elements of the pre-configured CType	cache	&lt;InterpretedBytes&gt; caches bulk read bytes before interpreting for speed; size = elementSize * cacheSize	cacheSize	&lt;SmallInteger&gt; how many elements (not bytes) do we want to cache	operation	&lt;BlockClosure&gt; CType translation primitive used to read from the buffer	contentsSpecies	&lt;Class&gt; collection type to use to hold collections of elements</body></comment><class><name>JSONWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>depth </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Pragma			</imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.JSONWriteStream</class-id><body>JSON encoderInstance Variables:	depth &lt;Number&gt; maximum object traversal depthShared Variables	ActionMap	&lt;IdentityDictionary key: Class value: BlockClosure&gt; maps classes to corresponding marshaling actions</body></comment><class><name>InterpretedWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>elementSize cache cacheSize operation contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.InterpretedWriteStream</class-id><body>Converts consumed elements into bytes of pre-configured (primitive) CType, e.g. float, long etc. The type of the written elements must match the CType, the underlying destination must be binary.Instance Variables	elementSize	&lt;Integer&gt; byte size of elements of the pre-configured CType	cache	&lt;InterpretedBytes&gt; caches the bytes so that they can be bulk written	cacheSize	&lt;SmallInteger&gt; how many elements (not bytes) do we want to cache	operation	&lt;BlockClosure&gt; CType translation primitive used to write into the buffer	contentsSpecies	&lt;Class&gt; collection type to use to hold collections of elements</body></comment><class><name>ObjectAnalyseStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>marshaler log depth objects int8 int16 int32 int64 uint16 uint32 uint64 float double </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><class><name>EncodeReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>transparent crPreceeding encoder buffer bufferWriting bufferReading </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.EncodeReadStream</class-id><body>Converts bytes into characters using pre-configured encoding. At the same time, if set to lineEndAuto (default) it can perform line-end translation, converting any line-end convention into CRs. The source stream must provide bytes (0...255).Instance Variables	transparent	&lt;Boolean&gt; should the stream perform line-end translations	crPreceeding	&lt;Boolean&gt; was previous character read a CR (used when not transparent)	encoder	&lt;Encoder&gt; converts bytes to characters	buffer	&lt;Buffer on: ByteArray&gt; used to optimize bulk reads	bufferWriting	&lt;WriteStream&gt; write stream on buffer	bufferReading	&lt;ReadStream&gt; read stream on buffer</body></comment><class><name>ObjectWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>marshaler objects int16 int32 int64 uint16 uint32 uint64 float double int8 id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.ObjectWriteStream</class-id><body>Marshals objects into a binary destination using the associated ObjectMarshaler. The marshaler version ID is emited at the beginning.Instance Variables	marshaler	&lt;ObjectMarshaler&gt; performs marshaling of object bodies	objects	&lt;Dictionary&gt; retains unmarshaled objects for resolution of backward references (to preserve identity)	id		&lt;Integer&gt;	the next object id to assign when writing objects	longs	&lt;InterpretedReadStream&gt; (internal) for reading of longs	longlongs	&lt;InterpretedReadStream&gt; (internal) for reading of longlongs	floats	&lt;InterpretedReadStream&gt; (internal) for reading of floats	doubles	&lt;InterpretedReadStream&gt; (internal) for reading of doubles</body></comment><class><name>DuplicateReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>duplicate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.DuplicateReadStream</class-id><body>Duplicates contents flowing through the stream into a secondary write stream.Instance Variables	duplicate	&lt;WriteStream&gt; stream to duplicate the content to</body></comment><class><name>ISO8859L1Encoder</name><environment>Xtreams</environment><super>Xtreams.Encoder</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Xtreams-Transforms</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.ISO8859L1Encoder</class-id><body>Implements ISO-8859-1 (Latin 1) encoding.</body></comment><class><name>TransformWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer block closeBlock process incompleteCount readReady writeReady closeReady </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.TransformWriteStream</class-id><body>Transform write stream provides the most expressive form of transformation. The transformation is described by a binary block that is given two arguments, @input and @output. The @input is a virtual stream of elements written into the stream. The @output is the destination stream under the transform stream. The block can read arbitrary amount of elements from @input (including none) and write arbitrary amount of elements into @output (including none). The block will be invoked as many times as necessary to consume everything written into the stream, or until an Incomplete is raised by the destination.The closing behavior of the stream can be customized through the closeBlock. The default closeBlock simply propagates #close to the destination as with any other transform stream.In some cases it might be desirable to tweak the buffering strategy of the virtual input stream. In that case the buffer of the stream can be set manually to any kind of Buffer that matches the requirements of the transformation.From the point of view of the API, the TransformWriteStream is very much like the TransformReadStream. Notably any valid transform block should work the same way on either read or write stream without modification. However to preserve the invariants and expressivity of the transform block, the implementation is vastly different. Primarily it is necessary to convert all the writes into a virtual stream of written elements that can be passed into the transform block as the input stream. Consequently the transformation itself needs to be suspended if there weren't enough elements written yet, to complete an iteration of the transform block. Therefore it needs to run in its own process. Any writes get redirected into an internal buffer and a background process repeatedly invokes the transform block to drain the contents of the buffer and produces output into the destination. Obviously buffer access has to be synchronized between any writing threads and the background process. The readReady/writeReady semaphores work in a lock-step mode, to interleave the background buffer draining with any writes.This highly elaborate implementation has its costs and complexities which are better to be avoided if possible. Therefore the transform stream should be used only to prototype a transformation. Especially for simple transformations it is highly recommended to create a dedicated transform stream class to simplify the runtime characteristics. Creating custom stream classes is intentionally very simple for these exact reasons.Instance Variables	buffer	&lt;Buffer&gt; holds the contents of the virtual input stream	block	&lt;BlockClosure&gt; binary transformation block that reads elements from input (first argument) and writes elements into output (second argument)	closeBlock	&lt;BlockClosure&gt; binary block invoked in response to the #close message, allows customizing the close behavior	process	&lt;Process&gt; background process that runs the transformation block	incompleteCount	&lt;Integer&gt; indicates that the transformation raised or received Incomplete and how many elements were actually consumed by the transformation block so that we can reraise Incomplete with correct count in the client thread	readReady	&lt;Semaphore&gt; signals to the background process that elements were written into the buffer	writeReady	&lt;Semaphore&gt; gates any writes into the stream, making sure background process is not draining the buffer at the same time	closeReady	&lt;Semaphore&gt; signals back to the user thread that the background process finished draining the buffer and the stream is properly closed, so the #close call can return</body></comment><class><name>CollectWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>block cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms</package></attributes></class><comment><class-id>Xtreams.CollectWriteStream</class-id><body>Converts written elements using the provided conversion block. Optimizes bulk writes by batching the conversion results, allowing the destination stream to perform bulk writes as well.Instance Variables	block	&lt;BlockClosure&gt; collecting block (same style as collect: blocks)	cache	&lt;SequenceableCollection&gt; caches results after transformation so that they can be bulk written too</body></comment><shared-variable><name>Whitespace</name><environment>Xtreams.JSONReadStream</environment><private>false</private><constant>false</constant><category>constants</category><initializer>String with: Character tab with: Character space with: Character cr with: Character lf</initializer><attributes><package>Xtreams-Transforms</package></attributes></shared-variable><shared-variable><name>ActionMap</name><environment>Xtreams.JSONWriteStream</environment><private>false</private><constant>false</constant><category>configuration</category><attributes><package>Xtreams-Transforms</package></attributes></shared-variable><shared-variable><name>MaxObjectDepth</name><environment>Xtreams.JSONWriteStream</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>50</initializer><attributes><package>Xtreams-Transforms</package></attributes></shared-variable><methods><class-id>Xtreams.EncodeWriteStream</class-id> <category>line-end</category><body package="Xtreams-Transforms">setLineEndAuto	IOAccessor defaultClass = PCIOAccessor		ifTrue:	[self setLineEndCRLF]		ifFalse:	[self setLineEndLF]</body><body package="Xtreams-Transforms">setLineEndCRLF	| stream |	decodedLineEnd := Character cr.	stream := ByteArray new writing.	encoder encode: Character cr on: stream; encode: Character lf on: stream.	encodedLineEnd := stream contents</body><body package="Xtreams-Transforms">setLineEndLF	| stream |	decodedLineEnd := Character cr.	stream := ByteArray new writing.	encoder encode: Character lf on: stream.	encodedLineEnd := stream contents</body><body package="Xtreams-Transforms">setLineEndTransparent	decodedLineEnd := nil.	encodedLineEnd := nil</body></methods><methods><class-id>Xtreams.EncodeWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">close	buffer isNil ifTrue: [^self].	super close.	buffer recycle.	buffer := nil</body><body package="Xtreams-Transforms">contentsSpecies	^ByteString</body><body package="Xtreams-Transforms">on: aSource encoding: anEncoding	super on: aSource.	encoder := Encoder for: anEncoding.	buffer := RingBuffer new: DefaultBufferSize class: ByteArray.	bufferReading := buffer reading.	bufferWriting := buffer writing.	self setLineEndAuto</body></methods><methods><class-id>Xtreams.EncodeWriteStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">encoder	^encoder</body><body package="Xtreams-Transforms">write: anInteger from: aSequenceableCollection at: startIndex	| character |	startIndex to: startIndex + anInteger - 1 do:  [:index |		buffer writeSize &lt; 10 ifTrue: [destination write: buffer readSize from: bufferReading].		character := aSequenceableCollection at: index.		character == decodedLineEnd			ifTrue:	[bufferWriting write: encodedLineEnd]			ifFalse:	[encoder encode: character on: bufferWriting]].	destination write: buffer readSize from: bufferReading.	^anInteger</body></methods><methods><class-id>Xtreams.EncodeWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aDestination encoding: anEncoding	^self new on: aDestination encoding: anEncoding</body></methods><methods><class-id>Xtreams.TransformReadStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">block	^block</body><body package="Xtreams-Transforms">buffer	^buffer</body><body package="Xtreams-Transforms">closeBlock	^closeBlock</body><body package="Xtreams-Transforms">get	(self fillBufferIfRequired: 1) ifFalse: [Incomplete zero raise].	^buffer get</body><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	| count read |	anInteger isZero ifTrue: [^0].	count := 0.	[count &lt; anInteger] whileTrue:		[(self fillBufferIfRequired: anInteger - count) ifFalse: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].		read := (anInteger - count) min: buffer readSize.		buffer read: read into: aSequenceableCollection at: startIndex + count.		count := count + read].	^anInteger</body></methods><methods><class-id>Xtreams.TransformReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">buffer: aBuffer	buffer recycle.	buffer := aBuffer.	bufferWriting := buffer writing</body><body package="Xtreams-Transforms">close	buffer ifNil: [^self].	sourceAtEnd := true.	closeBlock cull: source cull: self.	buffer recycle.	buffer := nil</body><body package="Xtreams-Transforms">closeBlock: anObject	closeBlock := anObject</body><body package="Xtreams-Transforms">contentsSpecies	^buffer contentsSpecies</body><body package="Xtreams-Transforms">contentsSpecies: aClass	self buffer: (buffer class new: buffer cacheSize class: aClass)</body><body package="Xtreams-Transforms">on: aReadStream block: aBlock		self on: aReadStream.	block := aBlock.	closeBlock := [ :sourceStream | sourceStream close].	sourceAtEnd := false.	buffer := ElasticBuffer new: DefaultBufferSize class: aReadStream contentsSpecies.	bufferWriting := buffer writing</body></methods><methods><class-id>Xtreams.TransformReadStream</class-id> <category>printing</category><body package="Xtreams-Transforms">streamingPrintOn: aStream	super streamingPrintOn: aStream.	aStream		space;		write: '#';		write: block method homeMethod selector;		write: ' buffered: ';		print: buffer readSize.	buffer readSize isZero ifTrue: [^self].	aStream		cr; tab;		print: buffer contentsFuture</body></methods><methods><class-id>Xtreams.TransformReadStream</class-id> <category>private</category><body package="Xtreams-Transforms">fillBuffer: anInteger"	We have exhausted our buffer, so fill it up again from our inner stream. Do not read more than is available from the inner stream or more than was originally requested. But try to be as greedy as possible, since filling our buffer is faster than always re-filling our buffer with one object at a time. Also, cap it at @bufferSize, because if we're reading from in-memory or on-disk sources, all the data will be immediately available - which could be gigs worth. We don't want to pull all of that in to our buffer.	The semantics of our block are interesting. We give it both an input and an output stream. The block must write something to the output stream otherwise we assume this means we're at the end of the stream. It does not need to read from the input stream, but if it does and that stream fires EndOfStream, that also marks us as end of stream."	| count available |	count := 0.	[[available := buffer readSize.	block value: source value: bufferWriting.	count := count + (buffer readSize - available).	count &gt;= anInteger ifTrue: [^self].	buffer hasSpaceToWrite ifFalse: [^self]]		repeat]			on: Incomplete do: [:ex | ^sourceAtEnd := true].</body><body package="Xtreams-Transforms">fillBufferIfRequired: anInteger"	If we have any data available in our buffer, return true. If not, attempt to fill up our buffer and return true if that worked. Try not to fill the buffer more than was originally requested (@anInteger), but we make sure we only fill up to what's available from our inner stream. We don't guarantee we'll fill our buffer up to @anInteger's worth, just that we'll attempt to fill the buffer."	buffer ifNil: [^false].	buffer hasDataToRead ifTrue: [^true].	sourceAtEnd ifTrue: [^false].	self fillBuffer: anInteger.	^buffer hasDataToRead</body></methods><methods><class-id>Xtreams.TransformReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aReadStream block: block	^self new on: aReadStream block: block</body></methods><methods><class-id>Xtreams.StoreStringMarshaler</class-id> <category>configuration</category><body package="Xtreams-Transforms">configureAnalyse: reading	self notYetImplemented</body><body package="Xtreams-Transforms">configureMarshal: writing	encoding := #utf8.	(writing encoding: #ascii)		setLineEndLF;		write: encoding;		cr;		flush.	^false</body><body package="Xtreams-Transforms">configureUnmarshal: reading	encoding := ((reading encoding: #ascii) ending: Character cr) rest asSymbol.	^false</body><body package="Xtreams-Transforms">streamingMarshal: stream	^ObjectWriteStream on: stream marshaler: self</body><body package="Xtreams-Transforms">streamingUnmarshal: stream	^ObjectReadStream on: stream marshaler: self</body></methods><methods><class-id>Xtreams.StoreStringMarshaler</class-id> <category>api</category><body package="Xtreams-Transforms">analyse: reading	self notYetImplemented</body><body package="Xtreams-Transforms">marshal: writing object: object	| storeString |	storeString := object storeString.	(writing encoding: encoding)		setLineEndLF;		print: storeString size + 1;		cr;		write: storeString;		cr</body><body package="Xtreams-Transforms">unmarshal: reading	| encoded size storeString |	encoded := reading encoding: encoding.	size := Integer readFrom: (encoded ending: Character cr) rest readStream.	size = 0 ifTrue: [Incomplete zero raiseSignal].	storeString := (encoded limiting: size) rest.	^Kernel.Compiler evaluate: storeString</body></methods><methods><class-id>Xtreams.ASCIIEncoder</class-id> <category>accessing</category><body package="Xtreams-Transforms">decodeFrom: aReadStream	| value |	^(value := aReadStream get) &lt; 128		ifTrue: [ Character value: value ]		ifFalse: [ self error: 'Illegal value!' ]</body><body package="Xtreams-Transforms">encode: aCharacter on: aWriteStream	| value |	(value := aCharacter asInteger) &lt; 128		ifTrue: [ aWriteStream put: value ]		ifFalse: [ self error: 'Illegal character!' ]</body></methods><methods><class-id>Xtreams.ASCIIEncoder class</class-id> <category>class initialization</category><body package="Xtreams-Transforms">initialize	self encoders		at: #ascii put: self new;		at: #ASCII put: self new</body></methods><methods><class-id>Xtreams.JSONReadStream</class-id> <category>private-parsing</category><body package="Xtreams-Transforms">parseArray	| array |	self next = $[ ifFalse: [self error: 'Failed parsing array'].	array := Array new writing.	self skipWhitespace.	[	self peekNext = $]	] whileFalse: [		array put: self get.		(self skipWhitespace; peekNext) = $, ifTrue: [			self next; skipWhitespace ] ].	self next.	^array close; terminal</body><body package="Xtreams-Transforms">parseFalse	(self next: 5) = 'false' ifTrue: [^false].	self error: 'Failed parsing false'</body><body package="Xtreams-Transforms">parseInteger: aBlock		| number char digits |	number := 0.	digits := 0.	[	[ (char := self next) isDigit ] whileTrue: [			digits := digits + 1.			number := number * 10 + (char asInteger - 48 "$0 asInteger") ].		next := char.	] on: Incomplete do: [ :ex | digits &gt; 0 ifFalse: [ ex pass ] ].	^aBlock value: number value: digits</body><body package="Xtreams-Transforms">parseNull	(self next: 4) = 'null' ifTrue: [^nil].	self error: 'Failed parsing null'</body><body package="Xtreams-Transforms">parseNumber		| number negated exponent |	number := self parseInteger: [ :int :digits | int ].	next = $. ifFalse: [ ^number ].	next := source get.	number := (self parseInteger: [ :int :digits | (10.0d ** digits negated) * int ]) + number.	('eE' includes: next) ifFalse: [ ^number ].	negated := source get = $-.	next := source get.	exponent := self parseInteger: [ :int :digits | int ].	negated ifTrue: [ exponent := exponent negated ].	^number * (10.0d ** exponent)</body><body package="Xtreams-Transforms">parseObject	| object |	self next = ${ ifFalse: [ self error: 'Failed parsing object' ].	object := Dictionary new.	self skipWhitespace.	[	self peekNext = $}	] whileFalse: [ | key value |		key := self parseString.		(self skipWhitespace; next) = $: ifFalse: [ self error: 'Failed parsing object' ].		value := self skipWhitespace; get.		object at: key asSymbol put: value.		(self skipWhitespace; peekNext) = $, ifTrue: [			self next; skipWhitespace] ].	self next.	^object</body><body package="Xtreams-Transforms">parseSpecialCharacter	| c |	c := self next.	c = $\ ifTrue: [^$\].	c = $" ifTrue: [^$"].	c = $/ ifTrue: [^$/].	c = $b ifTrue: [^Character backspace].	c = $f ifTrue: [^Character newPage].	c = $n ifTrue: [^Character lf].	c = $r ifTrue: [^Character cr].	c = $t ifTrue: [^Character tab].	c = $u ifTrue: [^self parseUnicodeCodePoint: (self next: 4) asLowercase].	self error: 'Failed parsing special character'</body><body package="Xtreams-Transforms">parseString	| string c |	string := String new writing.	self next = $" ifFalse: [self error: 'Failed parsing String'].	[	(c := self next) = $"	] whileFalse: [		c = $\ ifTrue: [ c := self parseSpecialCharacter ].		string put: c ].	^string close; terminal</body><body package="Xtreams-Transforms">parseTrue	(self next: 4) = 'true' ifTrue: [^true].	self error: 'Failed parsing true'</body><body package="Xtreams-Transforms">parseUnicodeCodePoint: digits	| hex codePoint |	hex := '0123456789abcdef'.	codePoint := digits inject: 0 into: [ :nr :c | nr * 16 + (hex indexOf: c) - 1 ].	^codePoint asCharacter</body></methods><methods><class-id>Xtreams.JSONReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">contentsSpecies		^Array</body></methods><methods><class-id>Xtreams.JSONReadStream</class-id> <category>private</category><body package="Xtreams-Transforms">next	^next ifNil: [ source get ]		ifNotNil: [ :c | next := nil. c ]</body><body package="Xtreams-Transforms">next: count	^next		ifNil: [ source read: count ]		ifNotNil: [ | out |			out := (String new: count) writing.			out put: self next.			out write: count - 1 from: source.			out close; terminal ]</body><body package="Xtreams-Transforms">peekNext	^next ifNil: [ next := source get ]</body><body package="Xtreams-Transforms">skipWhitespace	| c |	[ Whitespace includes: (c := self next) ] whileTrue.	next := c</body></methods><methods><class-id>Xtreams.JSONReadStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">get	| negated |	self skipWhitespace.	next := self next.	next = ${ ifTrue: [^self parseObject].	next = $[ ifTrue: [^self parseArray].	next = $" ifTrue: [^self parseString].	next = $n ifTrue: [^self parseNull].	next = $t ifTrue: [^self parseTrue].	next = $f ifTrue: [^self parseFalse].	negated := false.	next = $- ifTrue: [ next := source get. negated := true].	next isDigit ifTrue: [ | number |		number := self parseNumber.		^negated ifTrue: [number negated] ifFalse: [number]].	self error: 'Invalid JSON'</body><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	| read |	read := 0.	[	[ read &lt; anInteger ] whileTrue: [ aSequenceableCollection at: startIndex + read put: self get ]	] on: Incomplete do: [ :ex | (Incomplete count: read) raise ].	^read</body></methods><methods><class-id>Xtreams.MessagePackMarshaler</class-id> <category>api</category><body package="Xtreams-Transforms">analyse: reading	| type |	type := reading uint8 get.	type &lt;= 16rBF ifTrue: [		| fixMapOrArray |		type &lt;= 16r7F ifTrue: [^reading log: 'positive fixnum' do: [type]].		fixMapOrArray := type bitShift: -4.		fixMapOrArray = 2r1001 ifTrue: [^reading log: 'fix array' do: [(1 to: (type bitAnd: 2r00001111)) collect: [:i | self analyse: reading]]].		fixMapOrArray = 2r1000 ifTrue: [			^reading log: 'fix map' do: [				| map |				map := Dictionary new.				(type bitAnd: 2r00001111) timesRepeat: [					map at: (self analyse: reading) put: (self analyse: reading)].				map]].		^reading log: 'fix raw' do: [reading uint8 read: (type bitAnd: 2r00011111)]].	(type bitShift: -5) = 2r111 ifTrue: [^reading log: 'negative fixnum' do: [-32 + (type bitAnd: 2r00011111)]].	^reading log: (type printStringRadix: 16) do: [(analysing at: type) value: reading]</body><body package="Xtreams-Transforms">marshal: writing object: object	(marshaling at: object class ifAbsent: [self error: 'Unmarshalable class with the MessagePack protocol']) value: writing value: object</body><body package="Xtreams-Transforms">unmarshal: reading	| type |	type := reading uint8 get.	type &lt;= 16rBF ifTrue: [		| fixMapOrArray |		type &lt;= 16r7F ifTrue: [^type].		fixMapOrArray := type bitShift: -4.		fixMapOrArray = 2r1001 ifTrue: [^(1 to: (type bitAnd: 2r00001111)) collect: [:i | self unmarshal: reading]].		fixMapOrArray = 2r1000 ifTrue: [			| map |			map := Dictionary new.			(type bitAnd: 2r00001111) timesRepeat: [				map at: (self unmarshal: reading) put: (self unmarshal: reading)].			^map].		^reading uint8 read: (type bitAnd: 2r00011111)].	(type bitShift: -5) = 2r111 ifTrue: [^-32 + (type bitAnd: 2r00011111)].	^(unmarshaling at: type) value: reading</body></methods><methods><class-id>Xtreams.MessagePackMarshaler</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">initialize	self initializeMarshaling.	self initializeUnmarshaling.	self initializeAnalysing.</body><body package="Xtreams-Transforms">initializeAnalysing	(analysing := unmarshaling copy)		at: self class array16 put: [:reading | reading log: 'array16' do: [(1 to: reading uint16 get) collect: [:i | self analyse: reading]]];		at: self class array32 put: [:reading | reading log: 'array32' do: [(1 to: reading uint32 get) collect: [:i | self analyse: reading]]];		at: self class map16 put: [:reading |			reading log: 'map16' do: [				| map |				map := Dictionary new.				reading uint16 get timesRepeat: [					map at: (self analyse: reading) put: (self analyse:reading)].				map]];		at: self class map32 put: [:reading |			reading log: 'map32' do: [				| map |				map := Dictionary new.				reading uint16 get timesRepeat: [					map at: (self analyse: reading) put: (self analyse: reading)].				map]];		yourself</body><body package="Xtreams-Transforms">initializeMarshaling	(marshaling := Dictionary new)		"singletons"		at: UndefinedObject put: [:writing :object | writing uint8 put: self class nil];		at: True put: [:writing :object | writing uint8 put: self class true];		at: False put: [:writing :object | writing uint8 put: self class false];		"numbers"		at: Float put: [:writing :object | writing uint8 put: self class float. writing float put: object];		at: Double put: [:writing :object | writing uint8 put: self class double. writing double put: object];		at: SmallDouble put: [:writing :object | writing uint8 put: self class double. writing double put: object];		yourself.	Integer allSubclassesDo: [:each |		marshaling at: each put: [:writing :object | self write: writing integer: object]].	SequenceableCollection allSubclassesDo: [:each |		marshaling at: each put: [:writing :object | self write: writing array: object]].	(KeyedCollection withAllSubclasses, Dictionary withAllSubclasses) do: [:each |		marshaling at: each put: [:writing :object | self write: writing map: object]].	(CharacterArray withAllSubclasses, IntegerArray withAllSubclasses) do: [:each |		marshaling at: each put: [:writing :object | self error: each name, ' are not supported by the MessagePack protocol']].	marshaling at: ByteArray put: [:writing :object | self write: writing raw: object]</body><body package="Xtreams-Transforms">initializeUnmarshaling	(unmarshaling := Array new: 255 withAll: [:reading | self error: 'unknown type'])		"singletons"		at: self class nil put: [:reading | nil];		at: self class true put: [:reading | true];		at: self class false put: [:reading | false];		"numbers"		at: self class uint8 put: [:reading | reading uint8 get];		at: self class uint16 put: [:reading | reading uint16 get];		at: self class uint32 put: [:reading | reading uint32 get];		at: self class uint64 put: [:reading | reading uint64 get];		at: self class int8 put: [:reading | reading int8 get];		at: self class int16 put: [:reading | reading int16 get];		at: self class int32 put: [:reading | reading int32 get];		at: self class int64 put: [:reading | reading int64 get];		at: self class float put: [:reading | reading float get];		at: self class double put: [:reading | reading double get];		"containers"		at: self class raw16 put: [:reading | reading uint8 read: reading uint16 get];		at: self class raw32 put: [:reading | reading uint8 read: reading uint32 get];		at: self class array16 put: [:reading | (1 to: reading uint16 get) collect: [:i | self unmarshal: reading]];		at: self class array32 put: [:reading | (1 to: reading uint32 get) collect: [:i | self unmarshal: reading]];		at: self class map16 put: [:reading |			| size map |			size := reading uint16 get.			map := Dictionary new: size.			size timesRepeat: [				map noCheckAdd: (self unmarshal: reading) -&gt; (self unmarshal: reading)].			map];		at: self class map32 put: [:reading |			| size map |			size := reading uint32 get.			map := Dictionary new: size.			size timesRepeat: [				map noCheckAdd: (self unmarshal: reading) -&gt; (self unmarshal: reading)].			map];		yourself</body></methods><methods><class-id>Xtreams.MessagePackMarshaler</class-id> <category>private - writing</category><body package="Xtreams-Transforms">write: writing array: array	self write: writing array_size: array size.	array do: [:each | self marshal: writing object: each]</body><body package="Xtreams-Transforms">write: writing array_size: size	size &lt;= 2r00001111 ifTrue: [^writing uint8 put: size + 2r10010000].	size &lt;= 65535 ifTrue: [		writing uint8 put: self class array16.		^writing uint16 put: size].	size &lt;= 4294967295 ifTrue: [		writing uint8 put: self class array32.		^writing uint32 put: size].	self error: 'array too big to marshal with MessagePack protocol'</body><body package="Xtreams-Transforms">write: writing integer: integer	(integer between: 0 and: 127) ifTrue: [^writing uint8 put: integer].	(integer between: -32 and: -1) ifTrue: [^writing uint8 put: integer + 256].	integer &gt;= 128 ifTrue: [		integer &lt;= 255 ifTrue: [^writing uint8 put: self class uint8; put: integer].		integer &lt;= 65535 ifTrue: [			writing uint8 put: self class uint16.			^writing uint16 put: integer].		integer &lt;= 4294967295 ifTrue: [			writing uint8 put: self class uint32.			^writing uint32 put: integer].		integer &lt;= 18446744073709551615 ifTrue: [			writing uint8 put: self class uint64.			^writing uint64 put: integer].		self error: 'integer too big to marshal with MessagePack protocol'].	integer &gt;= -128 ifTrue: [		writing uint8 put: self class int8.		^writing int8 put: integer].	integer &gt;= -32768 ifTrue: [		writing uint8 put: self class int16.		^writing int16 put: integer].	integer &gt;= -2147483648 ifTrue: [		writing uint8 put: self class int32.		^writing int32 put: integer].	integer &gt;= -9223372036854775808 ifTrue: [		writing uint8 put: self class int64.		^writing int64 put: integer].	self error: 'integer too small to marshal with MessagePack protocol'.</body><body package="Xtreams-Transforms">write: writing map: map	self write: writing map_size: map size.	map keysAndValuesDo: [:key :value |		self marshal: writing object: key.		self marshal: writing object: value]</body><body package="Xtreams-Transforms">write: writing map_size: size	size &lt;= 2r00001111 ifTrue: [^writing uint8 put: size + 2r10000000].	size &lt;= 65535 ifTrue: [		writing uint8 put: self class map16.		^writing uint16 put: size].	size &lt;= 4294967295 ifTrue: [		writing uint8 put: self class map32.		^writing uint32 put: size].	self error: 'array too big to marshal with MessagePack protocol'</body><body package="Xtreams-Transforms">write: writing raw: bytearray	self write: writing raw_size: bytearray size.	writing uint8 write: bytearray</body><body package="Xtreams-Transforms">write: writing raw_size: size	size &lt;= 2r00011111 ifTrue: [^writing uint8 put: size + 2r10100000].	size &lt;= 65535 ifTrue: [		writing uint8 put: self class raw16.		^writing uint16 put: size].	size &lt;= 4294967295 ifTrue: [		writing uint8 put: self class raw32.		^writing uint32 put: size].	self error: 'array too big to marshal with MessagePack protocol'</body></methods><methods><class-id>Xtreams.MessagePackMarshaler</class-id> <category>configuration</category><body package="Xtreams-Transforms">configureAnalyse: reading	"This protocol has fixed endianness built in"	^true</body><body package="Xtreams-Transforms">configureMarshal: writing	"This protocol has fixed endianness built in"	^true</body><body package="Xtreams-Transforms">configureUnmarshal: reading	"This protocol has fixed endianness built in"	^true</body><body package="Xtreams-Transforms">streamingMarshal: stream	^ObjectWriteStream on: stream marshaler: self</body><body package="Xtreams-Transforms">streamingUnmarshal: stream	^ObjectReadStream on: stream marshaler: self</body></methods><methods><class-id>Xtreams.MessagePackMarshaler class</class-id> <category>constants - containers</category><body package="Xtreams-Transforms">array16	^16rDC</body><body package="Xtreams-Transforms">array32	^16rDD</body><body package="Xtreams-Transforms">map16	^16rDE</body><body package="Xtreams-Transforms">map32	^16rDF</body><body package="Xtreams-Transforms">raw16	^16rDA</body><body package="Xtreams-Transforms">raw32	^16rDB</body></methods><methods><class-id>Xtreams.MessagePackMarshaler class</class-id> <category>constants - numbers</category><body package="Xtreams-Transforms">double	^16rCB</body><body package="Xtreams-Transforms">float	^16rCA</body><body package="Xtreams-Transforms">int16	^16rD1</body><body package="Xtreams-Transforms">int32	^16rD2</body><body package="Xtreams-Transforms">int64	^16rD3</body><body package="Xtreams-Transforms">int8	^16rD0</body><body package="Xtreams-Transforms">uint16	^16rCD</body><body package="Xtreams-Transforms">uint32	^16rCE</body><body package="Xtreams-Transforms">uint64	^16rCF</body><body package="Xtreams-Transforms">uint8	^16rCC</body></methods><methods><class-id>Xtreams.MessagePackMarshaler class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">new	^super new initialize</body></methods><methods><class-id>Xtreams.MessagePackMarshaler class</class-id> <category>constants - singletons</category><body package="Xtreams-Transforms">false	^16rC2</body><body package="Xtreams-Transforms">nil	^16rC0</body><body package="Xtreams-Transforms">true	^16rC3</body></methods><methods><class-id>Xtreams.DuplicateWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">contentsSpecies	^destination contentsSpecies</body><body package="Xtreams-Transforms">on: aDestination duplicate: aSecondDestination	super on: aDestination.	duplicate := aSecondDestination</body></methods><methods><class-id>Xtreams.DuplicateWriteStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">write: anInteger from: aSequenceableCollection at: startIndex	[	destination write: anInteger from: aSequenceableCollection at: startIndex	] on: Incomplete do: [ :incomplete |		duplicate write: incomplete count from: aSequenceableCollection at: startIndex.		incomplete pass ].	duplicate write: anInteger from: aSequenceableCollection at: startIndex.	^anInteger</body></methods><methods><class-id>Xtreams.DuplicateWriteStream</class-id> <category>seeking</category><body package="Xtreams-Transforms">++ anInteger	^self isPositionable		ifFalse: [super ++ anInteger]		ifTrue:			[destination ++ anInteger.			duplicate ++ anInteger]</body><body package="Xtreams-Transforms">-- anInteger	^self isPositionable		ifFalse: [super -- anInteger]		ifTrue:			[destination -- anInteger.			duplicate -- anInteger]</body><body package="Xtreams-Transforms">length	^self isPositionable		ifFalse: [super length]		ifTrue: [destination length]</body><body package="Xtreams-Transforms">position	^self isPositionable		ifFalse: [super position]		ifTrue: [destination position]</body><body package="Xtreams-Transforms">position: anInteger	^self isPositionable		ifFalse: [super position: anInteger]		ifTrue:			[destination position: anInteger.			duplicate position: anInteger]</body></methods><methods><class-id>Xtreams.DuplicateWriteStream</class-id> <category>testing</category><body package="Xtreams-Transforms">isPositionable	^destination isPositionable and: [duplicate isPositionable]</body></methods><methods><class-id>Xtreams.DuplicateWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aDestination duplicate: aSecondDestination	^self new on: aDestination duplicate: aSecondDestination</body></methods><methods><class-id>Xtreams.ObjectReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">contentsSpecies	^Array</body><body package="Xtreams-Transforms">on: aSource marshaler: aMarshaler	super on: aSource.	marshaler := aMarshaler.	int8 := aSource interpreting: #signedChar.	(marshaler configureUnmarshal: aSource)		ifTrue: [			int16 := aSource interpreting: #signedShort_be.			int32 := aSource interpreting: #signedLong_be.			int64 := aSource interpreting: #signedLonglong_be.			uint16 := aSource interpreting: #unsignedShort_be.			uint32 := aSource interpreting: #unsignedLong_be.			uint64 := aSource interpreting: #unsignedLonglong_be]		ifFalse: [			int16 := aSource interpreting: #signedShort_le.			int32 := aSource interpreting: #signedLong_le.			int64 := aSource interpreting: #signedLonglong_le.			uint16 := aSource interpreting: #unsignedShort_le.			uint32 := aSource interpreting: #unsignedLong_le.			uint64 := aSource interpreting: #unsignedLonglong_le].	float := aSource interpreting: #float.	double := aSource interpreting: #double</body></methods><methods><class-id>Xtreams.ObjectReadStream</class-id> <category>private</category><body package="Xtreams-Transforms">begin	objects := RecyclingCenter new: Xtreams.DefaultBufferSize class: Array.	objects at: 1 put: Transcript.	referenced := ByteArray new.	realized := ByteArray new.	realized bitSet: 1</body><body package="Xtreams-Transforms">complete	RecyclingCenter recycle: objects.	objects := nil.	referenced := nil.	realized := nil</body><body package="Xtreams-Transforms">grow: index	objects growToAtLeast: ((objects size + Xtreams.DefaultBufferSize) max: index)</body><body package="Xtreams-Transforms">isRealized: objectId	^(realized bitAt: objectId) == 1</body><body package="Xtreams-Transforms">isReferenced: objectId	^(referenced bitAt: objectId) == 1</body><body package="Xtreams-Transforms">objects	^objects</body><body package="Xtreams-Transforms">realize: objectId	realized bitSet: objectId</body><body package="Xtreams-Transforms">reference: objectId	referenced bitSet: objectId</body></methods><methods><class-id>Xtreams.ObjectReadStream</class-id> <category>primitives</category><body package="Xtreams-Transforms">double	^double</body><body package="Xtreams-Transforms">encoding: anEncoding	^source encoding: anEncoding</body><body package="Xtreams-Transforms">float	^float</body><body package="Xtreams-Transforms">int16	^int16</body><body package="Xtreams-Transforms">int32	^int32</body><body package="Xtreams-Transforms">int64	^int64</body><body package="Xtreams-Transforms">int8	^int8</body><body package="Xtreams-Transforms">uint16	^uint16</body><body package="Xtreams-Transforms">uint32	^uint32</body><body package="Xtreams-Transforms">uint64	^uint64</body><body package="Xtreams-Transforms">uint8	^source</body></methods><methods><class-id>Xtreams.ObjectReadStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">get	| object |	self begin.	object := marshaler unmarshal: self.	self complete.	^object</body><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	| count |	count := 0.	[anInteger timesRepeat:		[self begin.		aSequenceableCollection at: startIndex + count put: (marshaler unmarshal: self).		self complete.		count := count + 1]]			on: Incomplete do: [:exception |				self complete.				(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.ObjectReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aDestination	^self on: aDestination marshaler: ObjectMarshaler new</body><body package="Xtreams-Transforms">on: aDestination marshaler: aMarshaler	^self new on: aDestination marshaler: aMarshaler</body></methods><methods><class-id>Xtreams.JSON class</class-id> <category>private</category><body package="Xtreams-Transforms">streamingMarshal: stream	^JSONWriteStream on: stream</body><body package="Xtreams-Transforms">streamingUnmarshal: stream	^JSONReadStream on: stream</body></methods><methods><class-id>Xtreams.JSON class</class-id> <category>utility</category><body package="Xtreams-Transforms">decode: aString	| stream |	stream := aString reading marshaling: self.	^[ stream get ] ensure: [ stream close ]</body><body package="Xtreams-Transforms">encode: anObject	^(String new writing marshaling: JSON)		put: anObject;		close;		terminal</body></methods><methods><class-id>Xtreams.CollectReadStream</class-id> <category>seeking</category><body package="Xtreams-Transforms">++ anInteger	^source ++ anInteger</body><body package="Xtreams-Transforms">-- anInteger	^source -- anInteger</body><body package="Xtreams-Transforms">length	^source length</body><body package="Xtreams-Transforms">position	^source position</body><body package="Xtreams-Transforms">position: anInteger	^source position: anInteger</body></methods><methods><class-id>Xtreams.CollectReadStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">block	^block</body><body package="Xtreams-Transforms">get	^block value: source get</body><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	direct		ifTrue:	[self directRead: anInteger into: aSequenceableCollection at: startIndex]		ifFalse:	[self bufferRead: anInteger into: aSequenceableCollection at: startIndex].	^anInteger</body></methods><methods><class-id>Xtreams.CollectReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">close	| saved |	super close.	saved := cache.	cache := nil.	saved == nil ifFalse: [ saved recycle ].</body><body package="Xtreams-Transforms">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Transforms">contentsSpecies: aClass	contentsSpecies := aClass.	cache ifNotNil: [ cache recycle ].	cache := (direct := contentsSpecies == source contentsSpecies)		ifTrue:	[nil]		ifFalse:	[			source contentsSpecies newRecycled: (				(cache notNil and: [ cache size &gt; 0 ])					ifTrue: [cache size]					ifFalse: [DefaultBufferSize])]</body><body package="Xtreams-Transforms">on: aSource block: aBlock	self on: aSource.	block := aBlock.	contentsSpecies := aSource contentsSpecies.	direct := true</body></methods><methods><class-id>Xtreams.CollectReadStream</class-id> <category>testing</category><body package="Xtreams-Transforms">isPositionable	^source isPositionable</body></methods><methods><class-id>Xtreams.CollectReadStream</class-id> <category>private</category><body package="Xtreams-Transforms">bufferRead: anInteger into: aSequenceableCollection at: startIndex	| amount count read |	count := 0.	[count &lt; anInteger] whileTrue:		[amount := (anInteger - count) min: cache size.		read := [source read: amount into: cache at: 1. amount] on: Incomplete do: [ :ex | ex count ].		1 to: read do: [:index | aSequenceableCollection at: count + startIndex + index - 1 put: (block value: (cache at: index))].		count := count + read.		read &lt; amount ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise]]</body><body package="Xtreams-Transforms">directRead: anInteger into: aSequenceableCollection at: startIndex	| count |	count := [source read: anInteger into: aSequenceableCollection at: startIndex. anInteger] on: Incomplete do: [ :ex | ex count ].	startIndex to: startIndex + count - 1 do: [:index | aSequenceableCollection at: index put: (block value: (aSequenceableCollection at: index))].	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise]</body></methods><methods><class-id>Xtreams.CollectReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aReadStream block: block	^self new on: aReadStream block: block</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>analyse - numbers</category><body package="Xtreams-Transforms">analyse: reading integerMedium: aClass	| integer |	reading log: ['medium integer: ', integer printString] do: [integer := self get: reading integerMedium: aClass]</body><body package="Xtreams-Transforms">analyse: reading integerNegativeLarge: integer	reading log: 'large negative integer' do: [self get: reading integerLarge: integer]</body><body package="Xtreams-Transforms">analyse: reading integerPositiveLarge: integer	reading log: 'large positive integer' do: [self get: reading integerLarge: integer]</body><body package="Xtreams-Transforms">analyse: reading integerSmall: aClass	| integer |	reading log: ['small integer: ', integer printString] do: [integer := self get: reading integerSmall: aClass]</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>analyse - complex</category><body package="Xtreams-Transforms">analyse: reading class_id: aBlock	| id class className classIsMeta classFormat classInstVarSize classInstVarNames |	id := -1.	reading log: ['class id: ', id printString] do: [id := self get: reading integer: nil].	id &gt; classes size ifFalse: [^aBlock value: id value: (classes at: id)].	class := nil.	reading log: ['class description: ', class fullName] do:		[className := self get: reading string: String.		classIsMeta := self unmarshal: reading.		classFormat := self get: reading integer: Integer.		classInstVarSize := self get: reading integer: Integer.		classInstVarNames := (1 to: classInstVarSize) collect: [:i | self get: reading string: String].		classesMutex critical: [			class := self resolveClass: className isMeta: classIsMeta format: classFormat instVarNames: classInstVarNames.			self includeClass: class]].	^aBlock value: id value: class</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>reading - core</category><body package="Xtreams-Transforms">get: reading byte: aClass	^reading uint8 get</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>reading - complex</category><body package="Xtreams-Transforms">get: reading class_id: aBlock	| id class className classIsMeta classFormat classInstVarSize classInstVarNames |	id := self get: reading integer: nil.	id &gt; classes size ifFalse: [^aBlock value: id value: (classes at: id)].	className := self get: reading string: String "asStrictReference value".	classIsMeta := self unmarshal: reading.	classFormat := self get: reading integer: Integer.	classInstVarSize := self get: reading integer: Integer.	classInstVarNames := (1 to: classInstVarSize) collect: [:each | self get: reading string: String].	classesMutex critical: [		class := self resolveClass: className isMeta: classIsMeta format: classFormat instVarNames: classInstVarNames.		self includeClass: class].	^aBlock value: id value: class</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>writing - core</category><body package="Xtreams-Transforms">put: writing byte: byte	writing uint8 put: byte</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">includeClass: aClass	| class classId |	class := aClass.	[(classId := classes indexOf: class) isZero] whileTrue: [class := class superclass].	classes := classes copyWith: aClass.	read := read copyWith: (read at: classId).	write := write copyWith: (write at: classId).	analyse := analyse copyWith: (analyse at: classId).	rehash := rehash copyWith: (rehash at: classId).	immediate := immediate copyWith: aClass hasImmediateInstances.	^classes size</body><body package="Xtreams-Transforms">initialize	self initializeVersion.	classesMutex := Semaphore forMutualExclusion.	classes := Array new.	read := Array new.	(Pragma allNamed: #reads: from: self class to: ObjectMarshaler sortedByArgument: 1) do: [:pragma |		classes := classes copyWith: pragma arguments first asStrictReference value.		read := read copyWith: pragma selector].	analyse := Array new: classes size.	(Pragma allNamed: #analyse: from: self class to: ObjectMarshaler sortedByArgument: 1) do: [:pragma |		| class id |		class := pragma arguments first asStrictReference value.		(id := classes indexOf: class) isZero			ifTrue:				[classes := classes copyWith: class.				read := read copyWith: nil.				analyse := analyse copyWith: pragma selector]			ifFalse:				[analyse at: id put: pragma selector]].	write := Array new: classes size.	(Pragma allNamed: #writes: from: self class to: ObjectMarshaler sortedByArgument: 1) do: [:pragma |		| class id |		class := pragma arguments first asStrictReference value.		(id := classes indexOf: class) isZero			ifTrue:				[classes := classes copyWith: class.				read := read copyWith: nil.				analyse := analyse copyWith: nil.				write := write copyWith: pragma selector]			ifFalse:				[write at: id put: pragma selector]].	rehash := Array new: classes size.	classes keysAndValuesDo: [:index :class | rehash at: index put: (class canUnderstand: #rehash)].	immediate := Array new: classes size.	classes keysAndValuesDo: [:index :class | immediate at: index put: class hasImmediateInstances].	"true, false and nil are not immediate in the #isImmediate sense, but they are in the bytes sense"	immediate		at: (classes indexOf: UndefinedObject) put: true;		at: (classes indexOf: True) put: true;		at: (classes indexOf: False) put: true</body><body package="Xtreams-Transforms">initializeVersion	| hash versionWriting |	version := #[83 84 83 84 20]. "STST 2.0"	hash := self class absoluteName hash.	(self class methodDictionary keys asSortedCollection: [:a :b | (a trueCompare: b) &lt;= 0]) do: [:key |		hash := (hash bitXor: key stringhash) bitXor: (self class methodDictionary at: key) bytes hash].	versionWriting := ByteArray new writing.	versionWriting write: version.	versionWriting write: hash digitLength.	[hash &gt; 0] whileTrue: [versionWriting write: (hash bitAnd: 255). hash := hash bitShift: -8].	version := versionWriting conclusion</body><body package="Xtreams-Transforms">resolveClass: className isMeta: classIsMeta format: classFormat instVarNames: classInstVarNames	"If a class by the absolute name of className exists, and its shape and format match what was expected, re-use it, otherwise create a shadow-class."	| class newMetaclass |	class := className asStrictReference valueOrDo: [nil].	(class ~~ nil and: [classIsMeta]) ifTrue: [class := class class].	(class == nil or: [class format ~= classFormat or: [class allInstVarNames asSet ~= classInstVarNames asSet]]) ifTrue: [		newMetaclass := Metaclass new.		newMetaclass hash.		newMetaclass setSuperclass: Object class.		newMetaclass setInstanceFormat: (classIsMeta ifTrue: [classFormat] ifFalse: [Object class format]).		newMetaclass instanceVariables: (classIsMeta ifTrue: [(classInstVarNames asSet - Object class instVarNames asSet) asArray] ifFalse: [#()]).		newMetaclass methodDictionary: Kernel.MethodDictionary new.		class := newMetaclass new.		class hash.		class setName: className.		class setSuperclass: Object.		class setInstanceFormat: (classIsMeta ifTrue: [Object format] ifFalse: [classFormat]).		class instanceVariables: (classIsMeta ifTrue: [#()] ifFalse: [classInstVarNames]).		class methodDictionary: Kernel.MethodDictionary new.		classIsMeta ifFalse: [			classInstVarNames do: [:instVarName |  | methodNode |				methodNode := class compilerClass new compile: instVarName, ' ^', instVarName in: class notifying: nil ifFail: [].				class methodDictionary at: methodNode selector put: methodNode generate.				methodNode := class compilerClass new compile: instVarName, ': anObject ', instVarName, ' := anObject' in: class notifying: nil ifFail: [].				class methodDictionary at: methodNode selector put: methodNode generate].			class flushVMmethodCache].		classIsMeta ifTrue: [class := newMetaclass]].	^class</body><body package="Xtreams-Transforms">version	^version</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>api</category><body package="Xtreams-Transforms">analyse: reading	| description |	description := '&lt;error&gt;'.	reading		log:			[description]		do:			[ | classId class objectId |			self analyse: reading class_id: [:id :behavior |				description := 'class id: ', id printString, ' class: ', behavior fullName, ' '.				classId := id.				class := behavior].			(immediate at: classId) ifTrue:				[description := description, 'immediate'.				self perform: (analyse at: classId) with: reading with: class.				^self].			objectId := -1.			reading log: ['object id: ', objectId printString] do: [objectId := self get: reading integer: nil].			(reading objects includes: objectId) ifTrue:				[description := description, 'reference: ', objectId printString.				^self].			description := description, 'object id: ', objectId printString.			reading objects add: objectId.			self perform: (analyse at: classId) with: reading with: class.			(rehash at: classId) ifTrue: [description := description, ' rehash']]</body><body package="Xtreams-Transforms">marshal: writing object: object	| class classId objectId |	class := object class.	classId := self put: writing class: class.	(immediate at: classId) ifTrue: [^self perform: (write at: classId) with: writing with: object].	objectId := writing existing: object ifAbsent: [:index |		self put: writing integer: index.		^self perform: (write at: classId) with: writing with: object].	self put: writing integer: objectId</body><body package="Xtreams-Transforms">unmarshal: reading	| object reference classId class objectId |	self get: reading class_id: [:id :behavior | classId := id. class := behavior].	(immediate at: classId) ifTrue: [^self perform: (read at: classId) with: reading with: class].	objectId := self get: reading integer: nil.	objectId &gt; reading objects size ifTrue: [reading grow: objectId].	(reading isRealized: objectId) ifTrue: [		reading reference: objectId.		^reading objects at: objectId].	reading objects at: objectId put: (reference := Object new).	reading realize: objectId.	object := self perform: (read at: classId) with: reading with: class.	(rehash at: classId) ifTrue: [object rehash].	^(reading isReferenced: objectId)		ifTrue:	[reference become: object. reference]		ifFalse:	[reading objects at: objectId put: object. object]</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>writing - numbers</category><body package="Xtreams-Transforms">put: writing integerLarge: integer	| printed |	printed := String new writeStream.	integer printOn: printed base: 36.	printed := printed contents.	printed size &gt; 9223372036854775808 ifTrue: [self error: 'this number is too big for me, try again in a thousand years.'].	self put: writing string: printed</body><body package="Xtreams-Transforms">put: writing integerMedium: integer	self put: writing byte: 253.	writing int64 put: integer</body><body package="Xtreams-Transforms">put: writing integerNegativeLarge: integer	self put: writing byte: 255.	self put: writing integerLarge: integer negated</body><body package="Xtreams-Transforms">put: writing integerPositiveLarge: integer	self put: writing byte: 254.	self put: writing integerLarge: integer</body><body package="Xtreams-Transforms">put: writing integerSmall: integer	self put: writing byte: 252.	writing int32 put: integer</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>reading - numbers</category><body package="Xtreams-Transforms">get: reading integerLarge: integer	| printed |	printed := self get: reading string: String.	^Number readIntegerFrom: printed readStream radix: 36</body><body package="Xtreams-Transforms">get: reading integerMedium: aClass	^reading int64 get</body><body package="Xtreams-Transforms">get: reading integerSmall: aClass	^reading int32 get</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>configuration</category><body package="Xtreams-Transforms">configureAnalyse: reading	"Negotiate this marshaler on the reading stream and return true if the stream should be big-endian."	(reading read: version size) = version ifFalse: [self error: 'incompatible marshalers'].	^reading get = true coerceToCInteger</body><body package="Xtreams-Transforms">configureMarshal: writing	"Negotiate this marshaler on the writing stream and return true if the stream should be big-endian."	writing		write: version;		put: InterpretedBytes isBigEndian coerceToCInteger;		flush.	^InterpretedBytes isBigEndian</body><body package="Xtreams-Transforms">configureUnmarshal: reading	"Negotiate this marshaler on the reading stream and return true if the stream should be big-endian."	(reading read: version size) = version ifFalse: [self error: 'incompatible marshalers'].	^reading get = true coerceToCInteger</body><body package="Xtreams-Transforms">streamingMarshal: stream	^ObjectWriteStream on: stream marshaler: self</body><body package="Xtreams-Transforms">streamingUnmarshal: stream	^ObjectReadStream on: stream marshaler: self</body></methods><methods><class-id>Xtreams.ObjectMarshaler class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">new	^super new initialize</body></methods><methods><class-id>Xtreams.InterpretedReadStream</class-id> <category>seeking</category><body package="Xtreams-Transforms">++ anInteger	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	[source ++ anInteger * elementSize]		on: Incomplete do: [:exception | (Incomplete count: exception count / elementSize) raise].	^anInteger</body><body package="Xtreams-Transforms">-- anInteger	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	[source -- anInteger * elementSize]		on: Incomplete do: [:exception | (Incomplete count: exception count / elementSize) raise].	^anInteger</body><body package="Xtreams-Transforms">length	^source length / elementSize</body><body package="Xtreams-Transforms">position	^source position / elementSize</body><body package="Xtreams-Transforms">position: aPosition	^([ source position: aPosition * elementSize ] on: Incomplete do: [ :ex | ex count ]) // elementSize</body></methods><methods><class-id>Xtreams.InterpretedReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">close	| saved |	super close.	saved := cache.	cache := nil.	saved == nil ifFalse: [ saved recycle ].</body><body package="Xtreams-Transforms">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Transforms">on: aReadStream bytesPerElement: anInteger contentsSpecies: aClass operation: aBlock cacheSize: aSize	super on: aReadStream.	cacheSize := aSize.	elementSize := anInteger.	contentsSpecies := aClass.	operation := aBlock.	cache := InterpretedBytes newRecycled: ((elementSize * cacheSize) max: DefaultBufferSize)</body></methods><methods><class-id>Xtreams.InterpretedReadStream</class-id> <category>testing</category><body package="Xtreams-Transforms">isPositionable	^source isPositionable</body></methods><methods><class-id>Xtreams.InterpretedReadStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	| count amount |	count := 0.	[[count = anInteger] whileFalse:		[amount := cacheSize min: (anInteger - count).		source read: amount * elementSize into: cache at: 1.		0 to: amount - 1 do: [:index | aSequenceableCollection at: startIndex + count + index put: (operation value: cache value: index * elementSize + 1)].		count := count + amount]]			on: Incomplete do: [:exception |				0 to: exception count // elementSize - 1 do: [:index | aSequenceableCollection at: startIndex + count + index put: (operation value: cache value: index * elementSize + 1)].				(Incomplete on: aSequenceableCollection count: count + (exception count / elementSize) at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.InterpretedReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aReadStream bytesPerElement: anInteger contentsSpecies: aClass operation: aBlock cacheSize: aSize	^self new on: aReadStream bytesPerElement: anInteger contentsSpecies: aClass operation: aBlock cacheSize: aSize</body><body package="Xtreams-Transforms">on: aReadStream type: aSymbol cacheSize: anInteger	| interpretation |	interpretation := InterpretedBytes perform: aSymbol.	^self on: aReadStream bytesPerElement: (interpretation at: 1) contentsSpecies: (interpretation at: 2) operation: (interpretation at: 3) cacheSize: anInteger</body></methods><methods><class-id>Xtreams.JSONWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">contentsSpecies	^Array</body><body package="Xtreams-Transforms">maxDepth: maxDepth	depth := maxDepth</body><body package="Xtreams-Transforms">on: aDestination	super on: aDestination.	self maxDepth: MaxObjectDepth</body></methods><methods><class-id>Xtreams.JSONWriteStream</class-id> <category>private</category><body package="Xtreams-Transforms">isEscaped: aCharacter"Should the character be escaped?	unescaped = %x20-21 / %x23-5B / %x5D-10FFFF"	^aCharacter &lt; $ "space"		or: [ aCharacter == $"		or: [ aCharacter == $\ ] ]</body><body package="Xtreams-Transforms">isUnescaped: aCharacter"Should the character be escaped?	unescaped = %x20-21 / %x23-5B / %x5D-10FFFF"	^aCharacter &lt; $ "space" and: [ aCharacter == $" or: [ aCharacter == $\ ] ]</body><body package="Xtreams-Transforms">putEscapedCharacter: aCharacter	| code |	aCharacter = Character tab ifTrue: [^destination write: '\t'].	aCharacter = Character cr ifTrue: [^destination write: '\n'].	aCharacter = Character lf ifTrue: [^destination write: '\r'].	aCharacter = $/ ifTrue: [^destination write: '\/'].	aCharacter = $\ ifTrue: [^destination write: '\\'].	aCharacter = $" ifTrue: [^destination write: '\"'].	aCharacter = Character backspace ifTrue: [^destination write: '\b'].	aCharacter = Character newPage ifTrue: [^destination write: '\f'].	"otherwise use \uXXXX"	destination write: '\u'.	code := aCharacter codePoint.	#(-12 -8 -4 0) do: [:shift |		destination write: 1			from: '0123456789abcdef'			at: ((code bitShift: shift) bitAnd: 15) + 1 ]</body><body package="Xtreams-Transforms">putObjectWith: aBlock	self trackingDepthDo: [ | empty |		empty := true.		destination write: '{'.		aBlock value: [ :name :value |			empty				ifTrue: [ empty := false ]				ifFalse: [ destination write: ', ' ].			self putString: name.			destination write: ': '.			self put: value ].		destination write: '}' ]</body><body package="Xtreams-Transforms">trackingDepthDo: aBlock	depth &lt; 0 ifTrue: [ self error: 'Error: maximum object traversal depth exceeded.'.].	depth := depth - 1.	aBlock ensure: [depth := depth + 1]</body></methods><methods><class-id>Xtreams.JSONWriteStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">put: anObject	(ActionMap at: anObject class ifAbsent: [nil])		ifNil: [ anObject streamingWriteJSONOn: self ]		ifNotNil: [ :selector | self perform: selector with: anObject ]</body><body package="Xtreams-Transforms">write: anInteger from: aSequenceableCollection at: startIndex	| offset |	offset := 0.	[ offset &lt; anInteger ] whileTrue: [		self put: (aSequenceableCollection at: startIndex + offset) ].	^anInteger</body></methods><methods><class-id>Xtreams.JSONWriteStream class</class-id> <category>class initialization</category><body package="Xtreams-Transforms">initialize	self initializeActionMap</body><body package="Xtreams-Transforms">initializeActionMap"	self initializeActionMap"	ActionMap := IdentityDictionary new.	(Pragma allNamed: #action: in: self) do: [ :pragma || class |		class := pragma arguments first value.		ActionMap at: class put: pragma selector ].	^ActionMap</body><body package="Xtreams-Transforms">instanceMethodsChanged	self initializeActionMap</body></methods><methods><class-id>Xtreams.InterpretedWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">close	| saved |	super close.	saved := cache.	cache := nil.	saved == nil ifFalse: [ saved recycle ].</body><body package="Xtreams-Transforms">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Transforms">on: aWriteStream bytesPerElement: anInteger contentsSpecies: aClass operation: aBlock cacheSize: aSize	super on: aWriteStream.	cacheSize := aSize.	elementSize := anInteger.	contentsSpecies := aClass.	operation := aBlock.	cache := InterpretedBytes newRecycled: ((elementSize * cacheSize) max: DefaultBufferSize)</body></methods><methods><class-id>Xtreams.InterpretedWriteStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">insert: anInteger from: aSequenceableCollection at: startIndex	| count amount |	count := 0.	[count = anInteger] whileFalse: 		[amount := cacheSize min: anInteger - count.		0 to: amount - 1 do:  [:index | operation value: cache value: index * elementSize + 1 value: (aSequenceableCollection at: index + startIndex)].		destination insert: amount * elementSize from: cache at: 1.		count := count + amount].	^anInteger</body><body package="Xtreams-Transforms">put: anObject	operation value: cache value: 1 value: anObject.	destination write: elementSize from: cache at: 1.	^anObject</body><body package="Xtreams-Transforms">write: anInteger from: aSequenceableCollection at: startIndex	| count amount |	count := 0.	[count = anInteger] whileFalse: 		[amount := cacheSize min: anInteger - count.		0 to: amount - 1 do:  [:index | operation value: cache value: index * elementSize + 1 value: (aSequenceableCollection at: count + index + startIndex)].		destination write: amount * elementSize from: cache at: 1.		count := count + amount].	^anInteger</body></methods><methods><class-id>Xtreams.InterpretedWriteStream</class-id> <category>seeking</category><body package="Xtreams-Transforms">++ anInteger	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	[destination ++ anInteger * elementSize]		on: Incomplete do: [:exception | (Incomplete count: exception count / elementSize) raise].	^anInteger</body><body package="Xtreams-Transforms">-- anInteger	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	[destination -- anInteger * elementSize]		on: Incomplete do: [:exception | (Incomplete count: exception count / elementSize) raise].	^anInteger</body><body package="Xtreams-Transforms">length	^destination length / elementSize</body><body package="Xtreams-Transforms">position	^destination position / elementSize</body><body package="Xtreams-Transforms">position: aPosition	^([ destination position: aPosition * elementSize ] on: Incomplete do: [ :ex | ex count ]) // elementSize</body></methods><methods><class-id>Xtreams.InterpretedWriteStream</class-id> <category>testing</category><body package="Xtreams-Transforms">isPositionable	^destination isPositionable</body></methods><methods><class-id>Xtreams.InterpretedWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aWriteStream bytesPerElement: anInteger contentsSpecies: aClass operation: aBlock cacheSize: aSize	^self new on: aWriteStream bytesPerElement: anInteger contentsSpecies: aClass operation: aBlock cacheSize: aSize</body><body package="Xtreams-Transforms">on: aWriteStream type: aType cacheSize: aSize	| interpretation |	interpretation := InterpretedBytes perform: aType.	^self on: aWriteStream bytesPerElement: (interpretation at: 1) contentsSpecies: (interpretation at: 2) operation: (interpretation at: 4) cacheSize: aSize</body></methods><methods><class-id>Xtreams.ObjectAnalyseStream</class-id> <category>private</category><body package="Xtreams-Transforms">begin	objects := OrderedCollection with: 1.	depth := 0</body><body package="Xtreams-Transforms">complete	objects := nil</body><body package="Xtreams-Transforms">log: type do: aBlock	| superlog sublog position incomplete |	position := source position.	superlog := log.	log := String new writing.	depth := depth + 1.	incomplete := false.	^[aBlock on: Incomplete do: [:ex | incomplete := true. ex pass]] ensure:		[depth := depth - 1.		sublog := log conclusion.		log := superlog.		incomplete ifFalse:			[log tab: depth; print: position; write: '+'; print: (source position - position); tab.			type isCharacters				ifTrue:	[log write: type]				ifFalse:	[log write: type value].			log cr; write: sublog]]</body><body package="Xtreams-Transforms">objects	^objects</body></methods><methods><class-id>Xtreams.ObjectAnalyseStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">contentsSpecies	^Array</body><body package="Xtreams-Transforms">on: aSource marshaler: aMarshaler	super on: aSource.	marshaler := aMarshaler.	depth := 0.	log := String new writing.	int8 := aSource interpreting: #signedChar.	(self log: 'header' do: [marshaler configureAnalyse: aSource])		ifTrue: [			int16 := aSource interpreting: #signedShort_be.			int32 := aSource interpreting: #signedLong_be.			int64 := aSource interpreting: #signedLonglong_be.			uint16 := aSource interpreting: #unsignedShort_be.			uint32 := aSource interpreting: #unsignedLong_be.			uint64 := aSource interpreting: #unsignedLonglong_be]		ifFalse: [			int16 := aSource interpreting: #signedShort_le.			int32 := aSource interpreting: #signedLong_le.			int64 := aSource interpreting: #signedLonglong_le.			uint16 := aSource interpreting: #unsignedShort_le.			uint32 := aSource interpreting: #unsignedLong_le.			uint64 := aSource interpreting: #unsignedLonglong_le].	float := aSource interpreting: #float.	double := aSource interpreting: #double</body></methods><methods><class-id>Xtreams.ObjectAnalyseStream</class-id> <category>primitives</category><body package="Xtreams-Transforms">double	^double</body><body package="Xtreams-Transforms">encoding: anEncoding	^source encoding: anEncoding</body><body package="Xtreams-Transforms">float	^float</body><body package="Xtreams-Transforms">int16	^int16</body><body package="Xtreams-Transforms">int32	^int32</body><body package="Xtreams-Transforms">int64	^int64</body><body package="Xtreams-Transforms">int8	^int8</body><body package="Xtreams-Transforms">uint16	^uint16</body><body package="Xtreams-Transforms">uint32	^uint32</body><body package="Xtreams-Transforms">uint64	^uint64</body><body package="Xtreams-Transforms">uint8	^source</body></methods><methods><class-id>Xtreams.ObjectAnalyseStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">get	| details |	self begin.	marshaler analyse: self.	details := log conclusion.	log := String new writing.	self complete.	^details</body><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	| count |	count := 0.	[anInteger timesRepeat:		[self begin.		marshaler analyse: self.		aSequenceableCollection at: startIndex + count put: log conclusion.		log := String new writing.		self complete.		count := count + 1]]			on: Incomplete do: [:exception |				aSequenceableCollection at: startIndex + count put: log conclusion.				log := String new writing.				self complete.				(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.ObjectAnalyseStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aDestination	^self on: aDestination marshaler: ObjectMarshaler new</body><body package="Xtreams-Transforms">on: aDestination marshaler: aMarshaler	^self new on: aDestination marshaler: aMarshaler</body></methods><methods><class-id>Xtreams.EncodeReadStream</class-id> <category>line-end</category><body package="Xtreams-Transforms">setLineEndAuto	transparent := false</body><body package="Xtreams-Transforms">setLineEndTransparent	transparent := true</body></methods><methods><class-id>Xtreams.EncodeReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">close	buffer isNil ifTrue: [^self].	super close.	buffer recycle.	buffer := nil</body><body package="Xtreams-Transforms">contentsSpecies		^ByteString</body><body package="Xtreams-Transforms">on: aSource encoding: anEncoding	super on: aSource.	encoder := Encoder for: anEncoding.	buffer := RingBuffer new: DefaultBufferSize class: ByteArray.	bufferReading := buffer reading.	bufferWriting := buffer writing.	transparent := false.	crPreceeding := false.</body></methods><methods><class-id>Xtreams.EncodeReadStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">encoder	^encoder</body><body package="Xtreams-Transforms">get	| character |	buffer hasDataToRead ifTrue: [^super get].	character := encoder decodeFrom: source.	transparent ifFalse: 		[character == LF			ifTrue: [crPreceeding				ifTrue: 					[character := encoder decodeFrom: source.					crPreceeding := character = CR]				ifFalse: 					[crPreceeding := false.					character := CR]]			ifFalse: [crPreceeding := character = CR]].	^character</body><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	| remaining position character bufferAvailable decodingException|	remaining := anInteger.	position := startIndex.	decodingException := nil.	[remaining &gt; 0] whileTrue: [		| mark |		"Top up our buffer if we have room and we need data"		[bufferWriting write: (buffer writeSize min: remaining) from: source] 			on: Incomplete 			do: [:incomplete |			((incomplete count == 0 and: [buffer hasDataToRead not])				or: [decodingException notNil]) ifTrue: [				(Incomplete on: aSequenceableCollection count: anInteger - remaining at: startIndex) raise]].		"We now conduct an inner loop that iterates over the buffer data while:			a) we need to read more data			b) there is data available in the buffer			c) a character can successfully be decoded		"		"If our buffer size is too low before we begin our decode loop, we need to take an undo copy in case we cannot decode a character."		mark := buffer readPosition.		buffer readSize &lt; 10 ifTrue: [ encoder backupState ].		[["The following may raise an incomplete, which means we don't have enough data in the buffer to decode the full character.		 This is handled by the Incomplete exception capture before."		character := encoder decodeFrom: bufferReading.		"If we are not transparent, convert stray LFs in to CRs and CRLFs in to CRs"		transparent ifFalse: [			character == LF				ifTrue:	[character := crPreceeding ifTrue: [nil] ifFalse: [CR]. crPreceeding := false]				ifFalse:	[crPreceeding := character = CR]].		"If we didn't filter out an LF at the tail of a CRLF, commit the character to the output."		character == nil ifFalse:			[aSequenceableCollection at: position put: character.			remaining := remaining - 1.			position := position + 1].		"Find out how much data we have left in the buffer. If it's too low we need to keep track of the undo record in case we cannot decode a character."		mark := buffer readPosition.		(bufferAvailable := buffer readSize) &lt; 10 ifTrue: [ encoder backupState ].		remaining &gt; 0 and: [bufferAvailable &gt; 0]] whileTrue]			on: Incomplete do: [:incomplete | 				"Remember we don't have enough bytes to finish decoding. 				If there is no more bytes in the source we will raise Incomplete"				decodingException := incomplete. 								"We failed to decode a character, we've hit the end of the buffer and need to refill it. 				We rewind the buffer and leave the decoding loop to return to the main loop where 				more data will be fetched in to our buffer."				buffer readPosition: mark.				encoder restoreState]].	^anInteger</body></methods><methods><class-id>Xtreams.EncodeReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aSource encoding: anEncoding	^self new on: aSource encoding: anEncoding</body></methods><methods><class-id>Xtreams.ObjectWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">contentsSpecies	^Array</body><body package="Xtreams-Transforms">on: aDestination marshaler: aMarshaler	super on: aDestination.	marshaler := aMarshaler.	int8 := aDestination interpreting: #signedChar.	(marshaler configureMarshal: aDestination)		ifTrue: [			int16 := aDestination interpreting: #signedShort_be.			int32 := aDestination interpreting: #signedLong_be.			int64 := aDestination interpreting: #signedLonglong_be.			uint16 := aDestination interpreting: #unsignedShort_be.			uint32 := aDestination interpreting: #unsignedLong_be.			uint64 := aDestination interpreting: #unsignedLonglong_be]		ifFalse: [			int16 := aDestination interpreting: #signedShort_le.			int32 := aDestination interpreting: #signedLong_le.			int64 := aDestination interpreting: #signedLonglong_le.			uint16 := aDestination interpreting: #unsignedShort_le.			uint32 := aDestination interpreting: #unsignedLong_le.			uint64 := aDestination interpreting: #unsignedLonglong_le].	float := aDestination interpreting: #float.	double := aDestination interpreting: #double</body></methods><methods><class-id>Xtreams.ObjectWriteStream</class-id> <category>private</category><body package="Xtreams-Transforms">begin	objects := IdentityDictionary new.	objects at: Transcript put: 1.	id := 1</body><body package="Xtreams-Transforms">complete	objects := nil</body><body package="Xtreams-Transforms">existing: anObject ifAbsent: absentBlock	^objects at: anObject ifAbsent: [		id := id + 1.		objects at: anObject put: id.		absentBlock value: id.		id]</body><body package="Xtreams-Transforms">objects	^objects</body></methods><methods><class-id>Xtreams.ObjectWriteStream</class-id> <category>primitives</category><body package="Xtreams-Transforms">double	^double</body><body package="Xtreams-Transforms">encoding: anEncoding	^destination encoding: anEncoding</body><body package="Xtreams-Transforms">float	^float</body><body package="Xtreams-Transforms">int16	^int16</body><body package="Xtreams-Transforms">int32	^int32</body><body package="Xtreams-Transforms">int64	^int64</body><body package="Xtreams-Transforms">int8	^int8</body><body package="Xtreams-Transforms">uint16	^uint16</body><body package="Xtreams-Transforms">uint32	^uint32</body><body package="Xtreams-Transforms">uint64	^uint64</body><body package="Xtreams-Transforms">uint8	^destination</body></methods><methods><class-id>Xtreams.ObjectWriteStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">put: object	self begin.	marshaler marshal: self object: object.	self complete.	^object</body><body package="Xtreams-Transforms">write: anInteger from: aSequenceableCollection at: startIndex	startIndex to: anInteger + startIndex - 1 do: [:index |		self begin.		marshaler marshal: self object: (aSequenceableCollection at: index).		self complete].	^anInteger</body></methods><methods><class-id>Xtreams.ObjectWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aDestination	^self on: aDestination marshaler: ObjectMarshaler new</body><body package="Xtreams-Transforms">on: aDestination marshaler: aMarshaler	^self new on: aDestination marshaler: aMarshaler</body></methods><methods><class-id>Xtreams.DuplicateReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">contentsSpecies	^source contentsSpecies</body><body package="Xtreams-Transforms">on: aSource duplicate: aDestination	super on: aSource.	duplicate := aDestination</body></methods><methods><class-id>Xtreams.DuplicateReadStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">read: anInteger into: aSequenceableCollection at: startIndex	[	source read: anInteger into: aSequenceableCollection at: startIndex.	] on: Incomplete do: [ :incomplete |		duplicate write: incomplete count from: aSequenceableCollection at: startIndex.		incomplete pass ].	duplicate write: anInteger from: aSequenceableCollection at: startIndex</body></methods><methods><class-id>Xtreams.DuplicateReadStream</class-id> <category>seeking</category><body package="Xtreams-Transforms">-- anInteger	^self isPositionable		ifFalse: [super -- anInteger]		ifTrue:			[source -- anInteger.			duplicate -- anInteger]</body><body package="Xtreams-Transforms">-= anInteger	^self isPositionable		ifFalse: [super -= anInteger]		ifTrue:			[source -= anInteger.			duplicate -= anInteger]</body><body package="Xtreams-Transforms">length	^self isPositionable		ifFalse: [super length]		ifTrue: [source length]</body><body package="Xtreams-Transforms">position	^self isPositionable		ifFalse: [super position]		ifTrue: [source position]</body><body package="Xtreams-Transforms">position: anInteger	^self isPositionable		ifFalse: [super position: anInteger]		ifTrue:			[source position: anInteger.			duplicate position: anInteger]</body></methods><methods><class-id>Xtreams.DuplicateReadStream</class-id> <category>testing</category><body package="Xtreams-Transforms">isPositionable	^source isPositionable and: [duplicate isPositionable]</body></methods><methods><class-id>Xtreams.DuplicateReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aSource duplicate: aDestination	^self new on: aSource duplicate: aDestination</body></methods><methods><class-id>Xtreams.ISO8859L1Encoder</class-id> <category>accessing</category><body package="Xtreams-Transforms">decodeFrom: aReadStream	^Character value: aReadStream get</body><body package="Xtreams-Transforms">encode: aCharacter on: aWriteStream	aWriteStream put: aCharacter asInteger</body></methods><methods><class-id>Xtreams.ISO8859L1Encoder class</class-id> <category>class initialization</category><body package="Xtreams-Transforms">initialize	| newSelf |	newSelf := self new.	#(#'latin-1' #latin1 #iso8859L1 #ISO8859L1) do: [:id | self encoders at: id put: newSelf]</body></methods><methods><class-id>Xtreams.TransformWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">buffer: aBuffer	buffer := aBuffer.	self drainBuffer</body><body package="Xtreams-Transforms">close	buffer ifNil: [^self].	"Write nothing to the buffer, but signal that there is data to read, causing the drain to throw Incomplete"	readReady signal.	"Wait for the drain to finish up completely. Rearm the closeReady incase somebody calls #close again."	closeReady wait.	closeReady signal.	closeBlock cull: destination cull: self.	buffer recycle.	buffer := nil</body><body package="Xtreams-Transforms">closeBlock: anObject	closeBlock := anObject</body><body package="Xtreams-Transforms">contentsSpecies	^buffer contentsSpecies</body><body package="Xtreams-Transforms">contentsSpecies: aClass	self buffer: (buffer class new: buffer cacheSize class: aClass)</body><body package="Xtreams-Transforms">on: aStreamable block: aBlock	super on: aStreamable.	block := aBlock.	incompleteCount := nil.	closeBlock := [ :destinationStream | destinationStream close].	buffer := ElasticBuffer new: DefaultBufferSize class: aStreamable contentsSpecies.	self drainBuffer</body></methods><methods><class-id>Xtreams.TransformWriteStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">block	^block</body><body package="Xtreams-Transforms">buffer	^buffer</body><body package="Xtreams-Transforms">closeBlock	^closeBlock</body><body package="Xtreams-Transforms">insert: anInteger from: aSequenceableCollection at: startIndex	| count amount |	anInteger isZero ifTrue: [^0].	count := 0.	[count &lt; anInteger] whileTrue:		[amount := anInteger - count.		buffer hasFixedWriteSpace ifTrue: [amount := amount min: buffer cacheSize].		buffer insert: amount from: aSequenceableCollection at: startIndex + count.		"There is now data in the buffer for the drain to read"		readReady signal.		writeReady wait.		incompleteCount == nil ifFalse: [(Incomplete count: count + incompleteCount) raise].		count := count + amount ].	^anInteger</body><body package="Xtreams-Transforms">put: anObject	incompleteCount == nil ifFalse: [Incomplete zero raise].	buffer put: anObject.	"There is now data in the buffer for the drain to read"	readReady signal.	writeReady wait</body><body package="Xtreams-Transforms">write: anInteger from: aSequenceableCollection at: startIndex	| count amount |	anInteger isZero ifTrue: [^0].	count := 0.	[count &lt; anInteger] whileTrue:		[amount := anInteger - count.		buffer hasFixedWriteSpace ifTrue: [amount := amount min: buffer cacheSize].		buffer write: amount from: aSequenceableCollection at: startIndex + count.				"There is now data in the buffer for the drain to read"		readReady signal.		writeReady wait.		incompleteCount == nil ifFalse: [(Incomplete count: count + incompleteCount) raise].		count := count + amount ].	^anInteger</body></methods><methods><class-id>Xtreams.TransformWriteStream</class-id> <category>printing</category><body package="Xtreams-Transforms">streamingPrintOn: aStream	super streamingPrintOn: aStream.	aStream		space;		write: '#';		write: block method homeMethod selector;		write: ' buffered: ';		print: buffer writeSize.	buffer writeSize isZero ifTrue: [^self].	aStream		cr; tab;		print: buffer contentsPast</body></methods><methods><class-id>Xtreams.TransformWriteStream</class-id> <category>private</category><body package="Xtreams-Transforms">drainBuffer	| reading |	process ifNotNil: [process terminate].	incompleteCount == nil ifFalse: [^self].	closeReady := Semaphore new.	readReady := Semaphore new.	writeReady := Semaphore new.	reading := buffer reading transforming: [:in :out |		| count |		"Wait for the main process to have written to the buffer"		readReady wait.		"If nothing was written to the buffer, this indicates we're closing, we raise Incomplete"		(count := buffer readSize) isZero ifTrue: [Incomplete zero raise].		out write: count from: in.		"Allow the main process to write to the buffer"		writeReady signal].	process := [		[[block value: reading value: destination] repeat] on: Incomplete do: [].		incompleteCount := reading buffer readPosition.		"Signal that we're closed so that an attempt to write or close will immediately complete"		writeReady signal.		closeReady signal]			newProcess.	process resume</body></methods><methods><class-id>Xtreams.TransformWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aWriteStream block: block	^self new on: aWriteStream block: block</body></methods><methods><class-id>Xtreams.CollectWriteStream</class-id> <category>seeking</category><body package="Xtreams-Transforms">++ anInteger	^destination ++ anInteger</body><body package="Xtreams-Transforms">-- anInteger	^destination -- anInteger</body><body package="Xtreams-Transforms">length	^destination length</body><body package="Xtreams-Transforms">position	^destination position</body><body package="Xtreams-Transforms">position: anInteger	^destination position: anInteger</body></methods><methods><class-id>Xtreams.CollectWriteStream</class-id> <category>accessing</category><body package="Xtreams-Transforms">block	^block</body><body package="Xtreams-Transforms">insert: anInteger from: aSequenceableCollection at: startIndex	| count amount written offset |	count := 0.	offset := startIndex.	[count &lt; anInteger] whileTrue:		[amount := anInteger min: cache size.		1 to: amount do: [:index | cache at: index put: (block value: (aSequenceableCollection at: offset+index))].		written := [destination insert: anInteger from: cache. amount] on: Incomplete do: [ :ex | ex count ].		count := count + written.		written &lt; amount ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].		offset := offset + amount ].	^anInteger</body><body package="Xtreams-Transforms">put: anObject	destination put: (block value: anObject).	^anObject</body><body package="Xtreams-Transforms">write: anInteger from: aSequenceableCollection at: startIndex	| count amount written offset |	count := 0.	offset := startIndex - 1.	[count &lt; anInteger] whileTrue:		[amount := anInteger - count min: cache size.		1 to: amount do: [:index | cache at: index put: (block value: (aSequenceableCollection at: offset + index))].		written := [destination write: amount from: cache. amount] on: Incomplete do: [ :ex | ex count ].		count := count + written.		written &lt; amount ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].		offset := offset + amount ].	^anInteger</body></methods><methods><class-id>Xtreams.CollectWriteStream</class-id> <category>testing</category><body package="Xtreams-Transforms">isPositionable	^destination isPositionable</body></methods><methods><class-id>Xtreams.CollectWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Transforms">close	| saved |	super close.	saved := cache.	cache := nil.	saved == nil ifFalse: [ saved recycle ].</body><body package="Xtreams-Transforms">contentsSpecies	^cache species</body><body package="Xtreams-Transforms">contentsSpecies: aClass	cache ifNotNil: [ cache recycle ].	cache := aClass newRecycled: (				(cache notNil and: [ cache size &gt; 0 ])					ifTrue: [cache size]					ifFalse: [DefaultBufferSize])</body><body package="Xtreams-Transforms">on: aDestination block: aBlock	self on: aDestination.	block := aBlock.	self contentsSpecies: aDestination contentsSpecies</body></methods><methods><class-id>Xtreams.CollectWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Transforms">on: aWriteStream block: block	^self new on: aWriteStream block: block</body></methods><methods><class-id>Core.Object class</class-id> <category>json encoding</category><body package="Xtreams-Transforms">jsonHierarchyRoot	^self</body></methods><methods><class-id>Core.Object class</class-id> <category>class initialization</category><body package="Xtreams-Transforms">jsonInstVarNames	| names root current |	names := OrderedCollection withAll: self instVarNames.	current := self.	root := self jsonHierarchyRoot.	[current == root] whileFalse:		[current := current superclass.		names addAllFirst: current instVarNames].	^names</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="Xtreams-Transforms">streamingWriteJSONOn: stream"Write the receiver in JSON format to the stream. Usually that means emitting a JSON object. The default behavior is to follow the class shape. If this is being customized for a specific class, it is imperative that the pattern below is followed, where the putObjectWith: message is sent to the stream to handle all the object formatting and the block argument action is used to emit each key/value pair."	^stream putObjectWith: [ :emitKeyValue |		self class jsonInstVarNames do: [ :name |			emitKeyValue value: name value: (self instVarNamed: name) ] ]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>bit processing</category><body package="Xtreams-Transforms">bitAt: i	| position bit |	position := ((i - 1) // 8) + 1.	bit := ((i - 1) \\ 8) + 1.	position &gt; self size ifTrue: [^0].	^(self at: position) bitAt: bit</body><body package="Xtreams-Transforms">bitAt: i put: k	| position bit value |	position := ((i - 1) // 8) + 1.	bit := ((i - 1) \\ 8) + 1.	position &gt; self size ifTrue: [		k == 0 ifTrue: [^self].		self growToAtLeast: position].	value := self at: position.	self at: position put: (value bitAt: bit put: k)</body><body package="Xtreams-Transforms">bitClear: i	self bitAt: i put: 0</body><body package="Xtreams-Transforms">bitSet: i	self bitAt: i put: 1</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="Xtreams-Transforms">collecting: aBlock	"Transform each element using #collect: style block."	"	aBlock	&lt;BlockClosure&gt;	a #collect: style block used to tranform each element		^&lt;CollectReadSteam&gt;	""		((1 to: 5) reading collecting: [ :e | e * e ]) rest	""		((65 to: 90) reading collecting: [ :e | e asCharacter ]) contentsSpecies: String; rest	"	^CollectReadStream on: self block: aBlock</body><body package="Xtreams-Transforms">doing: aBlock	"Perform and action with each passing element using #do: style block."	"	aBlock	&lt;BlockClosure&gt;	a #do: style block invoked with each element as it passes through the stream		^&lt;CollectReadSteam&gt;	""		((1 to: 5) reading doing: [ :e | Transcript space; print: e * e ]) rest	"	^self collecting: [:each | (aBlock value: each). each]</body><body package="Xtreams-Transforms">duplicating: aWriteStream	"Duplicate all the contents read into @aWriteStream"	"	aWriteStream &lt;WriteStream&gt;	a stream to copy into		^&lt;DuplicatingReadSteam&gt;	""		| copy |		copy := ByteArray new writing.		((0 to: 15) reading duplicating: copy) rest -&gt; copy conclusion	"	^DuplicateReadStream on: self duplicate: aWriteStream</body><body package="Xtreams-Transforms">encoding: anEncoding	"Transform bytes into characters using @anEncoding such as #utf8 or #ascii, etc. Any encoding supported by StreamEncoder is allowed.	The encoding steam also performs automatic line end conversion from arbitrary platform convention to CRs, unless set into a transparent mode"	"	anEncoding	&lt;Symbol&gt; encoding identifier recognized by StreamEncoder class&gt;&gt;new:		^&lt;EncodedReadStream&gt;	""		((65 to: 90) reading encoding: #ascii) rest	""		| crlf text |		crlf := String with: Character cr with: Character lf.		text := ('Hello', crlf, 'World') asByteArrayEncoding: #ascii.		(text reading encoding: #ascii) rest.		(text reading encoding: #ascii) setLineEndTransparent; rest	"	^EncodeReadStream on: self encoding: anEncoding</body><body package="Xtreams-Transforms">encodingBase32	"Decodes characters of base-32 encoding into bytes. Ignores any intervening whitespace.	Automatically ends the stream if it encounters final padding characters $=, or anything else that's not a valid encoding character."	"	^&lt;TransformReadStream&gt;"	"		#('AE======' 'AEBA====' 'AEBAG===' 'AEBAGBA=' 'AEBAGBAFA') collect: [ :each | each reading encodingBase32 rest ]	"	| map cache |	map := [ :char | ('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567' indexOf: char) - 1 ].	cache := ByteString new: 8.	^(self transforming: [ :in :out || chars bits bytes i block nibble |			chars := [ (in rejecting: #isSeparator) read: 8 into: cache at: 1 ] on: Incomplete do: [ :incomplete | incomplete count ].			i := 1. bits := bytes := block := 0.			[	i &gt; chars or: [ (nibble := map value: (cache at: i)) negative ]			] whileFalse: [ block :=  (block bitShift: 5) + nibble. bits := bits + 5. i := i + 1 ].			[ bits &gt; 7 ] whileTrue: [ bits := bits - 8. out put: ((block bitShift: bits negated) bitAnd: 255). bytes := bytes + 1 ]. 			bytes &lt; 5 ifTrue: [ (Incomplete count: bytes) raise ] ]	)	buffer: (RingBuffer on: (ByteArray new: 5));		yourself</body><body package="Xtreams-Transforms">encodingBase64	"Decodes characters of base-64 encoding into bytes. Ignores any intervening whitespace.	Automatically ends the stream if it encounters final padding characters $=."	"	^&lt;TransformReadStream&gt;"	"		'AAECAwQFBgcICQo= and the rest should be ignored' reading encodingBase64 rest	"	| map cache |	map := [ :char | ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' indexOf: char) - 1 ].	cache := ByteString new: 4.	^(self transforming: [ :in :out || count end block filter |		filter := in rejecting: #isSeparator.		count := [ filter read: 4 into: cache at: 1. 4 ] on: Incomplete do: [ :incomplete | incomplete count].		count isZero ifTrue: [ Incomplete zero raise ].		(end := cache indexOf: $=) isZero ifFalse: [ count := count min: end - 1 ].		count &lt; 2 ifTrue: [ Incomplete zero signal ].		block := (1 to: 4) inject: 0 into: [ :total :i || sextet |			sextet := count &lt; i ifTrue: [ 0 ] ifFalse: [ map value: (cache at: i) ].			sextet negative ifTrue: [ count := i ].			(total bitShift: 6) + sextet ].		2 to: count do: [ :i | out put: ((block bitShift: (i - 4) * 8) bitAnd: 255) ].		count &lt; 4 ifTrue: [ (Incomplete count: count) raise ] ])			buffer: (RingBuffer on: (ByteArray new: 3));			yourself</body><body package="Xtreams-Transforms">encodingHex	"Decodes bytes hex characters."	"	^&lt;TransformReadStream&gt;"	"		(ByteArray withAll: (1 to: 20)) reading encodingHex rest	"	| i2c |	i2c := [ :i | '0123456789abcdef' at: i + 1 ].	^(self transforming: [ :in :out || byte |		byte := in get.		out put: (i2c value: (byte bitShift: -4)).		out put: (i2c value: (byte bitAnd: 15)) ])		contentsSpecies: ByteString;		yourself</body><body package="Xtreams-Transforms">injecting: initialObject into: aBlock	"Accumulates a running value combined with each passing element using the binary aBlock. aBlock takes the result of the last evaluation and the next element as its arguments. Notable difference from the collection analog is that the streaming variant is a stream of all the intermediate values of the running value."	"	initialObject	&lt;Object&gt; initial value used as the previous result for the evaluation of the first element		aBlock	&lt;BlockClosure&gt; binary block combining the value of each element with previous result of its evaluation		^&lt;CollectingReadStream&gt;"	"		((1 to: 10) reading injecting: 0 into: [ :total :each | each + total ]) rest	"	| nextObject |	nextObject := initialObject.	^self collecting: [:each | nextObject := aBlock cull: nextObject cull: each]</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>interpreting</category><body package="Xtreams-Transforms">interpreting: type	"Converts bytes from a binary source according to provided @type. It produces elements of corresponding class, e.g. #float -&gt; Float, #double -&gt; Double, etc. Supported types are defined by the Interpretations shared class variable.	""	type	&lt;Symbol&gt;	identifies a (primitive) CType, e.g. #float, #long (mapped via Interpretations)		^		&lt;InterpretedReadStream&gt;	""		| doubles bytes |		doubles := [ Random new next ] reading.		bytes := (ByteArray new writing interpreting: #double)			write: 10 from: doubles;			close;			terminal.		(bytes reading interpreting: #double) read: 10	"	^self interpreting: type cacheSize: 1</body><body package="Xtreams-Transforms">interpreting: type cacheSize: size	"Converts bytes from a binary source according to provided @type. It produces elements of corresponding class, e.g. #float -&gt; Float, #double -&gt; Double, etc. Supported types are defined on class side of InterpretedBytes.	""	type	&lt;Symbol&gt;	identifies a (primitive) CType, e.g. #float, #long (mapped via InterpretatedBytes)		size		&lt;Integer&gt;	requested cache size (in number of elements)		^		&lt;InterpretedReadStream&gt;	""		| doubles bytes |		doubles := [ Random new next ] reading.		bytes := (ByteArray new writing interpreting: #double cacheSize: 10)			write: 10 from: doubles;			close;			terminal.		(bytes reading interpreting: #double) read: 10	"	^InterpretedReadStream on: self type: type cacheSize: size</body><body package="Xtreams-Transforms">interpreting: reader size: byteSize	"Converts bytes from a binary source according to provided @reader block. The block is evaluated with an instance of InterpretedBytes and and index into it from which it should use byteSize bytes to make an object to return.	""	reader		&lt;BlockClosure&gt;	reading block, e.g. [ :b :i | (b at: i) @ (b at: i + 1) ]		byteSize	&lt;Integer&gt;	byte size of an element		^			&lt;InterpretedReadStream&gt;	""		| doubles bytes |		doubles := [ Random new next ] reading.		bytes := (ByteArray new writing interpreting: #double)			write: 10 from: doubles;			close;			terminal.		(bytes reading interpreting: [ :b :i | (b floatAt: i) @ (b floatAt: i + 4) ] size: 8) read: 5	"	^InterpretedReadStream on: self bytesPerElement: byteSize contentsSpecies: Array operation: reader cacheSize: 1</body><body package="Xtreams-Transforms">interpreting: reader size: byteSize cacheSize: cacheSize	"Converts bytes from a binary source according to provided @reader block. The block is evaluated with an instance of InterpretedBytes and and index into it from which it should use byteSize bytes to make an object to return.	""	reader		&lt;BlockClosure&gt;	reading block, e.g. [ :b :i | (b at: i) @ (b at: i + 1) ]		byteSize	&lt;Integer&gt;	byte size of an element		cacheSize	&lt;Integer&gt;	requested cache size (in number of elements)		^			&lt;InterpretedReadStream&gt;	""		| points bytes |		points := Random new reading transforming: [ :in :out | out put: in get @ in get ].		bytes := (ByteArray new writing interpreting: [ :b :i :o | (b floatAt: i put: o x) @ (b floatAt: i + 4 put: o y) ] size: 8 )			write: 10 from: points;			close;			terminal.		(bytes reading interpreting: [ :b :i | (b floatAt: i) @ (b floatAt: i + 4) ] size: 8 cacheSize: 5) read: 5	"	^InterpretedReadStream on: self bytesPerElement: byteSize contentsSpecies: Array operation: reader cacheSize: cacheSize</body><body package="Xtreams-Transforms">marshaling	"Marshaling streams are used to encode arbitrary smalltalk objects into a sequence of bytes suitable for binary storage or transport. The format of the binary encoding is defined by an ObjectMarshaler and is identified by particular version ID. A marshaling read stream decodes objects from a binary source previously encoded by a marshaling write stream.	""	^	&lt;ObjectReadSteam&gt;	""		| rectangle bytes |		rectangle := 5 @ 5 extent: 5 @ 5.		bytes := ByteArray new writing marshaling put: rectangle; conclusion.		bytes reading marshaling get	"	^ObjectReadStream on: self</body><body package="Xtreams-Transforms">marshaling: aMarshaler	"Marshaling streams are used to encode arbitrary smalltalk objects into a sequence of bytes suitable for binary storage or transport. The format of the binary encoding is defined by an ObjectMarshaler and is identified by particular version ID. Custom marshaling schemes can be derived by subclassing ObjectMarshaler. Custom schemes must declare their own (unique) version ID. This method allows to employ a cusomt marshaler instead of the default one (STST2.0).	A marshaling read stream decodes objects from a binary source previously encoded by a marshaling write stream.	""	aMarshaler	&lt;ObjectMarshaler&gt;	implements custom marshaling format		^			&lt;ObjectReadSteam&gt;	""		| rectangle bytes |		rectangle := 5 @ 5 extent: 5 @ 5.		bytes := (ByteArray new writing marshaling: ObjectMarshaler new) put: rectangle; conclusion.		bytes reading marshaling get	"	^aMarshaler streamingUnmarshal: self</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>private</category><body package="Xtreams-Transforms">next	"This is here for compatibility with the existing StreamEncoders so that they can be re-used with transformation streams for encoding."	^self get</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="Xtreams-Transforms">rejecting: aBlock	"Filters elements from the source using aBlock. aBlock has the same form and semantics as the #reject: block on collections."	"	aBlock	&lt;BlockClosure&gt;	usual #reject: style block used to filter the elements passing through		^&lt;TransformReadStream&gt;"	"		((1 to: 10) reading rejecting: [ :e | e odd ]) rest	"	^self transforming: [:input :output |		| value |		[value := input get.		aBlock cull: value] whileTrue.		output put: value]</body><body package="Xtreams-Transforms">selecting: aBlock	"Filters elements from the source using aBlock. aBlock has the same form and semantics as the #select: block on collections."	"	aBlock	&lt;BlockClosure&gt;	usual #select: style block used to filter the elements passing through		^&lt;TransformReadStream&gt;"	"		((1 to: 10) reading selecting: [ :e | e odd ]) rest	"	^self transforming: [:input :output |		| value |		[value := input get.		aBlock cull: value] whileFalse.		output put: value]</body><body package="Xtreams-Transforms">transforming: aBlock	"This is the most general form of transform stream. The block receives two streams, the source (input) and a virtual stream of elements to be produced by the stream (output). The block can read arbitrary number of elements from input (including none) and write arbitrary number of elements into the output (including none). The block will be invoked as many times as necessary to produce the required number of elements, or until an Incomplete is raised. Consequently if the block handles Incomplete from the input, it has to raise another Incomplete at some point, otherwise the stream will never end.	Note that if the contentSpecies of the source doesn't fit the output of the transformation, the contents species of the transform stream has to be set explicitly.	""	aBlock	&lt;BlockClosure&gt;	binary transformation block that reads elements from input (first argument) and writes elements into output (second argument)		^&lt;TransformReadStream&gt;	""	Convert text into a stream of words		('hello world! bye world!' reading transforming: [ :in :out || word char |			word := String new writing.			[	[  (char := in get) = Character space ] whileFalse: [ word put: char ].			] ensure: [ out put: (word close; destination) ] ]		)	contentsSpecies: Array;			rest	""	Convert a hex-string into a byte array (2 characters per byte)		| c2d |		c2d := [ :char | ('0123456789abcdef' indexOf: char) - 1 ].		('0123456789abcdef' reading transforming: [ :in :out |			out put: (c2d value: in get) * 16 + (c2d value: in get) ]		)	buffer: (RingBuffer on: (ByteArray new: 1));			rest	"	^TransformReadStream on: self block: aBlock</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>transforming</category><body package="Xtreams-Transforms">collecting: aBlock	"Transform each written element using #collect: style block."	"	aBlock	&lt;BlockClosure&gt;	a #collect: style block used to tranform each element		^&lt;CollectWriteSteam&gt;	""		(Array new writing collecting: [ :e | e * e ]) write: (1 to: 5); conclusion	""		(String new writing collecting: [ :e | e asCharacter ]) write: (65 to: 90); conclusion	"	^CollectWriteStream on: self block: aBlock</body><body package="Xtreams-Transforms">doing: aBlock	"Perform and action with each passing element using #do: style block."	"	aBlock	&lt;BlockClosure&gt;	a #do: style block invoked with each element as it passes through the stream		^&lt;CollectWriteSteam&gt;	""		(Array new writing doing: [ :e | Transcript space; print: e * e ]) write: (1 to: 10); conclusion	"	^self collecting: [:each | (aBlock value: each). each]</body><body package="Xtreams-Transforms">duplicating: aWriteStream	"Duplicate all the contents written into @aWriteStream"	"	aWriteStream &lt;WriteStream&gt;	a stream to copy into		^&lt;DuplicateWriteSteam&gt;	""		| original copy |		original := Array new writing.		copy := ByteArray new writing.		(original duplicating: copy) write: (0 to: 15).		original conclusion -&gt; copy conclusion	"	^DuplicateWriteStream on: self duplicate: aWriteStream</body><body package="Xtreams-Transforms">encoding: anEncoding	"Transform characters into bytes using @anEncoding such as #utf8 or #ascii, etc. Any encoding supported by StreamEncoder is allowed.	The encoding steam also performs automatic conversion of CRs into the native line-end convention of the underlying platform,	unless set into a different line-end convention mode"	"	anEncoding	&lt;Symbol&gt; encoding identifier recognized by StreamEncoder class&gt;&gt;new:		^&lt;EncodedWriteStream&gt;	""		(ByteArray new writing encoding: #ascii) write: 'abcdefghi'; conclusion	""		(ByteArray new writing encoding: #ascii) write: 'Hello\World' withCRs; conclusion	""		(ByteArray new writing encoding: #ascii) setLineEndCRLF; write: 'Hello\World' withCRs; conclusion	"	^EncodeWriteStream on: self encoding: anEncoding</body><body package="Xtreams-Transforms">encodingBase32	"Encodes bytes into characters of base-32 encoding.	Emits final padding characters ($=) as required, when the stream is closed."	"	^&lt;TransformWriteStream&gt;"	"		(1 to: 5) collect: [ :i | String new writing encodingBase32 write: (ByteArray withAll: (1 to: i)); conclusion ]	"	| map cache |	map := [ :i | 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567' at: i + 1 ].	cache := ByteArray new: 5.	^(self transforming: [ :in :out || bytes chars bits block |			bytes := [ in read: 5 into: cache at: 1 ] on: Incomplete do: [ :incomplete | incomplete count ].			bytes isZero ifTrue: [ Incomplete zero raise ].			block := (1 to: bytes) inject: 0 into: [ :total :byte | (total bitShift: 8) + (cache at: byte)].			bits := bytes * 8.			[ bits &gt; 0 ] whileTrue: [ bits := bits - 5. out put: (map value: ((block bitShift: bits negated) bitAnd: 31)) ].			chars := #[ 2 4 5 7 8 ] at: bytes.			chars &lt; 8 ifTrue: [				8 - chars timesRepeat: [ out put: $= ].				(Incomplete count: bytes) raise ] ]	)	buffer: (RingBuffer on: (ByteArray new: 5));		yourself</body><body package="Xtreams-Transforms">encodingBase64	"Encodes bytes into characters of base-64 encoding.	Emits final padding characters ($=) as required, when the stream is closed."	"	^&lt;TransformWriteStream&gt;"	"		String new writing encodingBase64 write: (ByteArray withAll: (1 to: 20)); conclusion	"	| map cache |	map := [ :i | 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' at: i + 1 ].	cache := ByteArray new: 3.	^(self transforming: [ :in :out | | count block shift |		count := [ in read: 3 into: cache at: 1. 3 ] on: Incomplete do: [ :incomplete | incomplete count].		count isZero ifTrue: [ Incomplete zero raise ].		block := (1 to: count) inject: 0 into: [ :total :byte | (total bitShift: 8) + (cache at: byte)].		shift := count * -8.		1 to: count + 1 do: [:i | out put: (map value: ((block bitShift: (shift + (i * 6))) bitAnd: 63))].		count &lt; 3 ifTrue: [			3 - count timesRepeat: [ out put: $= ].			(Incomplete count: count) raise]])		buffer: (RingBuffer on: (ByteArray new: 3));		yourself</body><body package="Xtreams-Transforms">encodingHex	"Encodes hex characters into bytes."	"	^&lt;TransformReadStream&gt;"	"		ByteArray new writing encodingHex write: '010203fdfeff'; terminal	"	| c2i |	c2i := [ :c | ('0123456789abcdef' indexOf: c asLowercase) - 1 ].	^(self transforming: [ :in :out |		out put: ((c2i value: in get) bitShift: 4) + (c2i value: in get) ])		contentsSpecies: ByteString;		yourself</body><body package="Xtreams-Transforms">injecting: initialObject into: aBlock	"Accumulates a running value combined with each passing element using the binary aBlock. aBlock takes the result of the last evaluation and the next element as arguments. Notable difference from the collection analog is that the streaming variant is a stream of all the intermediate values of the running value."	"	initialObject	&lt;Object&gt; initial value used as the previous result for the evaluation of the first element		aBlock	&lt;BlockClosure&gt; binary block combining the value of each element with previous result of its evaluation		^&lt;CollectingWriteStream&gt;"	"		(Array new writing injecting: 0 into: [ :total :each | each + total ]) write: (1 to: 10); conclusion	"	| nextObject |	nextObject := initialObject.	^self collecting: [:each | nextObject := aBlock cull: nextObject cull: each]</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>interpreting</category><body package="Xtreams-Transforms">interpreting: type	"Converts consumed elements into bytes of pre-configured (primitive) CType, e.g. float, long etc. The type of the written elements must match the CType and the underlying destination must be binary.	""	type	&lt;Symbol&gt;	identifies a (primitive) CType, e.g. #float, #long (mapped via Interpretations)		^		&lt;InterpretedWriteStream&gt;	""		| doubles bytes |		doubles := [ Random new next ] reading.		bytes := (ByteArray new writing interpreting: #double)			write: 10 from: doubles;			close;			terminal.		(bytes reading interpreting: #double) read: 10	"	^self interpreting: type cacheSize: 1</body><body package="Xtreams-Transforms">interpreting: type cacheSize: size	"Converts consumed elements into bytes of pre-configured (primitive) CType, e.g. float, long etc. The type of the written elements must match the CType and the underlying destination must be binary.	""	type	&lt;Symbol&gt;	identifies a (primitive) CType, e.g. #float, #long (mapped via Interpretations)		size		&lt;Integer&gt;	requested buffer size (in number of elements)		^		&lt;InterpretedWriteStream&gt;	""		| doubles bytes |		doubles := [ Random new next ] reading.		bytes := (ByteArray new writing interpreting: #double size: 10)			write: 10 from: doubles;			close;			terminal.		(bytes reading interpreting: #double) read: 10	"	^InterpretedWriteStream on: self type: type cacheSize: size</body><body package="Xtreams-Transforms">interpreting: writer size: byteSize	"Converts objects into bytes in a binary destination according to provided @writer block. The block is evaluated with an instance of InterpretedBytes an index and object to write into the bytes.	""	type		&lt;Symbol&gt;	identifies a (primitive) CType, e.g. #float, #long (mapped via Interpretations)		byteSize	&lt;Integer&gt;	byte size of an element		^			&lt;InterpretedWriteStream&gt;	""		| points bytes |		points := Random new reading transforming: [ :in :out | out put: in get @ in get ].		bytes := (ByteArray new writing interpreting: [ :b :i :o | (b floatAt: i put: o x) @ (b floatAt: i + 4 put: o y) ] size: 8 )			write: 10 from: points;			close;			terminal.		(bytes reading interpreting: [ :b :i | (b floatAt: i) @ (b floatAt: i + 4) ] size: 8 cacheSize: 5) read: 5	"	^InterpretedWriteStream on: self bytesPerElement: byteSize contentsSpecies: Array operation: writer cacheSize: 1</body><body package="Xtreams-Transforms">interpreting: writer size: byteSize cacheSize: cacheSize	"Converts objects into bytes in a binary destination according to provided @writer block. The block is evaluated with an instance of InterpretedBytes an index and object to write into the bytes.	""	type		&lt;Symbol&gt;	identifies a (primitive) CType, e.g. #float, #long (mapped via Interpretations)		byteSize	&lt;Integer&gt;	byte size of an element		cacheSize	&lt;Integer&gt;	requested cache size (in number of elements)		^			&lt;InterpretedWriteStream&gt;	""		| points bytes |		points := Random new reading transforming: [ :in :out | out put: in get @ in get ].		bytes := (ByteArray new writing interpreting: [ :b :i :o | (b floatAt: i put: o x) @ (b floatAt: i + 4 put: o y) ] size: 8 )			write: 10 from: points;			close;			terminal.		(bytes reading interpreting: [ :b :i | (b floatAt: i) @ (b floatAt: i + 4) ] size: 8 cacheSize: 5) read: 5	"	^InterpretedWriteStream on: self bytesPerElement: byteSize contentsSpecies: Array operation: writer cacheSize: cacheSize</body><body package="Xtreams-Transforms">marshaling	"Marshaling streams are used to encode arbitrary smalltalk objects into a sequence of bytes suitable for binary storage or transport. The format of the binary encoding is defined by an ObjectMarshaler and is identified by particular version ID.	A marshaling write stream encodes objects into a binary destination stream.	""	^			&lt;ObjectWriteSteam&gt;	""		| rectangle bytes |		rectangle := 5 @ 5 extent: 5 @ 5.		bytes := ByteArray new writing marshaling put: rectangle; conclusion.		bytes reading marshaling get	"	^ObjectWriteStream on: self</body><body package="Xtreams-Transforms">marshaling: aMarshaler	"Marshaling streams are used to encode arbitrary smalltalk objects into a sequence of bytes suitable for binary storage or transport. The format of the binary encoding is defined by an ObjectMarshaler and is identified by particular version ID. Custom marshaling schemes can be derived by subclassing ObjectMarshaler. Custom schemes must declare their own (unique) version ID. This method allows to employ a cusomt marshaler instead of the default one (STST2.0).	A marshaling write stream encodes objects into a binary destination stream.	""	aMarshaler	&lt;ObjectMarshaler&gt;	implements custom marshaling format		^			&lt;ObjectWriteSteam&gt;	""		| rectangle bytes |		rectangle := 5 @ 5 extent: 5 @ 5.		bytes := (ByteArray new writing marshaling: ObjectMarshaler new) put: rectangle; conclusion.		bytes reading marshaling get	"	^aMarshaler streamingMarshal: self</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>private</category><body package="Xtreams-Transforms">nextPut: anObject	"This is here for compatibility with the existing StreamEncoders so that they can be re-used with transformation streams for encoding."	self put: anObject.	^anObject</body><body package="Xtreams-Transforms">nextPutAll: aCollection	"This is here for compatibility with the existing StreamEncoders so that they can be re-used with transformation streams for encoding."	self write: aCollection.	^aCollection</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>transforming</category><body package="Xtreams-Transforms">rejecting: aBlock	"Filters written elements using aBlock. aBlock has the same form and semantics as the #reject: block on collections."	"	aBlock	&lt;BlockClosure&gt;	usual #reject: style block used to filter the elements passing through		^&lt;TransformWriteStream&gt;"	"		(Array new writing rejecting: [ :e | e odd ]) write: (1 to: 10); conclusion	"	^self selecting: [:each | (aBlock cull: each) not]</body><body package="Xtreams-Transforms">selecting: aBlock	"Filters written elements using aBlock. aBlock has the same form and semantics as the #select: block on collections."	"	aBlock	&lt;BlockClosure&gt;	usual #select: style block used to filter the elements passing through		^&lt;TransformWriteStream&gt;"	"		(Array new writing selecting: [ :e | e odd ]) write: (1 to: 10); conclusion	"	^self transforming: [:input :output |		| value |		[value := input get.		aBlock cull: value] whileFalse.		output put: value]</body><body package="Xtreams-Transforms">transforming: aBlock	"This is the most general form of transform stream. The block receives two streams, a virtual stream of written elements (input) and the destination (output). The block can read arbitrary number of elements from input (including none) and write arbitrary number of elements into the output (including none). The block will be invoked as many times as necessary to consume any written elements, or until an Incomplete is raised by the destination.	Note that if the #contentSpecies of the destination doesn't fit the input of the transformation, the #contentsSpecies of the transform stream has to be set explicitly.	""	aBlock	&lt;BlockClosure&gt;	binary transformation block that reads elements from input (first argument) and writes elements into output (second argument)		^&lt;TransformWriteStream&gt;	""	Convert text into a stream of words		(Array new writing transforming: [ :in :out || word char |			word := String new writing.			[	[  (char := in get) = Character space ] whileFalse: [ word put: char ].			] ensure: [ out put: (word close; destination) ] ]		)	write: 'hello world! bye world!';			close;			terminal	""	Convert a hex-string into a byte array (2 characters per byte)		| c2d |		c2d := [ :char | ('0123456789abcdef' indexOf: char) - 1 ].		(ByteArray new writing transforming: [ :in :out |			out put: (c2d value: in get) * 16 + (c2d value: in get) ]		)	contentsSpecies: String;			write: '0123456789abcdef';			close;			terminal	"	^TransformWriteStream on: self block: aBlock</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>analyse - numbers</category><body package="Xtreams-Transforms">analyse: reading double: aClass	&lt;analyse: 'Core.Double'&gt;	&lt;analyse: 'Core.SmallDouble'&gt;	| double |	reading log: ['double: ', double printString] do: [double := self get: reading double: aClass]</body><body package="Xtreams-Transforms">analyse: reading float: aClass	&lt;analyse: 'Core.Float'&gt;	| float |	reading log: ['float: ', float printString] do: [float := self get: reading float: aClass]</body><body package="Xtreams-Transforms">analyse: reading integer: aClass	&lt;analyse: 'Core.Integer'&gt;	&lt;analyse: 'Core.SmallInteger'&gt;	&lt;analyse: 'Core.LargePositiveInteger'&gt;	&lt;analyse: 'Core.LargeNegativeInteger'&gt;	| indicator integer |	integer := nil.	reading log: [integer ifNil: ['integer'] ifNotNil: ['byte integer: ', integer printString]] do: [		indicator := self get: reading byte: nil.		indicator &lt; 252 ifTrue: [integer := indicator. ^indicator].		indicator = 255 ifTrue: [^self analyse: reading integerNegativeLarge: aClass].		indicator = 254 ifTrue: [^self analyse: reading integerPositiveLarge: aClass].		indicator = 253 ifTrue: [^self analyse: reading integerMedium: aClass].		indicator = 252 ifTrue: [^self analyse: reading integerSmall: aClass]]</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>analyse - complex</category><body package="Xtreams-Transforms">analyse: reading binding: aClass	&lt;analyse: 'Core.VariableBinding'&gt;	| binding isInStandardEnvironment |	reading		log: ['binding: ', binding]		do: [isInStandardEnvironment := self unmarshal: reading.			binding := self get: reading string: String.			isInStandardEnvironment ifFalse:				[reading log: 'value' do: [self analyse: reading].				reading log: 'environment' do: [self analyse: reading]]]</body><body package="Xtreams-Transforms">analyse: reading bytes: aClass	&lt;analyse: 'Core.ByteArray'&gt;	| bytes |	reading log: ['bytes: ', bytes printString] do: [bytes := self get: reading bytes: aClass]</body><body package="Xtreams-Transforms">analyse: reading class: aClass	&lt;analyse: 'Core.Behavior'&gt;	| classId class  |	reading		log:	['class: ', class absoluteName]		do:	[classId := self analyse: reading class_id: [:id :behavior | classId := id. class := behavior]]</body><body package="Xtreams-Transforms">analyse: reading collection: aClass	&lt;analyse: 'Core.Collection'&gt;	&lt;analyse: 'Core.OrderedCollection'&gt;	&lt;analyse: 'Core.Array'&gt;	&lt;analyse: 'Core.Set'&gt;	| size |	reading log: ['collection: ', aClass fullName, ' size: ', size printString] do: [		size := self get: reading integer: nil.		size timesRepeat: [self analyse: reading]]</body><body package="Xtreams-Transforms">analyse: reading compiledcode: aClass	&lt;analyse: 'Kernel.CompiledCode'&gt;	reading log: 'compiled code: ', aClass fullName do: [		| variableSize allInstVarNames |		variableSize := aClass isVariable			ifTrue:	[self get: reading integer: nil]			ifFalse:	[0].		allInstVarNames := aClass allInstVarNames.		1 to: aClass instSize do: [:index | reading log: (allInstVarNames at: index) do: [self analyse: reading]].		1 to: variableSize do: [:index | reading log: index printString do: [self analyse: reading]]]</body><body package="Xtreams-Transforms">analyse: reading dictionary: aClass	&lt;analyse: 'Core.Dictionary'&gt;	&lt;analyse: 'Core.KeyedCollection'&gt;	&lt;analyse: 'Core.Bag'&gt;	| size |	reading log: ['dictionary: ', aClass fullName, ' size: ', size printString] do: [		size := self get: reading integer: nil.		size timesRepeat:			[self analyse: reading.			self analyse: reading]]</body><body package="Xtreams-Transforms">analyse: reading interval: aClass	&lt;analyse: 'Core.Interval'&gt;	reading log: ['interval: ', aClass fullName] do: [		self analyse: reading.		self analyse: reading.		self analyse: reading]</body><body package="Xtreams-Transforms">analyse: reading linkedlist: aClass	&lt;analyse: 'Core.LinkedList'&gt;	| size |	reading log: ['linkedlist: ', aClass fullName, ' size: ', size printString] do: [		size := self get: reading integer: nil.		size timesRepeat: [self analyse: reading]]</body><body package="Xtreams-Transforms">analyse: reading namespace: aClass	&lt;analyse: 'Kernel.NameSpace'&gt;	| namespace |	^reading log: ['namespace: ', namespace absoluteName] do: [namespace := (self get: reading string: String) asStrictReference value]</body><body package="Xtreams-Transforms">analyse: reading object: aClass	&lt;analyse: 'Core.Object'&gt;	reading log: 'object: ', aClass fullName do: [		| variableSize allInstVarNames |		variableSize := aClass isVariable			ifTrue:	[self get: reading integer: nil]			ifFalse:	[0].		allInstVarNames := aClass allInstVarNames.		1 to: aClass instSize do: [:index | reading log: (allInstVarNames at: index) do: [self analyse: reading]].		1 to: variableSize do: [:index | reading log: index printString do: [self analyse: reading]]]</body><body package="Xtreams-Transforms">analyse: reading point: aClass	&lt;analyse: 'Core.Point'&gt;	reading log: 'point' do:		[reading log: 'x:' do: [self analyse: reading].		reading log: 'y:' do: [self analyse: reading]]</body><body package="Xtreams-Transforms">analyse: reading sortedCollection: aClass	&lt;analyse: 'Core.SortedCollection'&gt;	| size |	size := 0.	reading log: ['sorted collection: ', aClass fullName, ' size: ', size printString] do: [		size := self get: reading integer: nil.		reading log: ['sort block'] do: [self analyse: reading].		size timesRepeat: [self analyse: reading]]</body><body package="Xtreams-Transforms">analyse: reading string: aClass	&lt;analyse: 'Core.String'&gt;	&lt;analyse: 'Core.ByteString'&gt;	&lt;analyse: 'Core.TwoByteString'&gt;	&lt;analyse: 'Core.FourByteString'&gt;	| string |	reading log: ['string: ', string printString] do: [string := self get: reading string: aClass]</body><body package="Xtreams-Transforms">analyse: reading struct: aStruct	&lt;analyse: 'Protocols.Struct'&gt;		| structSize allInstVarNames |	reading log: ['struct: ', aStruct fullName, ' size: ',  structSize printString] do: [		structSize := self get: reading integer: nil.		allInstVarNames := aStruct  allInstVarNames.		1 to: aStruct instSize do: [:index | reading log: (allInstVarNames at: index) do: [self analyse: reading]].		1 to: structSize do: [:index | reading log: index printString do: [self analyse: reading]]]</body><body package="Xtreams-Transforms">analyse: reading symbol: aClass	&lt;analyse: 'Core.Symbol'&gt;	&lt;analyse: 'Core.ByteSymbol'&gt;	&lt;analyse: 'Core.TwoByteSymbol'&gt;	&lt;analyse: 'Core.FourByteSymbol'&gt;	| symbol |	reading log: ['symbol: ', symbol printString] do: [symbol := self get: reading symbol: aClass]</body><body package="Xtreams-Transforms">analyse: reading uninterpretedBytes: aClass	&lt;analyse: 'Core.UninterpretedBytes'&gt;	| bytes |	reading log: ['uninterpredBytes: ', bytes printString] do: [bytes := self get: reading uninterpretedBytes: aClass]</body><body package="Xtreams-Transforms">analyse: reading variablePool: aClass	&lt;analyse: 'Tools.WorkspaceVariablePool'&gt;	reading log: ['variable pool'] do:		[reading log: 'import' do: [self get: reading string: String].		reading log: 'bindings' do: [self analyse: reading]].</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>reading - core</category><body package="Xtreams-Transforms">get: reading character: aClass	&lt;reads: 'Core.Character'&gt;	^Character codePoint: (self get: reading integer: nil)</body><body package="Xtreams-Transforms">get: writing false: boolean	&lt;reads: 'Core.False'&gt;	^false</body><body package="Xtreams-Transforms">get: writing nil: undefined	&lt;reads: 'Core.UndefinedObject'&gt;	^nil</body><body package="Xtreams-Transforms">get: writing true: boolean	&lt;reads: 'Core.True'&gt;	^true</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>reading - complex</category><body package="Xtreams-Transforms">get: reading bag: aClass	&lt;reads: 'Core.Bag'&gt;	| size bag |	size := self get: reading integer: nil.	bag := aClass new.	size timesRepeat: [bag add: (self unmarshal: reading) withOccurrences: (self unmarshal: reading)].	^bag</body><body package="Xtreams-Transforms">get: reading binding: aClass	&lt;reads: 'Core.VariableBinding'&gt;	| isInStandardEnvironment |	isInStandardEnvironment := self unmarshal: reading.	isInStandardEnvironment		ifTrue: [^(self get: reading string: String) asStrictReference binding].	^(aClass		key: (self get: reading symbol: Symbol)		value: (self unmarshal: reading))			environment: (self unmarshal: reading);			yourself</body><body package="Xtreams-Transforms">get: reading bytes: aClass	&lt;reads: 'Core.ByteArray'&gt;	| size bytearray |	size := self get: reading integer: nil.	bytearray := ByteArray new: size.	1 to: size do: [:each | bytearray at: each put: (self get: reading byte: nil)].	^bytearray</body><body package="Xtreams-Transforms">get: reading class: aClass	&lt;reads: 'Core.Behavior'&gt;	| class |	self get: reading class_id: [:id :behavior | class := behavior].	^class</body><body package="Xtreams-Transforms">get: reading collection: aClass	&lt;reads: 'Core.Collection'&gt;	&lt;reads: 'Core.OrderedCollection'&gt;	&lt;reads: 'Core.Array'&gt;	| collection size |	size := self get: reading integer: nil.	collection := aClass withSize: size.	1 to: size do: [:index | collection at: index put: (self unmarshal: reading)].	^collection</body><body package="Xtreams-Transforms">get: reading compiledcode: aClass	&lt;reads: 'Kernel.CompiledCode'&gt;	| object variableSize |	aClass isVariable		ifTrue:			[variableSize := self get: reading integer: nil.			object := aClass basicNew: variableSize]		ifFalse:			[variableSize := 0.			object := aClass basicNew].	1 to: aClass instSize do: [:index | object instVarAt: index put: (self unmarshal: reading)].	1 to: variableSize do: [:index | object basicAt: index put: (self unmarshal: reading)].	^object</body><body package="Xtreams-Transforms">get: reading dictionary: aClass	&lt;reads: 'Core.Dictionary'&gt;	&lt;reads: 'Core.KeyedCollection'&gt;	| size dictionary |	size := self get: reading integer: nil.	dictionary := aClass new.	size timesRepeat: [dictionary at: (self unmarshal: reading) put: (self unmarshal: reading)].	^dictionary</body><body package="Xtreams-Transforms">get: reading interval: aClass	&lt;reads: 'Core.Interval'&gt;	| start stop step |	start := self unmarshal: reading.	stop := self unmarshal: reading.	step := self unmarshal: reading.	^Interval from: start to: stop by: step</body><body package="Xtreams-Transforms">get: reading linkedlist: aClass	&lt;reads: 'Core.LinkedList'&gt;	| collection size |	size := self get: reading integer: nil.	collection := aClass new.	1 to: size do: [:index | collection add: (self unmarshal: reading)].	^collection</body><body package="Xtreams-Transforms">get: reading namespace: aClass	&lt;reads: 'Kernel.NameSpace'&gt;	^(self get: reading string: String) asStrictReference value</body><body package="Xtreams-Transforms">get: reading object: aClass	&lt;reads: 'Core.Object'&gt;	| object variableSize |	aClass isVariable		ifTrue:			[variableSize := self get: reading integer: nil.			object := aClass withSize: variableSize]		ifFalse:			[variableSize := 0.			object := aClass basicNew].	1 to: aClass instSize do: [:index | object instVarAt: index put: (self unmarshal: reading)].	1 to: variableSize do: [:index | object basicAt: index put: (self unmarshal: reading)].	^object</body><body package="Xtreams-Transforms">get: reading point: aClass	&lt;reads: 'Core.Point'&gt;	^Point		x: (self unmarshal: reading) 		y: (self unmarshal: reading)</body><body package="Xtreams-Transforms">get: reading set: aClass	&lt;reads: 'Core.Set'&gt;	| set size |	size := self get: reading integer: nil.	set := aClass new: size.	size timesRepeat: [set add: (self unmarshal: reading)].	^set</body><body package="Xtreams-Transforms">get: reading sortedCollection: aClass	&lt;reads: 'Core.SortedCollection'&gt;	| collection size sortBlock |	size := self get: reading integer: nil.	sortBlock := self unmarshal: reading.	collection := Array new: size.	1 to: size do: [:index | collection at: index put: (self unmarshal: reading)].	^SortedCollection withAll: collection sortBlock: sortBlock</body><body package="Xtreams-Transforms">get: reading string: aClass	&lt;reads: 'Core.String'&gt;	&lt;reads: 'Core.ByteString'&gt;	&lt;reads: 'Core.TwoByteString'&gt;	&lt;reads: 'Core.FourByteString'&gt;	| size string |	size := self get: reading integer: nil.	string := aClass new: size.	1 to: size do: [:each | string at: each put: (self get: reading character: nil)].	^string</body><body package="Xtreams-Transforms">get: reading struct: aStruct	"We cannot use #get:object: because it creates instances with #withSize: which is not implemented for Struct."	&lt;reads: 'Protocols.Struct'&gt;	| struct structSize |	structSize := self get: reading integer: nil.	struct := aStruct new: structSize.	1 to: aStruct instSize do: [:index | struct instVarAt: index put: (self unmarshal: reading)].	1 to: structSize do: [:index | struct basicAt: index put: (self unmarshal: reading)].	^struct</body><body package="Xtreams-Transforms">get: reading symbol: aClass	&lt;reads: 'Core.Symbol'&gt;	&lt;reads: 'Core.ByteSymbol'&gt;	&lt;reads: 'Core.TwoByteSymbol'&gt;	&lt;reads: 'Core.FourByteSymbol'&gt;	^(self get: reading string: String) asSymbol</body><body package="Xtreams-Transforms">get: reading uninterpretedBytes: aClass	&lt;reads: 'Core.UninterpretedBytes'&gt;	^aClass from: (self get: reading bytes: ByteArray)</body><body package="Xtreams-Transforms">get: reading variablePool: aClass	&lt;reads: 'Tools.WorkspaceVariablePool'&gt;	^aClass new		imports: (self get: reading string: String);		instVarNamed: 'bindings' put: (self unmarshal: reading);		yourself</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>analyse - core</category><body package="Xtreams-Transforms">analyse: reading character: aClass	&lt;analyse: 'Core.Character'&gt;	| character |	reading log: ['character: ', character printString] do: [character := self get: reading character: aClass]</body><body package="Xtreams-Transforms">analyse: reading false: boolean	&lt;analyse: 'Core.False'&gt;	reading log: 'false' do: [self get: reading false: boolean]</body><body package="Xtreams-Transforms">analyse: reading nil: undefined	&lt;analyse: 'Core.UndefinedObject'&gt;	reading log: 'nil' do: [self get: reading nil: undefined]</body><body package="Xtreams-Transforms">analyse: reading true: boolean	&lt;analyse: 'Core.True'&gt;	reading log: 'true' do: [self get: reading true: boolean]</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>writing - complex</category><body package="Xtreams-Transforms">put: writing bag: bag	&lt;writes: 'Core.Bag'&gt;	self put: writing integer: bag contents size.	bag contents keysAndValuesDo: [:key :value |		self marshal: writing object: key.		self marshal: writing object: value]</body><body package="Xtreams-Transforms">put: writing binding: aBinding	&lt;writes: 'Core.VariableBinding'&gt;	self marshal: writing object: aBinding environment residesInStandardEnvironment.	aBinding environment residesInStandardEnvironment		ifTrue: [^self put: writing string: aBinding absoluteName].	self put: writing string: aBinding key.	self marshal: writing object: aBinding value.	self marshal: writing object: aBinding environment.</body><body package="Xtreams-Transforms">put: writing bytes: bytearray	&lt;writes: 'Core.ByteArray'&gt;	self put: writing integer: bytearray size.	bytearray do: [:byte | self put: writing byte: byte]</body><body package="Xtreams-Transforms">put: writing class: class	&lt;writes: 'Core.Behavior'&gt;	| id missing behavior |	classesMutex critical: [		(missing := (id := classes indexOf: class) == 0)			ifTrue: [id := self includeClass: class]].	self put: writing integer: id.	missing ifFalse: [^id].	behavior := class.	class isMeta ifTrue: [behavior := behavior soleInstance].	self put: writing string: behavior absoluteName.	self marshal: writing object: class isMeta.	self put: writing integer: class format.	self put: writing integer: class instSize.	class allInstVarNames do: [:each | self put: writing string: each].	^id</body><body package="Xtreams-Transforms">put: writing collection: collection	&lt;writes: 'Core.Collection'&gt;	&lt;writes: 'Core.OrderedCollection'&gt;	&lt;writes: 'Core.Array'&gt;	self put: writing integer: collection size.	collection do: [:object | self marshal: writing object: object]</body><body package="Xtreams-Transforms">put: writing compiledcode: aCompiledCode	&lt;writes: 'Kernel.CompiledCode'&gt;	self put: writing object: aCompiledCode</body><body package="Xtreams-Transforms">put: writing dictionary: dictionary	&lt;writes: 'Core.Dictionary'&gt;	&lt;writes: 'Core.KeyedCollection'&gt;	self put: writing integer: dictionary size.	dictionary keysAndValuesDo: [:key :value |		self marshal: writing object: key.		self marshal: writing object: value]</body><body package="Xtreams-Transforms">put: writing interval: interval	&lt;writes: 'Core.Interval'&gt;	self marshal: writing object: interval first.	self marshal: writing object: interval last.	self marshal: writing object: interval increment</body><body package="Xtreams-Transforms">put: writing linkedlist: aLinkedList	&lt;writes: 'Core.LinkedList'&gt;	self put: writing integer: aLinkedList size.	aLinkedList do: [:object | self marshal: writing object: object]</body><body package="Xtreams-Transforms">put: writing namespace: aNamespace	&lt;writes: 'Kernel.NameSpace'&gt;	self put: writing string: aNamespace absoluteName</body><body package="Xtreams-Transforms">put: writing object: object	&lt;writes: 'Core.Object'&gt;	object class isVariable ifTrue: [self put: writing integer: object basicSize].	1 to: object class instSize do: [:index | self marshal: writing object: (object instVarAt: index)].	1 to: object basicSize do: [:index | self marshal: writing object: (object basicAt: index)]</body><body package="Xtreams-Transforms">put: writing point: point	&lt;writes: 'Core.Point'&gt;	self marshal: writing object: point x.	self marshal: writing object: point y</body><body package="Xtreams-Transforms">put: writing set: set	&lt;writes: 'Core.Set'&gt;	self put: writing integer: set size.	set do: [:object | self marshal: writing object: object]</body><body package="Xtreams-Transforms">put: writing sortedCollection: collection	&lt;writes: 'Core.SortedCollection'&gt;	self put: writing integer: collection size.	self marshal: writing object: collection sortBlock.	collection do: [:object | self marshal: writing object: object]</body><body package="Xtreams-Transforms">put: writing string: string	&lt;writes: 'Core.String'&gt;	&lt;writes: 'Core.ByteString'&gt;	&lt;writes: 'Core.TwoByteString'&gt;	&lt;writes: 'Core.FourByteString'&gt;	&lt;writes: 'Core.ByteSymbol'&gt;	&lt;writes: 'Core.TwoByteSymbol'&gt;	&lt;writes: 'Core.FourByteSymbol'&gt;	self put: writing integer: string size.	string do: [:character | self put: writing character: character]</body><body package="Xtreams-Transforms">put: writing struct: aStruct	"Implement the writing counterpart for #get:struct:.	We can reuse #put:object: but apparently the marshaler needs pairs of read/write operations."	&lt;writes: 'Protocols.Struct'&gt;	self put: writing integer: aStruct structSize.	1 to: aStruct class instSize do: [:index | self marshal: writing object: (aStruct instVarAt: index)].	aStruct associationsDo: [ :assoc | self marshal: writing object: assoc ]</body><body package="Xtreams-Transforms">put: writing uninterpretedBytes: uninterpretedBytes	&lt;writes: 'Core.UninterpretedBytes'&gt;	self put: writing bytes: uninterpretedBytes asByteArray</body><body package="Xtreams-Transforms">put: writing variablePool: aPool	&lt;writes: 'Tools.WorkspaceVariablePool'&gt;	self put: writing string: aPool importString.	self marshal: writing object: aPool localBindings</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>writing - core</category><body package="Xtreams-Transforms">put: writing builtins: builtin	&lt;writes: 'Core.True'&gt;	&lt;writes: 'Core.False'&gt;	&lt;writes: 'Core.UndefinedObject'&gt;</body><body package="Xtreams-Transforms">put: writing character: character	&lt;writes: 'Core.Character'&gt;	self put: writing integer: character codePoint</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>writing - numbers</category><body package="Xtreams-Transforms">put: writing double: double	&lt;writes: 'Core.Double'&gt;	&lt;writes: 'Core.SmallDouble'&gt;	writing double put: double</body><body package="Xtreams-Transforms">put: writing float: float	&lt;writes: 'Core.Float'&gt;	writing float put: float</body><body package="Xtreams-Transforms">put: writing integer: integer	&lt;writes: 'Core.Integer'&gt;	&lt;writes: 'Core.SmallInteger'&gt;	&lt;writes: 'Core.LargePositiveInteger'&gt;	&lt;writes: 'Core.LargeNegativeInteger'&gt;	(integer between: 0 and: 251) ifTrue: [^self put: writing byte: integer].	(integer between: -2147483647 and: 2147483648) ifTrue: [^self put: writing integerSmall: integer].	(integer between: -9223372036854775807 and: 9223372036854775808) ifTrue: [^self put: writing integerMedium: integer].	integer positive		ifTrue:	[self put: writing integerPositiveLarge: integer]		ifFalse:	[self put: writing integerNegativeLarge: integer]</body></methods><methods><class-id>Xtreams.ObjectMarshaler</class-id> <category>reading - numbers</category><body package="Xtreams-Transforms">get: reading double: aClass	&lt;reads: 'Core.Double'&gt;	&lt;reads: 'Core.SmallDouble'&gt;	^reading double get</body><body package="Xtreams-Transforms">get: reading float: aClass	&lt;reads: 'Core.Float'&gt;	^reading float get</body><body package="Xtreams-Transforms">get: reading integer: aClass	&lt;reads: 'Core.Integer'&gt;	&lt;reads: 'Core.SmallInteger'&gt;	&lt;reads: 'Core.LargePositiveInteger'&gt;	&lt;reads: 'Core.LargeNegativeInteger'&gt;	| indicator |	indicator := self get: reading byte: nil.	indicator &lt; 252 ifTrue: [^indicator].	indicator = 252 ifTrue: [^self get: reading integerSmall: aClass].	indicator = 253 ifTrue: [^self get: reading integerMedium: aClass].	indicator = 254 ifTrue: [^self get: reading integerLarge: aClass].	indicator = 255 ifTrue: [^(self get: reading integerLarge: aClass) negated]</body></methods><methods><class-id>Xtreams.ObjectMarshaler class</class-id> <category>pragmas</category><body package="Xtreams-Transforms">pragmas	&lt;pragmas: #instance&gt;	^#( #reads: #analyse: #writes: )</body></methods><methods><class-id>Xtreams.JSONWriteStream</class-id> <category>actions</category><body package="Xtreams-Transforms">putArray: aCollection	&lt;action: #{Core.Array}&gt;	&lt;action: #{Core.ByteArray}&gt;	&lt;action: #{Core.WordArray}&gt;	&lt;action: #{Core.DwordArray}&gt;	&lt;action: #{Core.OrderedCollection}&gt;	&lt;action: #{SortedCollection}&gt;	&lt;action: #{SortedCollectionWithPolicy}&gt;	&lt;action: #{Core.Set}&gt;	&lt;action: #{Core.IdentitySet}&gt;	self trackingDepthDo: [		destination write: '['.		aCollection			do: [ :element | self put: element ]			separatedBy: [ destination write: ','; space].		destination write: ']' ]</body><body package="Xtreams-Transforms">putAssociation: anAssociation	&lt;action: #{Core.Association}&gt;	self putObjectWith: [ :emitKeyValue |		emitKeyValue value: anAssociation key asString value: anAssociation value ]</body><body package="Xtreams-Transforms">putBoolean: aBoolean	&lt;action: #{Core.True}&gt;	&lt;action: #{Core.False}&gt;	destination write: (aBoolean ifTrue: ['true'] ifFalse: ['false'])</body><body package="Xtreams-Transforms">putCharacter: aCharacter	&lt;action: #{Core.Character}&gt;	destination write: '"'.	(self isEscaped: aCharacter)		ifTrue: [ self putEscapedCharacter: aCharacter ]		ifFalse: [ destination put: aCharacter ].	destination write: '"'</body><body package="Xtreams-Transforms">putDictionary: aDictionary	&lt;action: #{Core.Dictionary}&gt;	&lt;action: #{Core.IdentityDictionary}&gt;	self putObjectWith: [ :emitKeyValue |		aDictionary keysAndValuesDo: [ :key :value |			emitKeyValue value: key value: value ] ]</body><body package="Xtreams-Transforms">putInteger: anInteger	&lt;action: #{Core.SmallInteger}&gt;	&lt;action: #{Core.LargePositiveInteger}&gt;	&lt;action: #{Core.LargeNegativeInteger}&gt;	destination print: anInteger</body><body package="Xtreams-Transforms">putNull: ignored	"All action: methods must have an argument accept the object to be written, even it it's nil."	&lt;action: #{Core.UndefinedObject}&gt;	destination write: 'null'</body><body package="Xtreams-Transforms">putRealDouble: aDouble	&lt;action: #{Core.Double}&gt;	&lt;action: #{Core.SmallDouble}&gt;	&lt;action: #{Core.Fraction}&gt;	&lt;action: #{Core.FixedPoint}&gt;	| string |	string := aDouble asDouble printString.	string replaceAll: $d with: $e.	destination write: string</body><body package="Xtreams-Transforms">putRealFloat: aFloat	&lt;action: #{Core.Float}&gt;	destination print: aFloat</body><body package="Xtreams-Transforms">putString: aString	&lt;action: #{Core.String}&gt;	&lt;action: #{Core.ByteString}&gt;	&lt;action: #{Core.TwoByteString}&gt;	&lt;action: #{Core.Symbol}&gt;	&lt;action: #{Core.ByteSymbol}&gt;	&lt;action: #{Core.TwoByteSymbol}&gt;	| from size to |	destination write: '"'.	size := aString size.	from := 1.	to := 0.	[ (to := to + 1) &gt; size ] whileFalse: [ | c |		c := aString at: to.		(self isEscaped: c) ifTrue: [			destination write: to - from from: aString at: from.			self putEscapedCharacter: c.			from := to + 1 ] ].	from &gt; size ifFalse: [ destination write: size - from + 1 from: aString at: from ].	destination write: '"'</body></methods><methods><class-id>Xtreams.JSONWriteStream class</class-id> <category>class initialization</category><body package="Xtreams-Transforms">pragmas	&lt;pragmas: #instance&gt;	^#(#action:)</body></methods><initialize><class-id>Xtreams.ASCIIEncoder</class-id></initialize><initialize><class-id>Xtreams.JSONWriteStream</class-id></initialize><initialize><class-id>Xtreams.ISO8859L1Encoder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Encoder</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Support</package></attributes></class></st-source>