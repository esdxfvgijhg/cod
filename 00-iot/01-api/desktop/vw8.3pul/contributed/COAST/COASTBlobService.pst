<?xml version="1.0"?><st-source><!-- Name: COASTBlobServiceNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#any 'SiouX-Server' '') #(#any 'SiouX-Http' '') #(#any 'COASTCore' '') #(#any 'COASTBinaryObjectStore' '') #(#any 'MIME' '') #(#any 'SiouX-Server-Secure' '') #(#any 'TLS' '') #(#any 'X509' '') #(#any 'URISupport' ''))KSignature: #('definedClasses' 4 'definedClassesHash' 3286737353 'extendedClasses' 0 'extendedClassesHash' 0)KSignatureV2: #('definedClasses' 4 'definedClassesHash' 167922355951175926653352208623368812556611806614 'extendedClasses' 0 'extendedClassesHash' 1245845410931227995499360226027473197403882391305)PackageName: COASTBlobServiceParcel: #('COASTBlobService')ParcelDirectory: COASTBlobServicePrerequisiteDescriptions: #(#(#name 'SiouX-Server' #componentType #bundle) #(#name 'SiouX-Http' #componentType #bundle) #(#name 'COASTCore' #componentType #bundle) #(#name 'COASTBinaryObjectStore' #componentType #package) #(#name 'MIME' #componentType #package) #(#name 'SiouX-Server-Secure' #componentType #package) #(#name 'TLS' #componentType #package) #(#name 'X509' #componentType #package) #(#name 'URISupport' #componentType #package))PrerequisiteParcels: #(#('SiouX-Server' '') #('SiouX-Http' '') #('COASTCore' '') #('COASTBinaryObjectStore' '') #('MIME' '') #('SiouX-Server-Secure' '') #('TLS' '') #('X509' '') #('URISupport' ''))Version: 5.4.16Date: 1:32:19 PM July 26, 2014 --><time-stamp>From VisualWorks速, Pre-Release 8.0 (jul14.3) of 25. Juli 2014 on 26. Juli 2014 at 13:32:19</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AbstractBlobService</name><environment>COAST</environment><super>COAST.CoastApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>httpServer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBlobService</package></attributes></class><class><name>MediatorBlobService</name><environment>COAST</environment><super>COAST.AbstractBlobService</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storeAccessors mediator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBlobService</package></attributes></class><class><name>BlobService</name><environment>COAST</environment><super>COAST.AbstractBlobService</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storeAccessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBlobService</package></attributes></class><class><name>BlobResponder</name><environment>COAST</environment><super>SiouX.HttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobService </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBlobService</package></attributes></class><methods><class-id>COAST.AbstractBlobService</class-id> <category>accessing</category><body package="COASTBlobService">portNumber	^ self iniAccess numberAt: 'port' ifAbsent: [ RemoteBinaryStoreInterface defaultPort ]</body><body package="COASTBlobService">storeAccessorFor: storeID	self subclassResponsibility</body><body package="COASTBlobService">transactionManager	^nil</body></methods><methods><class-id>COAST.AbstractBlobService</class-id> <category>security</category><body package="COASTBlobService">certificateFilename	^ self defaultCertificateDirectory construct: 'server.crt'</body><body package="COASTBlobService">createSecurityContext	| context certificateStore |	certificateStore := Xtreams.TLSCertificateStore newWithDefaults.	self inititalizeServerCertificateFor: certificateStore.	context := Xtreams.TLSContext new sessions: Xtreams.TLSSessionCache forServer;			certificates: certificateStore;			yourself.	^ context</body><body package="COASTBlobService">defaultCertificateDirectory	^ 'certificate' asFilename</body><body package="COASTBlobService">defaultKeyDirectory	^ 'private' asFilename</body><body package="COASTBlobService">inititalizeServerCertificateFor: aCertificateStore 	| certificateFile |	certificateFile := self certificateFilename asFilename.	certificateFile exists 		ifTrue: [ self inititalizeServerCertificateFromFile: certificateFile keyFile: self privateKeyFilename asFilename store: aCertificateStore ]		ifFalse: [ self inititalizeTemporaryCertificateFor: aCertificateStore  ]</body><body package="COASTBlobService">inititalizeServerCertificateFromFile: certificateFile keyFile: privateKeyFile store: aCertificateStore 	" Read certificate from file "	| key certificates |	certificateFile exists 		ifFalse: [ CoastError raiseSignal: 'Certificate file (' , certificateFile asString , ') not found' ].	privateKeyFile exists 		ifFalse: [ CoastError raiseSignal: 'Private key file (' , privateKeyFile asString , ') not found' ].	certificates :=		[ Security.X509.CertificateFileReader readFromFile: certificateFile ] 			on: Error			do: [: ex | CoastError raiseSignal: 'Could not load certificate: ' , ex description ].	certificates isEmpty 		ifTrue: [ CoastError raiseSignal: 'No certificates found in ' , self certificateFilename asString ].	key :=		[( Security.X509.CertificateFileReader readFromFile: privateKeyFile ) singleElementOnError: [ CoastError raiseSignal: 'Single private key expected' ]		] on: Error do: [: ex | CoastError raiseSignal: 'Could not load private key: ' , ex description ].	aCertificateStore known: certificates first.	aCertificateStore certificate: certificates key: key getKey.</body><body package="COASTBlobService">inititalizeTemporaryCertificateFor: aCertificateStore 	" Generate temporary Certificate "	| key name certificate |	CoastLog log: 'No certificate file found, creating temporary certificate' channel: #blobs.	key := Xtreams.PrivateKey algorithm: 'RSA' size: 2048.	name := Security.X509.Name new CN: SocketAccessor getHostname; yourself.	certificate :=		Security.X509.Certificate new			serialNumber: Time microsecondClock;			issuer: name;			subject: name;			notBefore: Date today;			notAfter: (Date today addDays: 365);			publicKey: key asX509Key asPublicKey;			yourself.	certificate tbsCertificate getEmptyKeyUsage keyEncipherment: true; digitalSignature: true.	certificate signUsing: key hash: 'SHA256' padding: 'PKCS1'.	aCertificateStore known: certificate.	aCertificateStore certificate: (Array with: certificate) key: key .</body><body package="COASTBlobService">privateKeyFilename	^ self defaultKeyDirectory construct: 'server.key'</body></methods><methods><class-id>COAST.AbstractBlobService</class-id> <category>config</category><body package="COASTBlobService">needsIni	^false</body></methods><methods><class-id>COAST.AbstractBlobService</class-id> <category>release</category><body package="COASTBlobService">shutDown	" Shut down the client. The client cannot restart afterwards "	httpServer notNil 		ifTrue: 		[	CoastLog log: 'Stopping blob service at port ' , self portNumber printString channel: #blobs.			httpServer release.			httpServer := nil		].</body></methods><methods><class-id>COAST.AbstractBlobService</class-id> <category>initialize-release</category><body package="COASTBlobService">newServerAt: ipAddress 	| securityContext listener |	CoastLog log: 'Starting blob service at port ' , self portNumber printString channel: #blobs.	httpServer := SiouX.Server id: self class name.	securityContext := self createSecurityContext .	listener := httpServer listenOn: ipAddress for: SiouX.HttpsConnection.	listener tlsContext: securityContext.	httpServer addResponder: ( BlobResponder blobService: self ).	httpServer start.	CoastLog log: 'Blob service started'.	^ httpServer</body></methods><methods><class-id>COAST.AbstractBlobService class</class-id> <category>accessing</category><body package="COASTBlobService">defaultIniFilename	^ 'blobservice.ini'</body></methods><methods><class-id>COAST.MediatorBlobService</class-id> <category>release</category><body package="COASTBlobService">shutDown	" Shut down the client. The client cannot restart afterwards "	super shutDown.	storeAccessors notNil ifTrue: 		[	storeAccessors do: [ : acc | acc release ].			storeAccessors := nil		].</body></methods><methods><class-id>COAST.MediatorBlobService</class-id> <category>accessing</category><body package="COASTBlobService">createStoreAccessorFor: storeID 	| volumeID interface store clusterManager |	volumeID := ( storeID tokensBasedOn: $+ ) first.	clusterManager := mediator volumeManager clusterManagers 			detect: [: cm | cm volumeID = volumeID ]			ifNone: [ nil ].	clusterManager isNil ifTrue: [ CoastError raiseSignal: 'volume with id ' , volumeID , ' not found or inactive' ].	store := CoastBinaryStore findStore: storeID withClusterManager: clusterManager.	store isNil ifTrue: [ CoastError raiseSignal: 'binary store with id ' , storeID , ' not found' ].	interface := clusterManager storageInterface binaryStoreInterfaceNeededForStore: store.	^ interface storeAccessor</body><body package="COASTBlobService">storeAccessorFor: storeID 	| acc |	acc := storeAccessors at: storeID ifAbsent: [ nil ].	(acc isNil or: [ acc isActive not ])	ifTrue:	[		acc := self createStoreAccessorFor: storeID.		storeAccessors at: storeID put: acc.	].	^acc</body></methods><methods><class-id>COAST.MediatorBlobService</class-id> <category>initialize-release</category><body package="COASTBlobService">startAsSubApplicationOf: coastApplication 	mediator := coastApplication.	storeAccessors := Dictionary new.	CoastBinaryStoreAccessor isLibraryAvailable 		ifFalse: 		[	CoastLog logError: 'SQLite library is not available' channel: #blobs.			Notifier isDevelopment 				ifFalse: [ ObjectMemory quitWithError: CoastExitCode unhandledException ]		].	self newServerAt: self portNumber.</body></methods><methods><class-id>COAST.BlobService</class-id> <category>accessing</category><body package="COASTBlobService">storeAccessor	^storeAccessor</body><body package="COASTBlobService">storeAccessorFor: storeID	^storeAccessor</body></methods><methods><class-id>COAST.BlobService</class-id> <category>initialize-release</category><body package="COASTBlobService">initialize	"initialize and start the blobservice"	super initialize.	storeAccessor := CoastBinaryStoreAccessor new.	storeAccessor initializeDB.	self newServerAt: self portNumber.</body></methods><methods><class-id>COAST.BlobService</class-id> <category>release</category><body package="COASTBlobService">shutDown	" Shut down the client. The client cannot restart afterwards "	super shutDown.	storeAccessor notNil ifTrue: 		[	storeAccessor release.			storeAccessor := nil		].	self removePidFile.</body></methods><methods><class-id>COAST.BlobResponder</class-id> <category>accessing</category><body package="COASTBlobService">blobService: aBlobService 	blobService := aBlobService.</body></methods><methods><class-id>COAST.BlobResponder</class-id> <category>utility</category><body package="COASTBlobService">query: query keysAndValuesDo: aBlock 	| encoder stream |	encoder := URLEncoder new setEncoder: ( StreamEncoder new: #utf8 ).	query == nil 		ifTrue: [ ^ self ].	stream := query readStream.	[ stream atEnd ] whileFalse: 		[ | field key val mid |			field := stream upTo: $&amp;.			( mid := field indexOf: $= ) isZero 				ifTrue: 				[	key := field.					val := ''				]				ifFalse: 				[	key := field copyFrom: 1 to: mid - 1.					val := field copyFrom: mid + 1 to: field size				].			key := encoder decode: key.			val := encoder decode: val.			aBlock value: key value: val		].</body></methods><methods><class-id>COAST.BlobResponder</class-id> <category>services</category><body package="COASTBlobService">delete: fileID storeID: storeID 	( self accessorForStoreID: storeID ) delete: fileID storeID: storeID.	^ SiouX.HttpResponse code: 200</body><body package="COASTBlobService">executeRequest: httpRequest connection: connection 	^ [ | urlPath storeID fileID authorized |		urlPath := httpRequest url path.		urlPath size &lt; 2 			ifTrue: 			[	^ ( SiouX.HttpResponse code: 400 )					contents: 'Missing parameters storeID / fileID';					yourself			].		storeID := urlPath at: urlPath size - 1.		fileID := urlPath last.		"Hier die Authentifizierung (HMAC) pr端fen"		authorized := self checkSignatureOf: httpRequest storeID: storeID fileID: fileID.		authorized 			ifFalse: 			[	^ ( SiouX.HttpResponse code: 401 )					contents: 'signature does not match';					yourself			].		httpRequest method = 'GET' 			ifTrue: [ self get: fileID storeID: storeID ]			ifFalse: 			[	httpRequest method = 'PUT' 					ifTrue: [ self put: httpRequest fileID: fileID storeID: storeID ]					ifFalse: 					[	httpRequest method = 'DELETE' 							ifTrue: [ self delete: fileID storeID: storeID ]					]			]	] 		on: Error		do: 		[: ex |			CoastLog logException: ex message: 'Error in blob responder'.			( SiouX.HttpResponse code: 500 )				contents: 'Could not execute request';				yourself		]</body><body package="COASTBlobService">get: fileID storeID: storeID 	| fileEntry response dispo contentFilename |	fileEntry := ( self accessorForStoreID: storeID ) fileEntryFor: fileID.	fileEntry isNil 		ifTrue: 		[	^ ( SiouX.HttpResponse code: 404 )				contents: 'File entry not found';				yourself		].	contentFilename := ( self accessorForStoreID: storeID ) filenameForFileID: fileID storeID: storeID.	contentFilename isNil 		ifTrue: 		[	^ ( SiouX.HttpResponse code: 404 )				contents: 'Content not found';				yourself		].	response := SiouX.HttpResponse code: 200.	response contents: contentFilename.	dispo := response contentDisposition: 'attachment'.	fileEntry filename ifNotNil: [: filename | dispo fileName: filename ].	fileEntry mimeType ifNotNil: [: mimeType | response contentType: mimeType ].	^ response</body><body package="COASTBlobService">put: httpRequest fileID: fileID storeID: storeID 	| bodyStream mimeType filename |	bodyStream := httpRequest body ifNil: [ ByteArray new reading ].	mimeType := nil.	httpRequest headers: 'Content-Type' do: [: field | mimeType := field body rest ].	filename := nil.	self 		query: httpRequest url query		keysAndValuesDo: 		[: key : value |			key = 'filename' 				ifTrue: [ filename := value ]		].	( self accessorForStoreID: storeID ) uploadFromStream: bodyStream fileID: fileID storeID: storeID mimeType: mimeType filename: filename.	^ SiouX.HttpResponse code: 200</body></methods><methods><class-id>COAST.BlobResponder</class-id> <category>private</category><body package="COASTBlobService">accessorForStoreID: storeID 	^ blobService storeAccessorFor: storeID</body><body package="COASTBlobService">checkSignatureOf: httpRequest storeID: storeID fileID: fileID 	| httpVerb dateString signature authorization timestamp |	httpVerb := httpRequest method.	dateString := nil.	authorization := nil.	"bei redirects haben wir keine wahl und m端ssen signatur und date als query-parameter 端bertragen"	self 		query: httpRequest url query		keysAndValuesDo: 		[: key : value |			key = 'signature' 				ifTrue: [ authorization := value ].			key = 'date' 				ifTrue: [ dateString := value ]		].	dateString isNil 		ifTrue: [ httpRequest headers: 'Date' do: [: field | dateString := field body rest ]].	timestamp :=		[ Net.RFC822Scanner dateAndTimeFrom: dateString ] on: Error do: [: ex | nil ].	authorization isNil 		ifTrue: [ httpRequest headers: 'Authorization' do: [: field | authorization := field body rest ]].	signature := ( self accessorForStoreID: storeID ) base64SignVerb: httpVerb storeID: storeID fileID: fileID dateString: dateString.	^ signature isNil or: [ signature = authorization and: [ timestamp notNil and: [( Timestamp now asSeconds - timestamp asSeconds ) abs &lt; 600 ]]]	"10 min. abweichung ist erlaubt"</body></methods><methods><class-id>COAST.BlobResponder class</class-id> <category>instance creation</category><body package="COASTBlobService">blobService: blobService 	^ self new blobService: blobService;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CoastApplication</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration winService startAction subApplications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>HttpResponder</name><environment>SiouX</environment><super>SiouX.Responder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class></st-source>