<?xml version="1.0"?><st-source><!-- Name: COASTBinaryObjectStoreNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#any 'Glorp' '') #(#any 'UUID' '') #(#any 'Database' '') #(#any 'HTTP' '') #(#any 'MIME' '') #(#any 'SHA' '') #(#any 'TLS' '') #(#any 'HashesBase' '') #(#any 'COASTCore' '') #(#any 'URISupport' '') #(#any 'SQLite3EXDI' ''))PackageName: COASTBinaryObjectStoreParcel: #('COASTBinaryObjectStore')ParcelDirectory: COASTBinaryObjectStorePrerequisiteDescriptions: #(#(#name 'Glorp' #componentType #bundle) #(#name 'UUID' #componentType #package) #(#name 'Database' #componentType #package) #(#name 'HTTP' #componentType #package) #(#name 'MIME' #componentType #package) #(#name 'SHA' #componentType #package) #(#name 'TLS' #componentType #package) #(#name 'HashesBase' #componentType #package) #(#name 'COASTCore' #componentType #bundle) #(#name 'URISupport' #componentType #package) #(#name 'SQLite3EXDI' #componentType #package))PrerequisiteParcels: #(#('Glorp' '') #('UUID' '') #('Database' '') #('HTTP' '') #('MIME' '') #('SHA' '') #('TLS' '') #('HashesBase' '') #('COASTCore' '') #('URISupport' '') #('SQLite3EXDI' ''))Version: 5.5.6Date: 11:13:00 AM July 18, 2014 --><time-stamp>From VisualWorks®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:13:00</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BinaryStoreInterface</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storeID secret </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>LocalBinaryStoreInterface</name><environment>COAST</environment><super>COAST.BinaryStoreInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storeAccessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>RemoteBinaryStoreInterface</name><environment>COAST</environment><super>COAST.BinaryStoreInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceURL </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>StoreIDEntry</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storeID storeNum secret </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>FileEntry</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileID directory mimeType filename fileSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>BinaryStoreDescriptorSystem</name><environment>COAST</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>CoastBinaryStore</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>StoreEntry</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileID storeNum </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>CoastExternalBinaryContainer</name><environment>COAST</environment><super>COAST.AbstractBinaryContainer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>CoastBinaryStoreAccessor</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseDirectory blobsDirectory objectAccessors dbSession freeDirectories stores storesByID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><class><name>CoastBlobError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTBinaryObjectStore</package></attributes></class><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>db</category><body package="COASTBinaryObjectStore">directoriesInDB	&lt;lintFilterRuleNamed: #sentNotImplemented&gt;	| query |	query := Glorp.Query read: FileEntry.	query retrieve: [:each | each directory distinct].	query orderBy: #directory.	^dbSession execute: query</body><body package="COASTBinaryObjectStore">stores	&lt;lintFilterRuleNamed: #sentNotImplemented&gt;	| query |	query := Glorp.Query read: StoreIDEntry.	query retrieve: [:each | each storeID distinct].	query orderBy: #storeID.	^dbSession execute: query</body></methods><methods><class-id>COAST.BinaryStoreInterface</class-id> <category>testing</category><body package="COASTBinaryObjectStore">isLocalInterface	^false</body></methods><methods><class-id>COAST.BinaryStoreInterface</class-id> <category>security</category><body package="COASTBinaryObjectStore">base64SignVerb: httpVerb fileID: fileID dateString: dateString 	^self class base64SignVerb: httpVerb storeID: storeID fileID: fileID dateString: dateString secret: secret</body></methods><methods><class-id>COAST.BinaryStoreInterface</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">secret	^ secret</body><body package="COASTBinaryObjectStore">secret: aSecret 	secret := aSecret.</body><body package="COASTBinaryObjectStore">storeID	^ storeID</body><body package="COASTBinaryObjectStore">storeID: aStoreID 	storeID := aStoreID.</body></methods><methods><class-id>COAST.BinaryStoreInterface</class-id> <category>api</category><body package="COASTBinaryObjectStore">bytesForFileID: fileID	" Returns the bytes of the file "	self subclassResponsibility</body><body package="COASTBinaryObjectStore">uploadBytes: bytes fileID: fileID mimeType: mimeType filename: filename 	" Store the bytes as the given file. Raises a CoastError if not possible "	self subclassResponsibility.</body></methods><methods><class-id>COAST.BinaryStoreInterface class</class-id> <category>security</category><body package="COASTBinaryObjectStore">base64SignVerb: httpVerb storeID: storeID fileID: fileID dateString: dateString secret: secret	| streamToSign |	secret isNil ifTrue: [ ^ nil ].	"public"	streamToSign := String new writeStream.	streamToSign nextPutAll: httpVerb; nextPut: Character lf.	streamToSign nextPutAll: storeID; nextPut: Character lf.	streamToSign nextPutAll: fileID; nextPut: Character lf.	streamToSign nextPutAll: dateString.	^ self encodeBase64: ( self sign: ( streamToSign contents asByteArrayEncoding: #utf8 ) secret: secret )</body><body package="COASTBinaryObjectStore">encodeBase64: aByteArray	" ByteArray in einen Base64-codierten String umwandeln "	| output |	output := ( ByteArray new withEncoding: #base64) writeStream.	aByteArray do: [ : byte | output nextPut: (Character value: byte) ].	output close.	^ output encodedContents asByteString</body><body package="COASTBinaryObjectStore">sign: aMessage secret: secret	^(Security.HMAC SHA: (secret asByteArrayEncoding: #utf8) )		hash: aMessage</body></methods><methods><class-id>COAST.LocalBinaryStoreInterface</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">storeAccessor	^ storeAccessor</body><body package="COASTBinaryObjectStore">storeAccessor: aStoreAccessor 	storeAccessor := aStoreAccessor.</body></methods><methods><class-id>COAST.LocalBinaryStoreInterface</class-id> <category>testing</category><body package="COASTBinaryObjectStore">isLocalInterface	^true</body></methods><methods><class-id>COAST.LocalBinaryStoreInterface</class-id> <category>initialize-release</category><body package="COASTBinaryObjectStore">release	storeAccessor release</body></methods><methods><class-id>COAST.LocalBinaryStoreInterface</class-id> <category>api</category><body package="COASTBinaryObjectStore">bytesForFileID: fileID	^storeAccessor bytesForFileID: fileID</body><body package="COASTBinaryObjectStore">uploadBytes: bytes fileID: fileID mimeType: mimeType filename: filename 	^ storeAccessor uploadFromStream: bytes reading fileID: fileID storeID: storeID mimeType: mimeType filename: filename</body></methods><methods><class-id>COAST.LocalBinaryStoreInterface class</class-id> <category>instance creation</category><body package="COASTBinaryObjectStore">storeID: storeID storeAccessor: accessor 	^ self new storeID: storeID;		storeAccessor: accessor;		yourself</body></methods><methods><class-id>COAST.RemoteBinaryStoreInterface</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">serviceURL	^ serviceURL</body><body package="COASTBinaryObjectStore">serviceURL: aServiceURL 	serviceURL := aServiceURL.</body></methods><methods><class-id>COAST.RemoteBinaryStoreInterface</class-id> <category>private</category><body package="COASTBinaryObjectStore">buildRequest: httpVerb for: fileID 	| request path auth dateString |	path := self pathFor: fileID.	request := Net.HttpRequest method: httpVerb url: path.	secret notNil ifTrue: 		[	dateString := Net.RFC822Scanner dateStringFrom: Timestamp now.			request date: dateString.			auth := self class base64SignVerb: httpVerb storeID: storeID fileID: fileID dateString: dateString secret: secret.			request authorization: auth		].	^ request</body><body package="COASTBinaryObjectStore">pathFor: fileID 	^ self serviceURL , '/' , storeID , '/' , fileID</body><body package="COASTBinaryObjectStore">sendRequest: aHttpRequest 	| response |	response := nil.		[ | client |			client := Net.HttpClient new.			client readingOptions saveAttachmentsAsFiles: false.			[					[ response := client executeRequest: aHttpRequest ] on: Xtreams.TLSCertificateWarning do: [: ex | ex resume ]			] ensure: [ client close ]		] on: Net.HttpException do: [: ex | ex resume ].	^ response</body></methods><methods><class-id>COAST.RemoteBinaryStoreInterface</class-id> <category>api</category><body package="COASTBinaryObjectStore">bytesForFileID: fileID 	| request response |	request := self buildRequest: 'GET' for: fileID.	response := self sendRequest: request.	^ (response notNil and: [ response isSuccess ])  		ifTrue: [ (response byteContents) ifNil: [ #[] ] ]		ifFalse: [ nil ]</body><body package="COASTBinaryObjectStore">uploadBytes: bytes fileID: fileID mimeType: mimeType filename: filename 	| request response encoder stream |	request := self buildRequest: 'PUT' for: fileID.	filename notNil 		ifTrue: 		[	encoder := URLEncoder new setEncoder: ( StreamEncoder new: #utf8 ).			stream := String new writeStream.			stream nextPutAll: '&amp;filename='.			encoder encode: filename onto: stream.			request url query: stream contents		].	request byteSource: bytes readStream.	mimeType notNil 		ifTrue: [ request contentType: mimeType ].	response := self sendRequest: request.	response isNil 		ifTrue: [ CoastBlobError raiseSignal: 'Could not upload bytes, no response' ].	response isSuccess 		ifFalse: [ CoastBlobError raiseSignal: 'Could not upload bytes (error code: ' , response code displayString, ', message: "', response contents, '")' ].</body></methods><methods><class-id>COAST.RemoteBinaryStoreInterface class</class-id> <category>instance creation</category><body package="COASTBinaryObjectStore">defaultPort	^30000</body><body package="COASTBinaryObjectStore">defaultServiceURLAtHost: mediatorHost	| mediatorHostWithoutPort |	mediatorHostWithoutPort := (mediatorHost tokensBasedOn: $:) first.	^'https://', mediatorHostWithoutPort , ':', self defaultPort printString</body><body package="COASTBinaryObjectStore">store: store mediatorHost: mediatorHost	| serviceURL |	serviceURL := store serviceURL ifNil: [ self defaultServiceURLAtHost: mediatorHost ].	^ self new storeID: store storeID;		secret: store secret;		serviceURL: serviceURL;		yourself</body></methods><methods><class-id>COAST.StoreIDEntry</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">secret	^ secret</body><body package="COASTBinaryObjectStore">secret: aSecret 	secret := aSecret.</body><body package="COASTBinaryObjectStore">storeID	^ storeID</body><body package="COASTBinaryObjectStore">storeID: aStoreID 	storeID := aStoreID.</body><body package="COASTBinaryObjectStore">storeNum	^ storeNum</body><body package="COASTBinaryObjectStore">storeNum: aStoreNum 	storeNum := aStoreNum.</body></methods><methods><class-id>COAST.FileEntry</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">directory	^ directory</body><body package="COASTBinaryObjectStore">directory: aDirectory 	directory := aDirectory.</body><body package="COASTBinaryObjectStore">fileID	^ fileID</body><body package="COASTBinaryObjectStore">fileID: aFileID 	fileID := aFileID.</body><body package="COASTBinaryObjectStore">fileSize	^ fileSize</body><body package="COASTBinaryObjectStore">fileSize: aFileSize 	fileSize := aFileSize.</body><body package="COASTBinaryObjectStore">filename	^ filename</body><body package="COASTBinaryObjectStore">filename: aFilename 	filename := aFilename.</body><body package="COASTBinaryObjectStore">mimeType	^ mimeType</body><body package="COASTBinaryObjectStore">mimeType: aMimeType 	mimeType := aMimeType.</body></methods><methods><class-id>COAST.BinaryStoreDescriptorSystem</class-id> <category>tables</category><body package="COASTBinaryObjectStore">tableForFILEENTRIES: aTable 	( aTable createFieldNamed: 'fileID' type: ( platform varChar: 255 )) bePrimaryKey.	( aTable createFieldNamed: 'directory' type: ( platform varChar: 255 )) beIndexed.	aTable createFieldNamed: 'mimeType' type: ( platform varChar: 127 ).	aTable createFieldNamed: 'filename' type: ( platform varChar: 1023 ).	aTable createFieldNamed: 'fileSize' type: platform integer.</body><body package="COASTBinaryObjectStore">tableForSTOREENTRIES:  aTable 	(aTable createFieldNamed: 'fileID' type: (platform varChar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'storeNum' type: (platform integer)) bePrimaryKey.</body><body package="COASTBinaryObjectStore">tableForSTORES: aTable 	( aTable createFieldNamed: 'storeNum' type: platform integer ) bePrimaryKey.	( aTable createFieldNamed: 'storeID' type: ( platform varChar: 255 )) bePrimaryKey.	aTable createFieldNamed: 'secret' type: ( platform varChar: 255 ).</body></methods><methods><class-id>COAST.BinaryStoreDescriptorSystem</class-id> <category>initialization</category><body package="COASTBinaryObjectStore">constructAllClasses	^(super constructAllClasses)		add: FileEntry;		add: StoreEntry;		add: StoreIDEntry;		yourself</body></methods><methods><class-id>COAST.BinaryStoreDescriptorSystem</class-id> <category>descriptors</category><body package="COASTBinaryObjectStore">descriptorForFileEntry: aDescriptor 	| table |	table := self tableNamed: 'FileEntries'.	aDescriptor table: table.	( aDescriptor newMapping: Glorp.DirectMapping ) from: #fileID to: ( table fieldNamed: 'fileID' ).	( aDescriptor newMapping: Glorp.DirectMapping ) from: #directory to: ( table fieldNamed: 'directory' ).	( aDescriptor newMapping: Glorp.DirectMapping ) from: #mimeType to: ( table fieldNamed: 'mimeType' ).	( aDescriptor newMapping: Glorp.DirectMapping ) from: #filename to: ( table fieldNamed: 'filename' ).	( aDescriptor newMapping: Glorp.DirectMapping ) from: #fileSize to: ( table fieldNamed: 'fileSize' ).</body><body package="COASTBinaryObjectStore">descriptorForStoreEntry: aDescriptor 	| table |	table := self tableNamed: 'StoreEntries'.	aDescriptor table: table.	( aDescriptor newMapping: Glorp.DirectMapping ) from: #fileID to: ( table fieldNamed: 'fileID' ).	( aDescriptor newMapping: Glorp.DirectMapping ) from: #storeNum to: ( table fieldNamed: 'storeNum' ).</body><body package="COASTBinaryObjectStore">descriptorForStoreIDEntry: aDescriptor 	| table |	table := self tableNamed: 'Stores'.	aDescriptor table: table.	( aDescriptor newMapping: Glorp.DirectMapping ) from: #storeNum to: ( table fieldNamed: 'storeNum' ).	( aDescriptor newMapping: Glorp.DirectMapping ) from: #storeID to: ( table fieldNamed: 'storeID' ).	( aDescriptor newMapping: Glorp.DirectMapping ) from: #secret to: ( table fieldNamed: 'secret' ).</body></methods><methods><class-id>COAST.BinaryStoreDescriptorSystem</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">allTableNames	"Return a list of all the table names that this system uses."	^#('FileEntries' 'StoreEntries' 'Stores').</body></methods><methods><class-id>COAST.CoastBinaryStore</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">addDeletedFileID: aString	self at: #deletedFileIDs add: aString.</body><body package="COASTBinaryObjectStore">deletedFileIDs	^ self at: #deletedFileIDs.</body><body package="COASTBinaryObjectStore">deletedFileIDs: someDeletedFileIDs	self at: #deletedFileIDs setAll: someDeletedFileIDs.</body><body package="COASTBinaryObjectStore">isDefault	^ self at: #isDefault.</body><body package="COASTBinaryObjectStore">isDefault: aBoolean	self at: #isDefault set: aBoolean.</body><body package="COASTBinaryObjectStore">removeDeletedFileID: aString	self at: #deletedFileIDs remove: aString.</body><body package="COASTBinaryObjectStore">secret	^ (self at: #secret) ifNil: [ self class testSecret ].</body><body package="COASTBinaryObjectStore">secret: aString	self at: #secret set: aString.</body><body package="COASTBinaryObjectStore">serviceURL	^ self at: #serviceURL.</body><body package="COASTBinaryObjectStore">serviceURL: aString	self at: #serviceURL set: aString.</body><body package="COASTBinaryObjectStore">storeID	"= unique volume id + fullFrameID"	^self clusterManager uniqueVolumeID, '+', self fullIDString</body></methods><methods><class-id>COAST.CoastBinaryStore</class-id> <category>accessing - interface</category><body package="COASTBinaryObjectStore">interface	^ self clusterManager binaryStoreInterfaceNeededForStore: self</body></methods><methods><class-id>COAST.CoastBinaryStore</class-id> <category>printing</category><body package="COASTBinaryObjectStore">printOn: aStream	self isDefault ifTrue: [ aStream nextPutAll: 'Default ' ].	aStream nextPutAll: 'Binary Store ('.	aStream nextPutAll: self storeID.	aStream nextPutAll: ')'.</body></methods><methods><class-id>COAST.CoastBinaryStore class</class-id> <category>constants</category><body package="COASTBinaryObjectStore">testSecret	^'198279hs48719187h27f7293hf74fh47f1h2394fh4h9vbbvhkf'</body></methods><methods><class-id>COAST.CoastBinaryStore class</class-id> <category>slots</category><body package="COASTBinaryObjectStore">deletedFileIDsSlot	^ (self slotOfType: #setProxy)		range: String;		yourself</body><body package="COASTBinaryObjectStore">isDefaultSlot	^ self slotSingleValue		range: Boolean;		defaultValue: false;		yourself</body><body package="COASTBinaryObjectStore">secretSlot	^ self slotSingleValue		range: String;		yourself</body><body package="COASTBinaryObjectStore">serviceURLSlot	^ self slotSingleValue		range: String;		yourself</body></methods><methods><class-id>COAST.CoastBinaryStore class</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">defaultNeededWithClusterManager: clusterManager 	| adminFrame defaultStore |	adminFrame := clusterManager rootClusterNeeded administrationFrame.	defaultStore := adminFrame binaryStores singleElementIfNone: [ nil ]			ifMore: 			[: stores |				stores 					detect: [: store | store isDefault ]					ifNone: [ nil ]			].	defaultStore isNil ifTrue: 		[	defaultStore := CoastBinaryStore newColocatedTo: adminFrame.			defaultStore isDefault: true.			adminFrame addBinaryStore: defaultStore		].	^ defaultStore</body><body package="COASTBinaryObjectStore">findStore: storeID withClusterManager: clusterManager 	| adminFrame |	adminFrame := clusterManager rootClusterNeeded administrationFrame.	^adminFrame binaryStores					detect: [: store | store storeID = storeID ]					ifNone: [ nil ]</body></methods><methods><class-id>COAST.StoreEntry</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">fileID	^ fileID</body><body package="COASTBinaryObjectStore">fileID: aFileID 	fileID := aFileID.</body><body package="COASTBinaryObjectStore">storeNum	^ storeNum</body><body package="COASTBinaryObjectStore">storeNum: anInteger	storeNum := anInteger.</body></methods><methods><class-id>COAST.CoastExternalBinaryContainer</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">fileID	^ self at: #fileID.</body><body package="COASTBinaryObjectStore">fileID: aString	self at: #fileID set: aString.</body><body package="COASTBinaryObjectStore">fileIDNeeded	| id |	^ self fileID ifNil: 		[	id := UUIDGenerator default next asString.			self fileID: id.			id		]</body><body package="COASTBinaryObjectStore">store	^ self at: #store.</body><body package="COASTBinaryObjectStore">store: aCoastBinaryStore	self at: #store set: aCoastBinaryStore.</body></methods><methods><class-id>COAST.CoastExternalBinaryContainer</class-id> <category>api</category><body package="COASTBinaryObjectStore">bytes	^self store interface bytesForFileID: self fileID</body><body package="COASTBinaryObjectStore">bytes: bytes 	self size: bytes size.	^ self store interface uploadBytes: bytes fileID: self fileID mimeType: self mimeType filename: self filename</body><body package="COASTBinaryObjectStore">removeFromStoreIfPossible	"logically remove from store"	| fileID store |	self ownRemoveFromClusterOnCommit.	( self fastAt: #coastInternalReferencedBy ) isEmpty ifTrue: 		[	fileID := self fileID.			fileID isNil ifTrue: [ ^ self ].			store := self store.			self depleteSlot: #fileID.			store notNil ifTrue: 				[	store addDeletedFileID: fileID.					self depleteSlot: #store				]		].</body></methods><methods><class-id>COAST.CoastExternalBinaryContainer</class-id> <category>transfer</category><body package="COASTBinaryObjectStore">downloadToFile: aFilename 	| aStream bytes |	bytes := self bytes.	bytes isNil 		ifTrue: [ CoastBlobError raiseSignal: 'Could not download contents' ].	aStream := aFilename writeStream.	[	aStream binary.		aStream nextPutAll: bytes	] ensure: [ aStream close ].</body><body package="COASTBinaryObjectStore">uploadFromFile: aFilename clusterManager: aClusterManager filename: filenameString 	| store mimeType bytes stream |	mimeType := nil.	(Net.MimeTypeDescriptor guessFromExtension: aFilename extension) ifNotNil: [ : guessType | mimeType := guessType ] .	self store isNil ifTrue: 		[	store := self clusterManager findOrCreate: CoastBinaryStore named: 'default-store'.			self store: store		].	stream := aFilename readStream binary.	[ bytes := stream upToEnd ] ensure: [ stream close ].	self store interface uploadBytes: bytes fileID: self fileID mimeType: mimeType filename: filenameString.	self filename: filenameString.	mimeType notNil ifTrue: [  self mimeType: mimeType ].	self size: bytes size.</body></methods><methods><class-id>COAST.CoastExternalBinaryContainer class</class-id> <category>instance creation</category><body package="COASTBinaryObjectStore">newInStore: aStore colocatedTo: aFrameOrNil 	| newInst |	newInst := aFrameOrNil isNil 			ifTrue: [ self newTempInVolumeOf: aStore clusterManager ]			ifFalse: [ self newTempInCluster: aFrameOrNil cluster ].	newInst fileIDNeeded.	newInst store: aStore.	^ newInst</body></methods><methods><class-id>COAST.CoastExternalBinaryContainer class</class-id> <category>slots</category><body package="COASTBinaryObjectStore">fileIDSlot	^ self slotSingleValue		range: String;		yourself</body><body package="COASTBinaryObjectStore">storeSlot	^ self slotSingleValue		range: CoastBinaryStore;		yourself</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>directories</category><body package="COASTBinaryObjectStore">baseDirectory	" base directory for all volumes"	baseDirectory isNil ifTrue: 		[ | dir |			dir := nil.			dir isNil ifTrue: [ dir := '.' asFilename ].			dir isRelative ifTrue: [ dir := dir head asFilename construct: dir tail ].			dir exists ifFalse: 				[	dir makeFullDirectory.					dir exists ifFalse: [ self error: 'cannot access base directory: ' , dir asString ].					dir makeWritable				].			baseDirectory := dir		].	^ baseDirectory</body><body package="COASTBinaryObjectStore">blobsDirectory	"answer the blobs directory as filename"	blobsDirectory isNil ifTrue: 		[	blobsDirectory := ( self baseDirectory construct: self class blobsDirectoryName ) asFilename.			blobsDirectory exists ifFalse: 				[	blobsDirectory makeFullDirectory.					blobsDirectory exists ifFalse: [ self error: 'cannot access base directory: ' , blobsDirectory asString ].					blobsDirectory makeWritable				]		].	^ blobsDirectory</body><body package="COASTBinaryObjectStore">blobsDirectoryForStore: storeID 	| bd sd |	bd := self blobsDirectory.	sd := bd construct: storeID.	^ sd exists 		ifTrue: [ sd ]		ifFalse: [ nil ]</body><body package="COASTBinaryObjectStore">blobsDirectoryNeededForStore: storeID 	| bd sd |	bd := self blobsDirectory.	sd := bd construct: storeID.	sd exists ifFalse: 		[	sd makeFullDirectory.			sd exists ifFalse: [ self error: 'cannot access blobs base directory: ' , sd asString ].			sd makeWritable		].	^sd</body><body package="COASTBinaryObjectStore">directoriesOnDisc	| bd |	bd := self blobsDirectory.	bd exists ifFalse: 		[	^#()		].	^bd directoryContents select: [ : entry | entry size = self directoryNameLength ].</body><body package="COASTBinaryObjectStore">directoryNameFor: anInteger 	| stream |	stream := String new writeStream.	anInteger printOn: stream paddedWith: $0 to: self directoryNameLength base: 16.	^ stream contents</body><body package="COASTBinaryObjectStore">directoryNumberFrom: aString 	^Integer readFrom: (ReadStream on: aString) radix: 16</body><body package="COASTBinaryObjectStore">filenameFor: fileID	| dir |	dir := self directoryOf: fileID.	dir isNil ifTrue: [ ^nil ].	^(self blobsDirectory construct: dir) construct: fileID</body><body package="COASTBinaryObjectStore">nextFreeDirectory	"das nächste freie directory ermitteln und gleich eine neue Belegung dort einplanen"	| newDir |	freeDirectories isNil ifTrue: 		[	freeDirectories := Dictionary new.			self directoriesInDB do: 				[: dir | | count |					count := self numberOfFilesIndirectory: dir.					count &lt; self maxNumberOfFilesPerDirectory ifTrue: [ freeDirectories at: dir put: count ]				]		].	freeDirectories isEmpty ifTrue: 		[	newDir := self directoryNameFor: ( self highestDirectoryNumber ifNil: [ 0 ] ifNotNil: [: num | num + 1 ]).			freeDirectories at: newDir put: 1.			^ newDir		].	freeDirectories keysAndValuesDo: 		[: dir : count |			freeDirectories at: dir put: count + 1.			count + 1 &gt;= self maxNumberOfFilesPerDirectory ifTrue: [ freeDirectories removeKey: dir ].			^ dir		].	^ nil	"hier sollte man nie ankommen"</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>db</category><body package="COASTBinaryObjectStore">cachedStores	stores isNil ifTrue: 		[	stores := Dictionary new.			( dbSession read: StoreIDEntry ) do: [: entry | stores at: entry storeNum put: entry ]		].	^ stores</body><body package="COASTBinaryObjectStore">cachedStoresByID	storesByID isNil ifTrue: 		[	storesByID := Dictionary new.			( dbSession read: StoreIDEntry ) do: [: entry | storesByID at: entry storeID put: entry ]		].	^ storesByID</body><body package="COASTBinaryObjectStore">closeDB	dbSession notNil ifTrue: [ dbSession accessor logout ].	dbSession := nil.</body><body package="COASTBinaryObjectStore">delete: fileID storeID: storeID	"todo: error handling, 2 phase commit ;-)"	dbSession inUnitOfWorkDo: 		[ | storeIDs dir stor storeNum |			storeIDs := self storeIDsOf: fileID.			(storeIDs includes: storeID) ifTrue:			[				storeNum := self storeNumFromStoreIDNeeded: storeID.				stor := StoreEntry new.				stor fileID: fileID.				stor storeNum: storeNum.				dbSession delete: stor.				storeIDs size = 1 ifTrue:				[					dir := (dbSession readOneOf: FileEntry where: [: each | each fileID = fileID ]).					dir notNil ifTrue: [						(self filenameFor: fileID) ifNotNil: [ : fname | fname delete ].						dbSession delete: dir					].				].			].		].</body><body package="COASTBinaryObjectStore">directoryOf: fileID 	^ ( self fileEntryFor: fileID ) ifNotNil: [: entry | entry directory ]</body><body package="COASTBinaryObjectStore">fileEntryFor: fileID 	^ dbSession readOneOf: FileEntry where: [: each | each fileID = fileID ]</body><body package="COASTBinaryObjectStore">filesInStore: storeID 	| storeNum |	storeNum := self storeNumFromStoreID: storeID.	^(dbSession read: StoreEntry where: [: each | each storeNum = storeNum ]) collect: [ : entry | entry fileID ]</body><body package="COASTBinaryObjectStore">highestDirectory	| dirs |	dirs := self directoriesInDB.	^dirs isEmpty ifTrue: [ nil ] ifFalse: [ dirs last ].</body><body package="COASTBinaryObjectStore">highestDirectoryNumber	| dirs |	dirs := self directoriesInDB.	^dirs isEmpty ifTrue: [ nil ] ifFalse: [ self directoryNumberFrom: dirs last ].</body><body package="COASTBinaryObjectStore">initializeDB	| login accessor |	login := Glorp.Login new			database: Glorp.SQLite3Platform new;			username: 'coast';			password: 'coast';			connectString: (self blobsDirectory construct: 'index.sqlite') asString.	accessor := Glorp.DatabaseAccessor forLogin: login.	accessor login.	dbSession := BinaryStoreDescriptorSystem sessionForLogin: login.	dbSession accessor: accessor.	accessor beginTransaction.	dbSession createTablesIfNecessary.	accessor commitTransaction.</body><body package="COASTBinaryObjectStore">insert: fileID intoDirectory: directory 	| dir |	dbSession inUnitOfWorkDo: 		[	dir := FileEntry new.			dir fileID: fileID.			dir directory: directory.			dbSession register: dir		].</body><body package="COASTBinaryObjectStore">insert: fileID intoStore: storeID 	| storeNum stor |	storeNum := self storeNumFromStoreIDNeeded: storeID.	dbSession inUnitOfWorkDo: 		[	stor := StoreEntry new.			stor fileID: fileID.			stor storeNum: storeNum.			dbSession register: stor		].</body><body package="COASTBinaryObjectStore">numberOfFilesIndirectory: directory 	^ dbSession count: FileEntry where: [: each | each directory = directory ]</body><body package="COASTBinaryObjectStore">storeIDsOf: fileID 	^(dbSession read: StoreEntry where: [: each | each fileID = fileID ]) collect: [ : entry | (self cachedStores at: entry storeNum) storeID ]</body><body package="COASTBinaryObjectStore">storeNumFromStoreID: storeID	^(dbSession readOneOf: StoreIDEntry where: [: each | each storeID = storeID ]) ifNotNil: [ : entry | entry storeNum ]</body><body package="COASTBinaryObjectStore">storeNumFromStoreIDNeeded: storeID 	^ ( self storeNumFromStoreID: storeID ) ifNil: 		[ | storeNum newStoreIDEntry |			dbSession inUnitOfWorkDo: 				[	storeNum := 0.					( dbSession read: StoreIDEntry ) do: [: entry | entry storeNum &gt; storeNum ifTrue: [ storeNum := entry storeNum ]].					storeNum := storeNum + 1.					newStoreIDEntry := StoreIDEntry new.					newStoreIDEntry storeID: storeID.					newStoreIDEntry storeNum: storeNum.					dbSession register: newStoreIDEntry				].			storeNum		]</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>initialize-release</category><body package="COASTBinaryObjectStore">release	self closeDB.	super release.</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>constants</category><body package="COASTBinaryObjectStore">directoryNameLength	^ 8</body><body package="COASTBinaryObjectStore">maxNumberOfFilesPerDirectory	^ 2000</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>security</category><body package="COASTBinaryObjectStore">base64SignVerb: httpVerb storeID: storeID fileID: fileID dateString: dateString 	| storedSecret |	storedSecret := ( self cachedStoresByID at: storeID ifAbsent: [ nil ]) ifNotNil: [: storeIDEntry | storeIDEntry secret ifNil: [ CoastBinaryStore testSecret ] ].	^BinaryStoreInterface base64SignVerb: httpVerb storeID: storeID fileID: fileID dateString: dateString secret: storedSecret</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">baseDirectory: aBaseDirectory 	baseDirectory := aBaseDirectory.</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>testing</category><body package="COASTBinaryObjectStore">isActive	^dbSession notNil</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>upload-download</category><body package="COASTBinaryObjectStore">byteStreamForFileID: fileID storeID: storeID 	" Returns a stream (Xtreams) on the file "	^ ( self filenameForFileID: fileID storeID: storeID ) ifNotNil: [: filename | filename reading ]</body><body package="COASTBinaryObjectStore">filenameForFileID: fileID storeID: storeID 	" Returns the Filename of file with the given id "	(( self storeIDsOf: fileID ) includes: storeID ) 		ifFalse: [ CoastBlobError raiseSignal: 'Unknown store ID ', storeID printString ].	^ self filenameFor: fileID</body><body package="COASTBinaryObjectStore">uploadFromStream: byteStream fileID: fileID storeID: storeID mimeType: mimeType filename: filename 	" Upload a new file "	| fileStream dir subDir fileName storeNum |	( self directoryOf: fileID ) notNil ifTrue: [ CoastBlobError raiseSignal: 'File overwrite in blobstore not allowed' ].	dir := self nextFreeDirectory.	subDir := self blobsDirectory construct: dir.	subDir exists ifFalse: 		[	subDir makeFullDirectory.			subDir exists ifFalse: [ CoastBlobError raiseSignal: 'cannot access blobstore directory: ' , subDir asString ].			subDir makeWritable		].	fileName := subDir construct: fileID.	fileStream := fileName writing.	[ fileStream write: byteStream ] ensure: [ fileStream close ].	storeNum := self storeNumFromStoreIDNeeded: storeID.	dbSession inUnitOfWorkDo: 		[ | entry stor |			entry := FileEntry new.			entry fileID: fileID.			entry directory: dir asString.			entry mimeType: mimeType.			entry filename: filename.			entry fileSize: fileName fileSize.			dbSession register: entry.			stor := StoreEntry new.			stor fileID: fileID.			stor storeNum: storeNum.			dbSession register: stor		].</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor</class-id> <category>upload-download - compatibility</category><body package="COASTBinaryObjectStore">bytesForFileID: fileID 	" Note: use the streaming API if possible "	| stream |	stream := ( self filenameFor: fileID ) reading.	^ [ stream rest ] ensure: [ stream close ]</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor class</class-id> <category>constants</category><body package="COASTBinaryObjectStore">blobsDirectoryName	^'blobs'</body></methods><methods><class-id>COAST.CoastBinaryStoreAccessor class</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">isLibraryAvailable	^ [		SQLite3ThreadedInterface new sqlite3_libversion.		true.	] on: ExternalLibraryError do: [ : ex |		false	].</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>table creation</category><body package="COASTBinaryObjectStore">createTables: aCollection ifError: aBlock	"Create the tables for our descriptor system. This will fail if the tables already exist. Use recreateTables for that."	| sequences |	system platform areSequencesExplicitlyCreated		ifTrue:			[sequences := self system allSequencesFor: aCollection.			sequences do: [:each | accessor createSequence: each ifError: aBlock]].	aCollection do: [:each | accessor createTable: each ifError: aBlock].	aCollection do: [:each | accessor createTableIndexes: each ifError: aBlock].	self platform supportsConstraints ifTrue: [aCollection do: [:each | accessor createTableFKConstraints: each ifError: aBlock]].</body><body package="COASTBinaryObjectStore">createTablesIfNecessary	"Create the tables for our descriptor system. This will not fail if the tables already exist"	self createTables: system allTables ifError: [ : ex | (ex class = UnableToPrepare and: [ ex parameter singleElementOrNil ifNil: [ false ] ifNotNil: [ : dbError | dbError dbmsErrorCode = 1 ]]) ifTrue: [ ^self ] ifFalse: [ ex pass] ].</body></methods><methods><class-id>COAST.AbstractStorageInterface</class-id> <category>binary storage</category><body package="COASTBinaryObjectStore">binaryStoreInterfaceNeededForStore: store 	binaryStoreInterfaces isNil ifTrue: [ binaryStoreInterfaces := Dictionary new ].	^ binaryStoreInterfaces at: store storeID ifAbsentPut: [ self createBinaryStoreInterfaceForStore: store ]</body><body package="COASTBinaryObjectStore">createBinaryStoreInterfaceForStore: storeID 	self subclassResponsibility</body></methods><methods><class-id>COAST.RemoteStorageInterface</class-id> <category>binary storage</category><body package="COASTBinaryObjectStore">createBinaryStoreInterfaceForStore: store	self notYetImplemented</body></methods><methods><class-id>COAST.CatCSClusterAdministrationFrame class</class-id> <category>slots</category><body package="COASTBinaryObjectStore">binaryStoresSlot	^ (self slotOfType: #set)		range: CoastBinaryStore;		yourself</body></methods><methods><class-id>COAST.CatCSClusterAdministrationFrame</class-id> <category>accessing</category><body package="COASTBinaryObjectStore">addBinaryStore: aCoastBinaryStore	self at: #binaryStores add: aCoastBinaryStore.</body><body package="COASTBinaryObjectStore">binaryStores	^ self at: #binaryStores.</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>binary storage</category><body package="COASTBinaryObjectStore">binaryStoreBaseDirectory	^ self clusterManager storageInterface storageAccessor workingDirectory asFilename</body><body package="COASTBinaryObjectStore">createBinaryStoreInterfaceForStore: store 	"ok for now - theoretically you could run without mediator but use a separate blob service (e.g. AWS)"	| accessor |	accessor := CoastBinaryStoreAccessor new.	accessor baseDirectory: self binaryStoreBaseDirectory.	accessor initializeDB.	^ LocalBinaryStoreInterface storeID: store storeID storeAccessor: accessor</body><body package="COASTBinaryObjectStore">deleteBinaryStore	| blobsDirectory |	super deleteBinaryStore.	blobsDirectory := self binaryStoreBaseDirectory asFilename construct: (CoastBinaryStoreAccessor blobsDirectoryName).	blobsDirectory exists ifTrue: [ blobsDirectory deleteRecursively ].</body><body package="COASTBinaryObjectStore">moveBinaryStoreTo: backupDirectory	| blobsDirectory |	super moveBinaryStoreTo: backupDirectory.	blobsDirectory := self binaryStoreBaseDirectory asFilename construct: CoastBinaryStoreAccessor blobsDirectoryName.	blobsDirectory exists ifTrue: [ blobsDirectory moveToRecursively: (backupDirectory construct: CoastBinaryStoreAccessor blobsDirectoryName) ].</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatFSFrame</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>coastFrameClassSymbol coastFrameClassName </class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSClusterAdministrationFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastError</name><environment>COAST</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><class><name>AbstractStorageInterface</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager binaryStoreInterfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>RemoteStorageInterface</name><environment>COAST</environment><super>COAST.AbstractStorageInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>AbstractBinaryContainer</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>LocalStorageInterface</name><environment>COAST</environment><super>COAST.AbstractStorageInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storageAccessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class></st-source>