<?xml version="1.0"?><st-source><!-- Name: Xtreams-CoreNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: Xtreams is a generalized stream/iterator framework providing simple, unified API for reading from various kinds of *sources* and writing into various kinds of *destinations* (Collections, Sockets, Files, Pipes, etc). Streams themselves can be sources or destinations as well, allowing to *stack* streams on top of each other. At the bottom of such stack is some kind of non-stream (e.g. a collection), we will call it a *terminal*. Directly above it is a specialized stream providing a streaming facade over the terminal. The rest of the streams in the stack we'll call *transforms*. Their primary purpose is to perform some kind of transformation on the elements that are passing through. Application code interacts with the top stream of the stack the same way it would with any other stream (or stream stack) producing/consuming the same elements. The goal of the framework is to provide consistent behavior of different stacks so that the application code can treat them the same way regardless of what exactly is the ultimate source or destination. For example an application analyzing binary data should be able to treat the source stream the same way if it is a simple stream over a ByteArray or if it is a stack providing contents of a specific binary part of a mulitpart, gziped and chunked HTTP response coming through a socket. Xtreams is an attempt to achieve this goal in a scalable and efficient manner.Note that the sequence of streams in a stack cannot be completely arbitrary. Each transform constrains the type of input it accepts and the type of output it produces. Since the adjacent streams in a stack are linked so that input of one is connected to the output of the other, they need to produce/consume same type of elements . For example, a "character encoding" read transform converting bytes to characters can only sit on top of a stream that produces bytes (0..255). These constraints are not checked when the stack is being constructed, it is up to the application code to make sure the streams in the stack are compatible with their adjacent streams.The framework is split into several packages:|| *Package Xtreams-*				||	*Notes*	|||| [Core]			||	Defines the API and core classes	|||| [Terminals]		||	Streams for all supported terminals (Collections, Blocks, Files, Sockets, Pipes, etc) |||| [Transforms]	||	Core transform streams (collection style, encodings, marshaling, etc) |||| [Substreams]	||	Streams embedded in other streams, slicing and stitching streams |||| [Multiplexing]	||	A substreaming protocol for sharing a paired read/write stream |||| [Crypto]		||	Cryptographic transforms (hashing, encryption, etc) |||| [Xtras]			||	Additional non-core transforms (e.g. compression) |||| [Parsing]		||	PEG parsing for Xtreams with a collection of parsers/generators (PEG, Smalltalk, Javascript, Wiki, etc) ||	== Stream Creation ==Xtreams strictly separate read and write streams. This allows for simpler API with better consistency. If necessary it would be quite simple to create a wrapper that holds a separate read and write stream and dispatches the read operations to one and write operations to the other.Streams are primarily created by messages with -ing suffix on the first keyword (it often is a simple unary message). A read stream on top of an arbitrary *source* terminal is created by sending message #reading to it. The source can be a collection, an IOAccessor (socket, pipe), aFilename, etc. For an exhaustive list of supported types of sources see package Xtreams-Terminals. If #reading is sent to a read stream, the same stream is returned.Similarly, a write stream is created by sending #writing to a *destination* terminal. Generally the same kinds of objects can serve as sources or destinations, Xtreams-Terminals provides further details on what those are. Message #writing sent to a write stream returns the same stream.	== Basic Operations ==Here are few simple examples showing equivalent code in classic streams and xtreams:{{{	"classic"	'hello world' readStream next: 5.	"xtreams"	'hello world' reading read: 5.}}}{{{	"classic"	String new writeStream nextPutAll: 'hello'; contents	"xtreams"	String new writing write: 'hello'; close; terminal}}}Nothing terribly surprising here, just some API changes. Note that xtreams do not provide the #contents message. It's a read operation and as such it doesn't really fit a write stream. Consequently it only works in specific circumstances (e.g. above), but not in a case like this for example:{{{	(ByteArray new withEncoding: #ascii) writeStream nextPutAll: 'Hello'; contents}}}Instead, in Xtreams, if you close a write stream on a collection it will trim the underlying collection down to the actual content. So the collection itself corresponds to stream #contents after closing. This provides equivalent capability within the constraints of generally applicable write stream API. Message #terminal can be used to retrieve the underlying terminal from a stream or stream stack. Message #conclusion can be used as a convenient shortcut combining #close and #terminal together.Here's a rough correspondence table of the most common API||	*classic*			||	*xtreams*				||||	next					||	get						||||	nextPut:				||	put:						||||	next:				||	read:					||||	next:into:startingAt:	||	read:into:/read:into:at:		||||	nextPutAll:			||	write:					||||	next:putAll:startingAt:	||	write:from:/write:from:at: 	||||	upToEnd			||	rest						||||	skip:				||	++						||	== Stream Copying ==Another useful difference is that read streams can be used as arguments of write: and write:from:. This provides a simple and efficient way of copying from stream to stream. Providing this capability at the API level allows for interesting optimizations, for example copying between two collection streams will eventually boil down to a single copy operation between the underlying collections. So the classic (slow) stream copying pattern{{{	source := 'Hello World' readStream.	destination := String new writeStream.	[ source atEnd ] whileFalse: [ destination nextPut: source next ].	destination contents}}}becomes simple and optimal{{{	String new writing write: 'Hello World' reading; conclusion}}}	== End Of Stream ==Another difference that you'll probably notice early on is that reading past the end of stream is not a notification which returns nil by default. With Xtreams it is always an exception, Incomplete, the same way you get IncompleteNextCountError with #next:/#next:into:startingAt: (but not with #next). Incomplete always carries count of elements that were read or written successfully, and optionally also the destination or source collection and start parameters to provide easy access to whatever was successfully processed. Similarly, the positioning APIs report the actual change of position, with collection and start being nil. As usual the stream that raises the exception is the originator.{{{	[ 'Hello World!' reading ++ 6; read: 50 ] on: Incomplete do: [ :ex | ex contents ]}}}Another significant difference is that xtreams do not provide the #atEnd test. Depending on the type of stream, implementing such test may require an actual read attempt to be able to answer. Once you perform a read, you'll need to cache the element if the stream is not positionable. This gets even more complicated with complex stream stacks. Instead xtreams provide several alternatives each suitable for different circumstances. Message #rest reads everything that is left in the stream and automatically handles the Incomplete exception at the end.{{{	'Hello World!' reading read: 6; rest}}}If you don't want to collect all the elements in the collection, xtreams also support collection style iteration protocols{{{	'Hello World!' reading		read: 6;		inject: 0 into: [ :count :each | count + 1 ]}}}For comparison here's a common "read line by line" example in both classic and xtream style{{{	text := 'line1\line2\line3\line4' withCRs readStream.	lines := OrderedCollection new.	[ text atEnd ] whileFalse: [ lines add: (text upTo: Character cr) ].	lines}}}{{{	text := 'line1\line2\line3\line4' withCRs reading.	slicer := (text ending: Character cr) slicing.	slicer collect: [ :line | line rest ]}}}The xtreams example relies on some features that are yet to be discussed, but the point we're trying to make here is that there's often better way to handle the classic pattern. For example if you want only up to first 3 characters from each line, just change the 'line rest' bit into '(line limiting: 3) rest'. The slicing layer will take care of aligning the underlying stream for you automatically, whereas in the classic case the code would have to handle it explicitly. It's also worth noting that the xtreams solution will do it efficiently. Each line can be processed as a stream of its own avoiding creation of unnecessary and potentially costly garbage.Obviously, if you can't find more suitable solution, any use of atEnd can be replaced by an Incomplete handler. For example the usual looping pattern{{{	[ stream atEnd ] whileFalse: [ ... ]}}}can be converted to{{{	[ [ ... ] repeat ] on: Incomplete do: [ :ex | ]}}}The stream can be ended in a way that it wasn't closed, but an error was raised. Usually this is a kind of OsError and it is not the same as knowing that a stream closed. The Incomplete exception does not raise when an OsError occurs on the underlying terminal. An example of where this distinction matters would be HTTP/1.0 where the body contents are sent to you and you know that the body is completely sent when the connection closes - however, if you receive an OsError before the Incomplete then you know you did not receive the entire body. Better protocols of course give you an indication of how much content there should be, so usually you want to catch OsError at a higher level of your application.	== Enumeration ==As was alluded to above, read streams provide all the traditional, collection style enumeration API: #collect:, #select:, #inject:into:, etc. Including some of the more recent additions like #do:separatedBy: and #groupedBy. This allows certain level of polymorphism with Collections. It's not clear at this point how far should we take this. For example we also provide concatenation of read streams with #, as an experimental feature (in Xtreams-Xtras).	== Closing ==It is beneficial to get into the habit of always closing a stream when you're done with it. However, it is worth noting, you should never close a stream that you did not create. If you are handed a stream from a framework or library, you should expect the framework or library to close it when execution control returns to it. Even though in particular cases it may end up being a noop, not making that assumption in your algorithm may extend its applicability to wider range of streams and stream stacks. Closing the stream isn't necessarily just a matter of releasing resources. Especially with write streams it may be important to perform additional activity to properly terminate the stream. Some of these might be unobvious implementation aspects that may need to be properly cleared out. For example, current implementation of generic TransformWriteStream involves a background process which won't be terminated if the stream is not closed. Given that even read transforms may involve arbitrary side-effects, similar precautions apply to read streams as well. The best approach is to always close a stream when you're done with it.	== Positioning / Seeking ==Not all streams are naturally positionable. Traditionally, an algorithm that required positionability was restricted to naturally positionable streams. Xtreams attempt to bridge this gap by providing positioning for non-positionable streams via a specialized buffering transform (PositionRead/WriteStream). To make sure a stream is positionable, send it #positioning. It returns the same stream if it already is positionable.{{{	Random new reading positioning read: 5; -  2; read: 2}}}The positioning API imitates pointer arithmetic. Only skipping forward (++) and skipping to the end (-= 0) is available on both positionable and non-positionable streams.||	*message*	|| 	*notes*	||||	position		||	returns current position from the beginning(1) of the stream ||||	position:		||	sets current position from the beginning(1) of the stream ||||	available	||	how many elements are left from current position to the end(1) ||||	length		||	total size of the stream (position + available) ||||	++			||	skips forward specified number of elements ||||	- 			||	skips backward specified number of elements ||||	-=			||	skips backward specified number of elements from the end(1) of the stream ||||	+=			||	skips forward specified number of elements from the beginning(1) of the stream ||Some streams, such as sequenceable collection write streams and file write streams, can be positioned past the end of their current size. In this situation, #position:, #-= and #+= can all position the stream beyond the current size. The size of the stream will not change until an actual write is performed. It is possible to use -= with a negative argument to move from the end of the stream in to its future. This mode of operation is called "sparse writing".(1) Note that interpretation of beginning of the stream is slightly different in the case of the augmented non-positionable streams. The true beginning of the stream may not be reachable by the time the stream is wrapped in the positioning layer, so the beginning refers to the position at the time the stream is wrapped (unless specific buffering strategy, e.g. a ring buffer, moves the beginning of the buffer forward, in which case the beginning of the stream moves with it). This applies equally to read and write streams.The backward skipping operators -  and -= cannot skip past the beginning of the stream. Incomplete will be raised if such request is made leaving the stream positioned at the beginning. Similarly the forward skipping operators += and ++ cannot skip past the end of the stream, and raises Incomplete if such request is made leaving the stream positioned at the end.{{{		[ Random new reading positioning read: 5; -  8 ] on: Incomplete do: [ :ex | ex count ]}}}There are several things to keep in mind when using the positioning/buffering transform. Some methods of the positioning API need to discover the end of the underlying stream, specifically #-=, #available and #length. These will cause the underlying stream to seek to the end immediately (filling up the positioning buffer along the way). Consequently, if the underlying stream is infinite, these operations will not return (potentially exhausting available memory, if the buffering strategy in use keeps growing the buffer).Once added the positioning layer cannot be removed arbitrarily. In the case of read streams the underlying stream is always aligned with the end of the positioning buffer. With write stream the underlying destination stream is aligned with the beginning of the positioning buffer, i.e. the elements are written when they either fall out of the bottom of the buffer (e.g. in case of fixed size ring buffer) or the stream is explicitly flushed (all buffered elements are written and buffer is reinitialized). While it should be safe to remove the positioning layer when its position is aligned with the underlying stream, it's best to avoid it altogether. Consequently, if an algorithm requires a positionable stream, it should be the caller's responsibility to pass in a positionable stream, not the algorithm attempting to turn arbitrary stream into a positionable one, because the positioning layer usually cannot be passed back to the caller.Buffering requires memory and different algorithms may require different buffering strategies. There are several Buffer classes available that are used throughout the framework for various purposes. Streams that employ buffers allow to replace the default buffer with a different one via the #buffer: message. For example if an algorithm only needs to be able to peek up to five elements ahead, RingBuffer of size 5 is efficient and doesn't waste memory.	== Exploring ==Any positionable stream can be explored. The #explore: method is an enhancement of the classic #peek. A 'stream peek' can be replaced with{{{	stream explore: [ stream get ]}}}The advantage of #explore: is that the block allows arbitrary activity with the stream. The stream will return back to its original position when the block completes. For example you can peek for arbitrary number of elements, not just one:{{{	actions at: (stream explore: [ stream read: 3 ]))		ifAbsent: [ "not an action ID, do something else with the stream" ]		ifPresent: [ :action | stream ++ 3. action value: stream ]}}}Positionable write streams can also be explored. The motivating use case is attempting a complex write and being able to abandon it if it doesn't work out.{{{	String new writing		write: 'Hello ';		explore: [ :stream | stream write: 'Fooled!' ];		write: 'World!';		conclusion}}}{{{	String new writing		write: 'Hello ';		explore: [ :stream | stream write: 'World!' ];		-= 0;		conclusion}}}The most common kind of exploration is to 'peek' ahead by one element only. This is a short hand for aStream explore: [aStream get], eg:{{{	'Hello' reading peek.}}}	== Write vs Insert ==At times it is useful to be able to insert elements into the existing content of a positionable write stream. All the #write:... methods have an #insert:... equivalent for that purpose. Insert at the end of the stream has the same effect as write, similarly insert: on non-positionable stream is the same as write:.{{{	String new writing		write: 'Hello World!';		+= 5;		insert: ', Hello';		-= 0;		conclusion}}}	== Buffered Writing ==When writing to a write stream, it is the habit of Xtreams to always send data through immediately. There are cases where sending data immediately (eg: through a socket or protocol) could cause a protocol to become "chatty". When you know where it is you can safely flush to keep a protocol happy, it is useful to buffer up write data before transmitting it.{{{	(ByteArray new writing buffering: 10)		write: #[ 1 2 3 4 5 ];		write: #[ 6 7 8 9 0 ];		put: 11;		flush;		conclusion.}}}DbIdentifier: bear73DbTrace: 490989DbUsername: jkottDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'Xtreams-Support' ''))DialectVersion: VisualWorks 7.9MonticelloPrefix: XTNamespace: Smalltalk.XtreamsPackageName: Xtreams-CoreParcel: #('Xtreams-Core')ParcelName: Xtreams-CorePrerequisiteDescriptions: #(#(#name 'Xtreams-Support' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Support' ''))PrintStringCache: (8.2 - 1,jkott)Url: http://www.squeaksource.com/Xtreams/Xtreams-Core-nice.5.mczVersion: 8.2 - 1Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.WriteStream</class-id><body>Abstract superclass of all write streams; defines the API.Write streams are created by sending #writing to a concrete resource (a.k.a terminal), such as a Collection, SocketAccessor, Filename, etc.	String new writing write: 'testing'; close; terminalTransform write streams are created through one of the messages in the 'transforming' protocol sent to other write streams.	(String new writing collecting: #asUppercase) write: 'testing'; close; terminalSubclasses must implement the following messages:	#read:into:at:	#contentsSpeciesInstance Variables	destination	&lt;Object&gt; a stream or "terminal" consuming written elementsShared Variables	Backspace	&lt;Character&gt;	Bell	&lt;Character&gt;	CarriageReturn	&lt;Character&gt;	Delete	&lt;Character&gt;	DoubleQuote	&lt;Character&gt;	Escape	&lt;Character&gt;	FormFeed	&lt;Character&gt;	LineFeed	&lt;Character&gt;	Quote	&lt;Character&gt;	Space	&lt;Character&gt;	Tab	&lt;Character&gt;	VerticalTab	&lt;Character&gt;</body></comment><class><name>BufferedWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.BufferedWriteStream</class-id><body>Caches written output in a fixed size buffer. Buffer content is flushed into the underlying destination when the buffer fills up and new room is needed. The buffer can also be flushed explicitly via #flush or #close.Instance Variables	buffer	&lt;Buffer&gt;	a fixed size output buffer</body></comment><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.ReadStream</class-id><body>Abstract superclass of all read streams, defines the API.Read streams are created by sending #reading to a concrete resource (a.k.a terminal), such as a Collection, SocketAccessor, Filename, etc.	'testing' reading restTransform read streams are created through one of the messages in the 'transforming' protocol sent to other read streams.	('testing' reading collecting: #asUppercase) restSubclasses must implement the following messages:	#read:into:at:	#contentsSpeciesInstance Variables	source	&lt;Object&gt; a read stream or "terminal" producing the elements</body></comment><class><name>PositionReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.PositionReadStream</class-id><body>Wraps a non-positionable stream and provides positioning capability by buffering read elements. Buffering strategy can be configured via different Buffer classes.Instance Variables	buffer	&lt;Buffer&gt; holds read elements</body></comment><class><name>Incomplete</name><environment>Xtreams</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection count start </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.Incomplete</class-id><body>This error is raised when a read or write fails to complete. The parameters report the details about successfully written or read elements.Instance Variables	collection	&lt;Collection | nil&gt; when possible points at the collection with the successfully processed elements	count	&lt;Integer&gt; number of successfully processed elements	start	&lt;Integer&gt; if collection is set, this is the index where the successfully processed elements start</body></comment><class><name>Buffer</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache readPosition writePosition dataLength </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.Buffer</class-id><body>Buffer implements a buffering API over an in-memory cache. The cache will grow as required to fit new data in to the buffer. Two positions are kept, the read position and write position, allowing flexible usage of the buffer.API:	read:into:startingAt: -- reads data from the cache and moves readPosition forward	write:into:startingAt: -- writes data into the cache and moves writePosition forward	readSkip:/writeSkip: -- moves either readPosition or writePosition forward without changing the cache	readPosition/readPosition:/writePosition/writePosition: -- accessors to the read/write positions	clear -- remove all the data from the cache	trim -- remove all the read data and all the empty space for writing in to from the cacheInstance Variables	cache	&lt;SequenceableCollection&gt;	the cache for our buffer	dataLength	&lt;ArithmeticValue&gt;	the amount of data in our cache, not the size of the cache	readPosition	&lt;ArithmeticValue&gt;	the position within our data that we're reading from (0..dataLength)	writePosition	&lt;ArithmeticValue&gt;	the position within our data that we're writing from (0..dataLength)</body></comment><class><name>RingBuffer</name><environment>Xtreams</environment><super>Xtreams.Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.RingBuffer</class-id><body>RingBuffer is a specialized buffer that has a fixed sized cache. The cache is treated as ring/circle, such that when we get to the end of the cache, we continue reading and writing data from the beginning of the cache. If you write more data than you have written, the unread data is lost. The readPosition and writePosition are always relative to the dataPosition, which is a hidden implementation detail.Instance Variables	dataPosition	&lt;ArithmeticValue&gt;	the position in our cache where our data starts</body></comment><class><name>ElasticBuffer</name><environment>Xtreams</environment><super>Xtreams.RingBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.ElasticBuffer</class-id><body>ElasticBuffer is a variation on a ring buffer that will grow if it has no room to write the data in to its cache. It will split the cache and insert new elements if necessary, otherwise it will wrap around like a regular ring buffer. You have a slightly more liberal 'rewind' policy than the RingBuffer such that if you read data, then write data, it will only overwrite the read data if the write data can fit in to that space, otherwise it will grow the cache.</body></comment><class><name>PositionWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><comment><class-id>Xtreams.PositionWriteStream</class-id><body>Wraps a non-positionable stream and provides positioning capability by buffering written elements. Buffering strategy can be configured via different Buffer classes.Instance Variables	buffer	&lt;Buffer&gt; holds written elements</body></comment><shared-variable><name>Delete</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>Escape</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>Bell</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>Space</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>VerticalTab</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>CarriageReturn</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>Quote</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>Tab</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>LineFeed</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>Backspace</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>DoubleQuote</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><shared-variable><name>FormFeed</name><environment>Xtreams.WriteStream</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Core</package></attributes></shared-variable><methods><class-id>Xtreams.WriteStream</class-id> <category>characters</category><body package="Xtreams-Core">backspace	self write: Backspace</body><body package="Xtreams-Core">bell	self write: Bell</body><body package="Xtreams-Core">cr	self write: CarriageReturn</body><body package="Xtreams-Core">delete	self write: Delete</body><body package="Xtreams-Core">escape	self write: Escape</body><body package="Xtreams-Core">ff	self write: FormFeed</body><body package="Xtreams-Core">lf	self write: LineFeed</body><body package="Xtreams-Core">print: anObject	anObject streamingPrintOn: self</body><body package="Xtreams-Core">q	self write: Quote</body><body package="Xtreams-Core">qq	self write: DoubleQuote</body><body package="Xtreams-Core">space	self write: Space</body><body package="Xtreams-Core">space: anInteger	anInteger timesRepeat: [self space]</body><body package="Xtreams-Core">tab	self write: Tab</body><body package="Xtreams-Core">tab: anInteger	anInteger timesRepeat: [self tab]</body><body package="Xtreams-Core">vtab	self write: VerticalTab</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Core">close	"Close the destination from any more writes."	self flush.	destination close</body><body package="Xtreams-Core">contentsSpecies	"The class of collection that is able to hold the kind of elements that this stream consumes."	"	^	&lt;Class&gt;	collection class	"	^self subclassResponsibility</body><body package="Xtreams-Core">flush	"Make sure all the previously written elements are pushed down into the destination."	destination flush</body><body package="Xtreams-Core">on: aDestination	destination := aDestination</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>seeking</category><body package="Xtreams-Core">++ anInteger	"Seek forward by anInteger elements. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	the number of elements to go forward by.		^&lt;Integer&gt;	the number of elements actually skipped	"	"		'Hello Would' copy writing ++ 6; write: 'World'; close; destination	"	"Subclasses should reimplement this method if the stream is positionable."	self isPositionable		ifFalse:	[Incomplete zero raise]		ifTrue:	[self subclassResponsibility]</body><body package="Xtreams-Core">+= anInteger	"Seek from the start of the stream by anInteger elements. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	The number of elements to go forward by."	"		String new writing write: 'Hello Would'; += 6; write: 'World'; close; destination	"	^self position: anInteger</body><body package="Xtreams-Core">-- anInteger	"Seek backward by anInteger elements. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	The number of elements to go back by."	"		String new writing write: 'helio'; -- 2; write: 'lo'; close; destination	"	"Subclasses should reimplement this method if the stream is positionable."	self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body><body package="Xtreams-Core">-= anInteger	"Seek backwards from the end of the stream by anInteger elements. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	The number of elements to go back by.		^&lt;Integer&gt;	the number of elements actually skipped"	"		'Hello Would' copy writing -= 3; write: 'rld'; close; terminal	"	| available |	available := anInteger min: self length.	self position: self length - available.	available = anInteger ifTrue: [ ^anInteger ].	^(Incomplete count: available) raise</body><body package="Xtreams-Core">available	"Return the number of elements from the current position to the end of the stream. The stream must be positionable."	"	^	&lt;Integer&gt;	the number of elements available"	"		String new writing write: 'Hello World'; -- 5; available	"	^self length - self position</body><body package="Xtreams-Core">explore: aBlock	" Explore the stream within the block but return to where we started when the block completes. The stream must be positionable."	"	aBlock	&lt;BlockClosure&gt;	defines the exploration activity		^		&lt;Object&gt;	result of aBlock"	"		String new writing explore: [ :s | s write: 'Hello' ]; write: 'World'; close; destination	"	| position |	position := self position.	^[aBlock cull: self] ensure: [self position: position]</body><body package="Xtreams-Core">length	"Return total length of the stream. The stream must be positionable."	"	^	&lt;Integer&gt;	the total number of elements in the stream. (position + available)"	"		'Hello World' copy writing ++ 5; length	"	"Subclasses should reimplement this method if the stream is positionable."	^self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body><body package="Xtreams-Core">position	"Return current position of the stream. The stream must be positionable."	"	^	&lt;Integer&gt;	current position of the stream."	"		'Hello World' copy writing -= 5; position	"	"Subclasses should reimplement this method if the stream is positionable."	^self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body><body package="Xtreams-Core">position: anInteger	"Change current position of the stream to anInteger. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	current position of the stream."	"		'Hello Would' copy writing position: 6; write: 'World'; close; destination	"	"Subclasses should reimplement this method if the stream is positionable."	self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>accessing</category><body package="Xtreams-Core">conclusion	"Close the stream and return the object at the bottom of the stream."	"	^&lt;Collection | Buffer | IOAccessor | BlockClosure&gt; "	self close.	^self terminal</body><body package="Xtreams-Core">destination	^destination</body><body package="Xtreams-Core">insert: aStreamable	"Insert aStreamable into self at current position."	"	aStreamable	&lt;SequenceableCollection | ReadStream | Buffer&gt;	the source to write in to the destination	 	^&lt;Integer&gt;	the number of elements written to the destination"	"		' World!' copy writing insert: 'Hello' reading; -= 0; close; destination	"	^aStreamable streamingInsertInto: self</body><body package="Xtreams-Core">insert: anInteger from: aStreamable	"Insert anIntegers worth of elements from aStreamable into self at current position."	"	anInteger	&lt;Integer&gt;	the number of elements to insert	 	aStreamable	&lt;ReadStream | SequenceableCollection | Buffer &gt;	the source to write into the destination	 	startIndex	&lt;Integer&gt;	the index into aSequenceableCollection to start writing from		^&lt;Integer&gt;	number of elements inserted	""		' World!' copy writing insert: 5 from: 'Hello Underworld!' reading; -= 0; close; destination	"	aStreamable streamingInsert: anInteger into: self.	^anInteger</body><body package="Xtreams-Core">insert: anInteger from: aSequenceableCollection at: startIndex	"Insert anIntegers worth of elements from aSequenceableCollection starting at startIndex into self at current position."	"	anInteger	&lt;Integer&gt;	the number of elements to insert	 	aStreamable	&lt;SequenceableCollection&gt;	the source to write into the destination	 	startIndex	&lt;Integer&gt;	the index into aSequenceableCollection to start writing from		^&lt;Integer&gt;	number of elements inserted	""		' World!' copy writing insert: 5 from: 'Hello' at: 1; -= 0; close; destination	"	self write: anInteger from: aSequenceableCollection at: startIndex.	^anInteger</body><body package="Xtreams-Core">put: anObject	"Write anObject into self."	"	anObject		&lt;Object&gt;	the object to write in to the destination	 	^				&lt;Object&gt;	the object that was written to the destination	""		String new writing put: $h; close; destination	"	| cache |	cache := self contentsSpecies newRecycled: 1.	cache at: 1 put: anObject.	self write: 1 from: cache at: 1.	cache recycle.	^anObject</body><body package="Xtreams-Core">putUint16: uint	self put: (uint bitShift: -8); put: (uint bitAnd: 255)</body><body package="Xtreams-Core">putUint24: uint	self put: (uint bitShift: -16); putUint16: (uint bitAnd: 16rFFFF)</body><body package="Xtreams-Core">putUint32: uint	self put: (uint bitShift: -24); putUint24: (uint bitAnd: 16rFFFFFF)</body><body package="Xtreams-Core">terminal	"Return the object at the bottom of the stream."	"	^&lt;Collection | Buffer | IOAccessor | BlockClosure&gt;	"	^(destination isKindOf: WriteStream)		ifTrue: [ destination terminal ]		ifFalse: [ destination ]</body><body package="Xtreams-Core">write: aStreamable	"Write aStreamable into self."	"	aStreamable	&lt;SequenceableCollection | ReadStream | Buffer&gt;	the source to write in to the destination	 	^&lt;Integer&gt;	the number of elements written to the destination"	"		String new writing write: 'Hello' reading; close; destination	"	^aStreamable streamingWriteInto: self</body><body package="Xtreams-Core">write: anInteger from: aStreamable	"Write anInteger's worth of elements from aStreamable into self."	"	anInteger	&lt;Integer&gt;	the number of elements to write	 	aStreamable	&lt;SequenceableCollection | ReadStream | Buffer&gt;	the source to write in to the destination		^&lt;Integer&gt;	number of elements written	""		String new writing write: 3 from: 'Hello' reading; close; destination	"	^aStreamable streamingWrite: anInteger into: self</body><body package="Xtreams-Core">write: anInteger from: aSequenceableCollection at: startIndex	"Write anIntegers worth of elements from aSequenceableCollection starting at startIndex into self."	"	anInteger	&lt;Integer&gt;	the number of elements to write	 	aStreamable	&lt;SequenceableCollection&gt;	the source to write in to the destination	 	startIndex	&lt;Integer&gt;	the index into aSequenceableCollection to start writing from		^&lt;Integer&gt;	number of elements written	""		String new writing write: 3 from: 'Hello' at: 2; close; destination	"	^self subclassResponsibility</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>printing</category><body package="Xtreams-Core">printOn: aStream	| stream |	stream := String new writing.	self streamingPrintOn: stream.	aStream nextPutAll: stream conclusion.	aStream cr.	destination printOn: aStream.</body><body package="Xtreams-Core">streamingPrintOn: aStream	aStream write: self class name</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>testing</category><body package="Xtreams-Core">isPositionable	"Can this stream be positioned. Positionable streams come with extra API: #position, #position:, etc."	^false</body><body package="Xtreams-Core">isReadable	^false</body><body package="Xtreams-Core">isWritable	^true</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>transforming</category><body package="Xtreams-Core">buffering: bufferSize	"Delays committing its content to its underlying stream until it has reached a certain size ,#flush is sent, or the stream is closed."	"	bufferSize	&lt;Integer&gt; The size of the buffer to start with.		^&lt;PositionWriteStream&gt;"	"		(ByteArray new writing buffering: 5)			write: (ByteArray withAll: (1 to: 11));			conclusion	"	^BufferedWriteStream on: self bufferSize: bufferSize</body><body package="Xtreams-Core">positioning	"If necessary add positioning layer. Note that positioning layer employs buffering to implement the ability. In this case the buffering strategy will grow the buffer up to the full size of the written content if not flushed appropriately. Other buffer types might be more suitable for specific circumstances, see #positioning: as an alternative example."	"	^	&lt;WriteStream&gt;	a positionable write stream	""		[ :x | Transcript space; print: x ] writing positioning write: (1 to: 10); -- 5; write: (11 to: 15); close	"	^self isPositionable		ifTrue:	[self]		ifFalse:	[PositionWriteStream on: self]</body><body package="Xtreams-Core">positioning: max	"If necessary add a positioning layer that allows stepping back at most @max elements. Note that in this case the positioning layer employs a ring buffer of @max size to implement the ability.	""	max		&lt;SmallInteger&gt;	how far back can you go		^	&lt;WriteStream&gt;	a write stream with limited positionability	""		([ :x | Transcript space; print: x ] writing positioning: 5) write: (1 to: 10); -- 5; write: (11 to: 15); close	"	^self isPositionable		ifTrue:	[self]		ifFalse:	[PositionWriteStream on: self buffer: (RingBuffer new: max class: self contentsSpecies)]</body><body package="Xtreams-Core">writing	"Return a writeable stream. This is to make the method polymorphic between write streams and terminals."	"	^	&lt;WriteStream&gt;	"	^self</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>private</category><body package="Xtreams-Core">streamingInsert: anInteger from: aReadStream	| cache toDo continue amount |	cache := aReadStream contentsSpecies newRecycledDefaultSize.	toDo := anInteger. continue := true.	[ continue and: [ toDo &gt; 0 ] ] whileTrue: [		amount := [ aReadStream read: (cache size min: toDo) into: cache at: 1 ] on: Incomplete do: [ :ex | continue := false. ex count ].		self insert: amount from: cache at: 1.		toDo := toDo - amount ].	cache recycle.	toDo &gt; 0 ifTrue: [(Incomplete count: anInteger - toDo) raise].	^anInteger</body><body package="Xtreams-Core">streamingInsertFrom: aReadStream	| count cache |	count := 0.	cache := aReadStream contentsSpecies newRecycledDefaultSize.	[[aReadStream read: cache size into: cache at: 1] on: Incomplete do: [:exception |		self insert: exception.		cache recycle.		^count + exception count].	self insert: cache size from: cache at: 1.	count := count + cache size] repeat</body><body package="Xtreams-Core">streamingWrite: anInteger from: aReadStream	| cache toDo continue amount |	cache := aReadStream contentsSpecies newRecycledDefaultSize.	toDo := anInteger. continue := true.	[ continue and: [ toDo &gt; 0 ] ] whileTrue: [		amount := [ aReadStream read: (cache size min: toDo) into: cache at: 1 ] on: Incomplete do: [ :ex | continue := false. ex count ].		self write: amount from: cache at: 1.		toDo := toDo - amount ].	cache recycle.	toDo &gt; 0 ifTrue: [(Incomplete count: anInteger - toDo) raise].	^anInteger</body><body package="Xtreams-Core">streamingWriteFrom: aReadStream	| count cache |	count := 0.	cache := aReadStream contentsSpecies newRecycledDefaultSize.	[[aReadStream read: cache size into: cache at: 1] on: Incomplete do: [:exception |		self write: exception.		cache recycle.		^count + exception count].	self write: cache size from: cache at: 1.	count := count + cache size] repeat</body></methods><methods><class-id>Xtreams.WriteStream class</class-id> <category>class initialization</category><body package="Xtreams-Core">initialize	Backspace := String with: Character backspace.	Bell := String with: (Character value: 7).	CarriageReturn := String with: Character cr.	Delete := String with: (Character value: 127).	DoubleQuote := String with: $".	Escape := String with: (Character value: 27).	FormFeed := String with: Character newPage.	LineFeed := String with: Character lf.	Quote := String with: $'.	Space := String with: Character space.	Tab := String with: Character tab.	VerticalTab := String with: (Character value: 11)</body></methods><methods><class-id>Xtreams.WriteStream class</class-id> <category>accessing</category><body package="Xtreams-Core">toolListIcon		^BehaviorIcons WriteStream</body></methods><methods><class-id>Xtreams.WriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Core">on: aDestination	^self new on: aDestination</body></methods><methods><class-id>Xtreams.BufferedWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Core">close	buffer isNil ifTrue: [^self].	super close.	buffer recycle.	buffer := nil</body><body package="Xtreams-Core">contentsSpecies	^destination contentsSpecies</body><body package="Xtreams-Core">flush	buffer ifNil: [ ^ self ].	destination write: buffer; flush.	buffer reset</body><body package="Xtreams-Core">on: aDestination bufferSize: bufferSize	buffer := Buffer new: bufferSize class: aDestination contentsSpecies.	super on: aDestination</body></methods><methods><class-id>Xtreams.BufferedWriteStream</class-id> <category>printing</category><body package="Xtreams-Core">streamingPrintOn: aStream	super streamingPrintOn: aStream.	aStream		write: ' buffered: ';		print: buffer writeSize.	buffer writeSize isZero ifTrue: [^self].	aStream		cr; tab;		print: buffer contentsPast</body></methods><methods><class-id>Xtreams.BufferedWriteStream</class-id> <category>accessing</category><body package="Xtreams-Core">put: anObject	buffer cacheSize &gt; buffer activeSize ifFalse: [self flush].	buffer put: anObject.	^1</body><body package="Xtreams-Core">write: anInteger from: aSequenceableCollection at: startIndex	| count amount |	count := 0.	[[amount := buffer write: (buffer writeSize min: (anInteger - count)) from: aSequenceableCollection at: startIndex + count.	count := count + amount.	count &lt; anInteger] whileTrue: [self flush]]		on: Incomplete do: [:exception | (Incomplete on: aSequenceableCollection count: count + exception count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.BufferedWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Core">on: aDestination bufferSize: bufferSize	^self new on: aDestination bufferSize: bufferSize</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>private</category><body package="Xtreams-Core">streamingInsert: anInteger into: aWriteStream	aWriteStream streamingInsert: anInteger from: self</body><body package="Xtreams-Core">streamingInsertInto: aWriteStream	^aWriteStream streamingInsertFrom: self</body><body package="Xtreams-Core">streamingWrite: anInteger into: aWriteStream	^aWriteStream streamingWrite: anInteger from: self</body><body package="Xtreams-Core">streamingWriteInto: aWriteStream	^aWriteStream streamingWriteFrom: self</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>testing</category><body package="Xtreams-Core">isPositionable	"Can this stream be positioned. Positionable streams support additional API: #position, #position:, ++, --, ..."	^false</body><body package="Xtreams-Core">isReadable	^true</body><body package="Xtreams-Core">isWritable	^false</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Core">close	source close</body><body package="Xtreams-Core">contentsSpecies	"Returns collection class suitable to hold elements of this stream."	^self subclassResponsibility</body><body package="Xtreams-Core">on: aSource	source := aSource</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>accessing</category><body package="Xtreams-Core">get	"Read an object from self.	If there aren't any elements left in the stream, the Incomplete exception is raised."	"	^	&lt;Object&gt; an object read from this stream	"	| cache object |	cache := self contentsSpecies newRecycled: 1.	self read: 1 into: cache at: 1.	object := cache first.	cache recycle.	^object</body><body package="Xtreams-Core">getUint16	^(self get bitShift: 8) + self get</body><body package="Xtreams-Core">getUint24	^(self getUint16 bitShift: 8) + self get</body><body package="Xtreams-Core">getUint32	^(self getUint24 bitShift: 8) + self get</body><body package="Xtreams-Core">read: anInteger	"Read anInteger's worth of elements from self and return them in a collection.	If full anInteger number of elements cannot be read from the source, the Incomplete exception is raised."	"	anInteger	&lt;Integer&gt;	the number of elements to read 	 	^&lt;SequenceableCollection&gt;	a new collection containing anIntegers worth of elements	"	| newCollection |	newCollection := self contentsSpecies withSize: anInteger.	self read: anInteger into: newCollection at: 1.	^newCollection</body><body package="Xtreams-Core">read: anInteger into: aSequenceableCollection	"Read anInteger's worth of elements into aSequenceableCollection starting from index 1.	If full anInteger number of elements cannot be read from the source, the Incomplete exception is raised."	"	anInteger	&lt;Integer&gt;	the number of elements to read	 	aSequenceableCollection	&lt;SequenceableCollection&gt;	the destination to read into		^&lt;Integer&gt;	number of elements read	"	^self read: anInteger into: aSequenceableCollection at: 1</body><body package="Xtreams-Core">read: anInteger into: aSequenceableCollection at: startIndex	"Read anInteger's worth of elements into aSequenceableCollection starting at startIndex.	If full anInteger number of elements cannot be read from the source, the Incomplete exception is raised."	"	anInteger	&lt;Integer&gt;	the number of elements to read	 	aSequenceableCollection	&lt;SequenceableCollection&gt;	the destination to read into		startIndex	&lt;Integer&gt;	the index into aSequenceableCollection to start writing to		^&lt;Integer&gt;	number of elements read	"	self subclassResponsibility	"Subclasses must implement this message. All effort must be taken to read anInteger, blocking if necessary. "</body><body package="Xtreams-Core">rest	"Read all remaining elements from self."	"	^		&lt;SequenceableCollection&gt;	a new collection of elements read from this stream	"	"Implementation note: Originally we sent #close then #destination, but sending #close will perform a #become:		and our constructed write stream is going to go away as soon as we leave this method, so we're better off		using #contents instead"	^self contentsSpecies new writing		write: self;		contents</body><body package="Xtreams-Core">source	"Return the source of this stream."	^source</body><body package="Xtreams-Core">terminal	"Return the object at the bottom of the stream."	"	^&lt;Collection | Buffer | IOAccessor | BlockClosure&gt;	"	^(source isKindOf: ReadStream)		ifTrue: [ source terminal ]		ifFalse: [ source ]</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>seeking</category><body package="Xtreams-Core">++ anInteger	"Seek forward by anInteger elements."	"	anInteger	&lt;Integer&gt;	the number of elements to go forward by		^&lt;Integer&gt;	the number of elements skipped	""		'Hello' reading ++ 2; rest	"	| count cache chunk read |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	anInteger = 0 ifTrue: [^0].	count := 0.	chunk := DefaultBufferSize min: anInteger.	cache := self contentsSpecies newRecycledDefaultSize.	[[count &lt; anInteger] whileTrue:		[read := chunk min: (anInteger - count).		self read: read into: cache at: 1.		count := count + read]]			on: Incomplete do: [ :ex | cache recycle. (Incomplete count: count + ex count) raise].	cache recycle.	^anInteger</body><body package="Xtreams-Core">+= anInteger	"Seek from the start of the stream by anInteger elements. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	The number of elements to go forward by."	"		'Hello' reading rest; += 2; rest	"	^self position: anInteger</body><body package="Xtreams-Core">-- anInteger	"Seek backward by anInteger elements. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	The number of elements to go back by."	"		'hello' reading rest; -- 3; rest	"	"Subclasses should reimplement this method if the stream is positionable."	self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body><body package="Xtreams-Core">-= anInteger	"Seek backwards from the end of the stream by anInteger elements. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	number of elements to go back by		^&lt;Integer&gt;	number of elements actually skipped	""		'Hello' reading -= 3; rest	"	| available |	(self isPositionable not and: [anInteger isZero]) ifTrue:		["If we are attempting to skip to end and the stream is not positionable, skip forward until we hit an incomplete"		[[self ++ SmallInteger maxVal] repeat] on: Incomplete do: [].		^0 ].	available := anInteger min: self length.	self position: self length - available.	available = anInteger ifTrue: [^anInteger].	^(Incomplete count: available) raise</body><body package="Xtreams-Core">atEnd	" Are there any more elements after current position. The stream must be positionable."	"	^		&lt;Boolean&gt;"	"		'Hello' reading -= 0; atEnd	"	"some non-positionables answer position and length, c.f. limiting:"	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	^self position = self length</body><body package="Xtreams-Core">available	"Return the number of elements available. The stream must be positionable."	"	^	&lt;Integer&gt;	the number of elements available"	"		'Hello' reading ++2; available	"	^self length - self position</body><body package="Xtreams-Core">explore: aBlock	" Explore the stream within the block but return to where we started when the block completes. The stream must be positionable."	"	aBlock	&lt;BlockClosure&gt;	defines the exploration activity		^		&lt;Object&gt;	result of aBlock"	"		'Hello' reading explore: [ :s | s -= 0 ]; rest	"	| position |	position := self position.	^[aBlock cull: self] ensure: [self position: position]</body><body package="Xtreams-Core">length	"Return total length of the stream. The stream must be positionable."	"	^	&lt;Integer&gt;	the total number of elements in the stream. (position + available)"	"		'Hello' reading read: 2; length	"	"Subclasses should reimplement this method if the stream is positionable."	^self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body><body package="Xtreams-Core">peek	" Explore the stream forward by one element then rewind once. The stream must be positionable."	"	^		&lt;Object&gt;	result of aBlock"	"		'Hello' reading peek	"	| element |	self isPositionable ifFalse: [ self error: 'This stream is not positionable.' ].	element := self get.	self -- 1.	^element</body><body package="Xtreams-Core">position	"Return current position of the stream. The stream must be positionable."	"	^	&lt;Integer&gt;	the current position in the stream."	"		'Hello' reading read: 2; position	"	"Subclasses should reimplement this method if the stream is positionable."	^self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body><body package="Xtreams-Core">position: anInteger	"Change position of the stream to anInteger. The stream must be positionable."	"	anInteger	&lt;Integer&gt;	the position to set the stream at.		^&lt;Integer&gt;	the position the stream was set to	""		'Hello' reading position: 2; rest	"	"Subclasses should reimplement this method if the stream is positionable."	self isPositionable		ifFalse:	[self error: 'This stream is not positionable.']		ifTrue:	[self subclassResponsibility]</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>printing</category><body package="Xtreams-Core">printOn: aStream	| stream |	stream := String new writing.	self streamingPrintOn: stream.	aStream nextPutAll: stream conclusion.	aStream cr.	source printOn: aStream</body><body package="Xtreams-Core">streamingPrintOn: aStream	| hash |	aStream write: self class name; put: $..	hash := self identityHash bitAnd: 16rFFF.	[ hash &gt; 0 ] whileTrue: [		aStream put: ('ABCDEFGHIJKLMNOP' at: (hash bitAnd: 15) + 1).		hash := hash bitShift: -4 ]</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>enumerating</category><body package="Xtreams-Core">collect: aBlock  	"Evaluate aBlock with each of the values of the receiver as the argument. Collect the resulting values into a collection."	"	aBlock	&lt;BlockClosure&gt;	#collect: style block transforming the elements being read		^		&lt;Collection&gt;	""		(1 to: 10) reading collect: [ :e | e * e ]	"	| contents |	contents := self contentsSpecies new writing.	self do: [:each | contents put: (aBlock value: each)].	^contents close; destination</body><body package="Xtreams-Core">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. Answer the first element for which aBlock evaluates to true."	"	aBlock	&lt;BlockClosure&gt;	#detect: style block		^		&lt;Object&gt;	first element for which aBlock evalutes to true	"	^self detect: aBlock ifNone: [NotFoundError raise]</body><body package="Xtreams-Core">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. Answer the first element for which aBlock evaluates to true.	Evaluate exceptionBlock if no such element is found."	"	aBlock			&lt;BlockClosure&gt;	#detect: style block		exceptionBlock	&lt;BlockClosure&gt;	evaluated if there wasn't any element for which aBlock returns true		^				&lt;Object&gt;	first element for which aBlock evalutes to true	"	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="Xtreams-Core">do: aBlock	"Read from the stream and pass the read objects to the #do: block one by one until it reaches the end of stream."	"	aBlock	&lt;BlockClosure&gt;	#do: style block evaluated with each element	"	[[aBlock cull: self get] repeat] on: Incomplete do: []</body><body package="Xtreams-Core">do: elementBlock separatedBy: separatorBlock	"Evaluate elementBlock for each element in the stream. Between each pair of elements, but not before the first or after the last, evaluate the separatorBlock."	"	elementBlock	&lt;BlockClosure&gt; evaluated with each element		separatorBlock	&lt;BlockClosure&gt; evaluated between elements	"	| first |	first := true.	self do:		[:elmnt |		first ifTrue: [first := false]			ifFalse: [separatorBlock value].		elementBlock value: elmnt]</body><body package="Xtreams-Core">fold: binaryBlock	"Evaluate binaryBlock with the 1st and th 2nd element of the stream, followed by the result of the first evaluation and the 3rd element of the stream, so on until the stream comes to an end."	"	binaryBlock	&lt;BlockClosure&gt; evaluated with each element	"	| current |	current := self get.	self do: [:next | current := binaryBlock value: current value: next].	^current</body><body package="Xtreams-Core">groupedBy: aBlock	"Return a dictionary whose keys are the result of evaluating aBlock for all elements in	 the stream, and the value for each key is a collection of elements that evaluated to that key.	""	aBlock	&lt;BlockClosure&gt;	#collect: style block evaluated with each element		^		&lt;Dictionary&gt;		keys are results of aBlock for all elements, values are corresponding elements that evaluated to the key	""	     #(1 2 3 4 5) reading groupedBy: [:each | each odd]	"	| result |	result := Dictionary new.	self do:		[:each | | key collection |		key := aBlock value: each.		collection := result at: key ifAbsentPut: [OrderedCollection new].		collection add: each].	self species ~~ OrderedCollection ifTrue:		["Convert the result collections to be the right type.		  Note that it should be safe to modify the dictionary		  while iterating because we only replace values for existing keys"		result keysAndValuesDo:			[:key :value | result at: key put: (self contentsSpecies withAll: value)]].	^result</body><body package="Xtreams-Core">inject: initialValue into: binaryBlock 	"Accumulate a running value associated with evaluation of binaryBlock with the each element and the result of evaluation for previous element. 	The initialValue serves as the previous result for evaluation of the first element."	"	initialValue	&lt;Object&gt;	servers as the previous result for evaluation of the first element.		binaryBlock	&lt;BlockClosure&gt;	evaluated with each element and result of evaluation of previous element	""		(1 to: 10) reading inject: 0 into: [:subTotal :next | subTotal + next].	"	| nextValue |	nextValue := initialValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue</body><body package="Xtreams-Core">reject: aBlock 	"Evaluate aBlock with each element, collect into a collection only those elements for which aBlock evaluates to false."	"	aBlock	&lt;BlockClosure&gt;	#reject: style block used to filter the elements		^		&lt;Collection&gt;		all elements that evaluate to false 	""		(1 to: 10) reading reject: [ :e | e odd ]	"	^self select: [:element | (aBlock value: element) == false]</body><body package="Xtreams-Core">select: aBlock 	"Evaluate aBlock with each element, collect into a collection only those elements for which aBlock evaluates to true."	"	aBlock	&lt;BlockClosure&gt;	#select: style block used to filter the elements		^		&lt;Collection&gt;		all elements that evaluate to true 	""		(1 to: 10) reading select: [ :e | e odd ]	"	| contents |	contents := self contentsSpecies new writing.	self do: [:each | (aBlock value: each) ifTrue: [contents put: each]].	^contents close; destination</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="Xtreams-Core">positioning	"If necessary add positioning layer. Note that positioning layer employs buffering to implement the ability. In this case the buffering strategy will grow the buffer up to the full size of the underlying stream if not released. Other buffer types might be more suitable for specific circumstances, see #positioning: as an alternative example."	"	^	&lt;ReadStream&gt;	a positionable read stream	""		[ Time now ] reading positioning ++ 3; -- 2; get	"	^self isPositionable		ifTrue:	[self]		ifFalse:	[PositionReadStream on: self]</body><body package="Xtreams-Core">positioning: max	"If necessary add a positioning layer that allows stepping back at most @max elements. Note that in this case the positioning layer employs a ring buffer of @max size to implement the positioning ability."	"	max		&lt;SmallInteger&gt;	how far back can you go		^&lt;ReadStream&gt;	a read stream with limited positionability	""		| x | x := 0. ([ x := x + 1 ] reading positioning: 5) ++ 10; -- 4; get	"	^self isPositionable		ifTrue:	[self]		ifFalse:	[PositionReadStream on: self buffer: (RingBuffer new: max class: self contentsSpecies)]</body><body package="Xtreams-Core">reading	"Return a readable stream. This is to make the method polymorphic between read streams and terminals."	"	^	&lt;ReadStream&gt;	"	^self</body></methods><methods><class-id>Xtreams.ReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Core">on: aSource	^self new on: aSource</body></methods><methods><class-id>Xtreams.ReadStream class</class-id> <category>accessing</category><body package="Xtreams-Core">toolListIcon		^BehaviorIcons ReadStream</body></methods><methods><class-id>Xtreams.PositionReadStream</class-id> <category>seeking</category><body package="Xtreams-Core">++ anInteger	| skipped |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	skipped := buffer readSkip: anInteger.	skipped = anInteger ifTrue: [^anInteger].	[super ++ (anInteger - skipped)] on: Incomplete do: [:incomplete |		(Incomplete count: incomplete count + skipped) raise].	^anInteger</body><body package="Xtreams-Core">-- anInteger	| skipped |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	skipped := (buffer readSkip: anInteger negated) negated.	skipped = anInteger ifTrue: [^anInteger].	(Incomplete count: skipped) raise</body><body package="Xtreams-Core">atEnd	" Are there any more elements after current position. The stream must be positionable."	"	^		&lt;Boolean&gt;"	"		([1] reading limiting: 5) positioning -= 0; atEnd	"	^[ self peek. false ] on: Incomplete do: [ :ex | true ]</body><body package="Xtreams-Core">length	"advance to the end"	[ [ self ++ SmallInteger maxVal ] repeat ] on: Incomplete do: [ :ex | ].	^buffer activeSize</body><body package="Xtreams-Core">position	^buffer readPosition</body><body package="Xtreams-Core">position: aPosition	| startPosition delta |	aPosition &lt; 0 ifTrue: [Incomplete zero raise].	startPosition := buffer readPosition.	delta := aPosition - startPosition.	^[	self ++ delta. aPosition	] on: Incomplete do: [ :ex |		(Incomplete count: startPosition + ex count) raise ]</body></methods><methods><class-id>Xtreams.PositionReadStream</class-id> <category>accessing</category><body package="Xtreams-Core">get	| object |	buffer hasDataToRead ifTrue: [^buffer get].	object := source get.	buffer put: object.	buffer readSkip: 1.	^object</body><body package="Xtreams-Core">read: anInteger into: aSequenceableCollection at: startIndex	^[	buffer read: anInteger into: aSequenceableCollection at: startIndex. anInteger	] on: Incomplete do: [:exception || bufferCount sourceCount |		bufferCount := exception count.		sourceCount := anInteger - bufferCount.		[source read: sourceCount into: aSequenceableCollection at: startIndex + exception count]			on: Incomplete do: [:incomplete | sourceCount := incomplete count].		buffer write: sourceCount from: aSequenceableCollection at: startIndex + bufferCount.		buffer readSkip: sourceCount.		(sourceCount + bufferCount) &lt; anInteger ifTrue: [			(Incomplete on: aSequenceableCollection count: sourceCount + bufferCount at: startIndex) raise].		anInteger ]</body></methods><methods><class-id>Xtreams.PositionReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Core">buffer	^buffer</body><body package="Xtreams-Core">buffer: aBuffer	buffer ifNotNil: [ buffer recycle ].	buffer := aBuffer</body><body package="Xtreams-Core">close	buffer isNil ifTrue: [^self].	super close.	buffer recycle.	buffer := nil</body><body package="Xtreams-Core">contentsSpecies	^source contentsSpecies</body></methods><methods><class-id>Xtreams.PositionReadStream</class-id> <category>testing</category><body package="Xtreams-Core">isPositionable	^true</body></methods><methods><class-id>Xtreams.PositionReadStream</class-id> <category>printing</category><body package="Xtreams-Core">streamingPrintOn: aStream	super streamingPrintOn: aStream.	aStream		write: ' buffered: ';		print: buffer readSize.	buffer readSize isZero ifTrue: [^self].	aStream		cr; tab;		print: buffer contentsFuture</body></methods><methods><class-id>Xtreams.PositionReadStream</class-id> <category>transforming</category><body package="Xtreams-Core">positioning	^self</body></methods><methods><class-id>Xtreams.PositionReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Core">on: aSource	^self on: aSource buffer: (Buffer new: DefaultBufferSize class: aSource contentsSpecies)</body><body package="Xtreams-Core">on: aSource buffer: aBuffer	^(super on: aSource)		buffer: aBuffer;		yourself</body></methods><methods><class-id>Xtreams.Incomplete</class-id> <category>private</category><body package="Xtreams-Core">streamingInsert: anInteger into: aWriteStream	| amount |	collection ifNil: [(self class on: collection count: 0 at: start) raise].	amount := anInteger min: count.	aWriteStream insert: amount from: collection at: start.	amount &lt; anInteger ifTrue: [(self class on: collection count: amount at: start) raise].</body><body package="Xtreams-Core">streamingInsertInto: aWriteStream	collection ifNil: [^0].	aWriteStream insert: count from: collection at: start.	^count</body><body package="Xtreams-Core">streamingWrite: anInteger into: aWriteStream	| amount |	collection ifNil: [(self class on: collection count: 0 at: start) raise].	amount := anInteger min: count.	aWriteStream write: amount from: collection at: start.	amount &lt; anInteger ifTrue: [(self class on: collection count: amount at: start) raise].	^anInteger</body><body package="Xtreams-Core">streamingWriteInto: aWriteStream	collection ifNil: [^0].	aWriteStream write: count from: collection at: start.	^count</body></methods><methods><class-id>Xtreams.Incomplete</class-id> <category>accessing</category><body package="Xtreams-Core">collection	^collection</body><body package="Xtreams-Core">collection: anObject	collection := anObject</body><body package="Xtreams-Core">contents	^collection		ifNil: [ self originator contentsSpecies withSize: count ]		ifNotNil: [ collection copyFrom: start to: start + count - 1 ]</body><body package="Xtreams-Core">count	^count</body><body package="Xtreams-Core">count: anObject	count := anObject</body><body package="Xtreams-Core">start	^start</body><body package="Xtreams-Core">start: anObject	start := anObject</body></methods><methods><class-id>Xtreams.Incomplete</class-id> <category>initialize-release</category><body package="Xtreams-Core">on: aCollection count: aCount at: aStart	collection := aCollection.	count := aCount.	start := aStart</body></methods><methods><class-id>Xtreams.Incomplete class</class-id> <category>instance creation</category><body package="Xtreams-Core">count: anInteger	^self new on: nil count: anInteger at: nil</body><body package="Xtreams-Core">on: collection count: count at: start	^self new on: collection count: count at: start</body><body package="Xtreams-Core">zero	^self count: 0</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>accessing</category><body package="Xtreams-Core">activeSize	"The number of elements in the buffer that can be explored. This is &lt;= cacheSize"	^dataLength</body><body package="Xtreams-Core">cache	^cache</body><body package="Xtreams-Core">cacheSize	"The size of the cache, which is &gt;= dataLength"	^cache size</body><body package="Xtreams-Core">contentsFuture	^cache copyFrom: readPosition + 1 to: readPosition + self readSize</body><body package="Xtreams-Core">contentsPast	^cache copyFrom: 1 to: writePosition</body><body package="Xtreams-Core">inactiveSize	"Free space to write in to"	^cache size - dataLength</body><body package="Xtreams-Core">readSize	"The number of elements available to read"	^dataLength - readPosition</body><body package="Xtreams-Core">writeSize	"The number of available slots to write in to, which might overwrite elements in dataLength; writeSize &gt;= inactiveSize"	^(cache size - writePosition + readPosition) min: cache size</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>testing</category><body package="Xtreams-Core">hasDataToRead	^readPosition &lt; dataLength</body><body package="Xtreams-Core">hasFixedWriteSpace	^false</body><body package="Xtreams-Core">hasSpaceToWrite	^true</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>printing</category><body package="Xtreams-Core">printOn: aStream	| stream |	stream := String new writing.	self streamingPrintOn: stream.	aStream nextPutAll: stream conclusion</body><body package="Xtreams-Core">streamingPrintOn: aStream	aStream write: self class name;		space; write: 'data: '; print: dataLength;		space; write: 'read: '; print: self readPosition;		space; write: 'write: '; print: self writePosition</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>private</category><body package="Xtreams-Core">clearCache	cache := cache copyEmpty: 0</body><body package="Xtreams-Core">growBy: anInteger	| replacement |	replacement := cache copyEmpty: (cache size + anInteger) * 2.	replacement replaceFrom: 1 to: cache size with: cache startingAt: 1.	cache := replacement</body><body package="Xtreams-Core">privateWrite: anInteger from: aSequenceableCollection at: startIndex	" Ensure we're only doing with (writePosition + anInteger) &lt;= cache size "	(writePosition + anInteger) &lt;= cache size ifFalse: [self error: 'invalid privateWrite. Use the #write: protocol instead.'].	cache replaceFrom: writePosition + 1 to: writePosition + anInteger with: aSequenceableCollection startingAt: startIndex.	writePosition := writePosition + anInteger.	writePosition &gt; dataLength ifTrue: [dataLength := writePosition]</body><body package="Xtreams-Core">streamingInsert: anInteger into: aWriteStream	| count |	count := (writePosition - readPosition) min: anInteger.	count &lt;= 0 ifTrue: [^0].	aWriteStream insert: count from: cache at: readPosition + 1.	self readSkip: count</body><body package="Xtreams-Core">streamingInsertInto: aWriteStream	| count |	count := writePosition - readPosition.	count &lt;= 0 ifTrue: [^0].	self streamingInsert: count into: aWriteStream.	^count</body><body package="Xtreams-Core">streamingWrite: anInteger from: aReadStream	writePosition + anInteger &lt;= cache size ifFalse: [self growBy: anInteger].	aReadStream read: anInteger into: cache at: writePosition + 1.	writePosition := writePosition + anInteger.	writePosition &gt; dataLength ifTrue: [dataLength := writePosition].	^anInteger</body><body package="Xtreams-Core">streamingWrite: anInteger into: aWriteStream	| count |	count := (writePosition - readPosition) min: anInteger.	count &lt;= 0 ifTrue: [^0].	aWriteStream write: count from: cache at: readPosition + 1.	self readSkip: count.	^count</body><body package="Xtreams-Core">streamingWriteFrom: aReadStream	| count |	count := 0.	^[ 	[ count := count + (self streamingWrite: DefaultBufferSize from: aReadStream) ] repeat	] on: Incomplete do: [ :ex | ex count + count ]</body><body package="Xtreams-Core">streamingWriteInto: aWriteStream	| count |	count := writePosition - readPosition.	count &lt;= 0 ifTrue: [^0].	self streamingWrite: count into: aWriteStream.	^count</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>accessing - reading</category><body package="Xtreams-Core">get	dataLength = readPosition ifTrue: [Incomplete zero raise].	readPosition := readPosition + 1.	^cache at: readPosition</body><body package="Xtreams-Core">read: anInteger into: aSequenceableCollection at: startIndex	| count |	count := anInteger min: (dataLength - readPosition).	aSequenceableCollection replaceFrom: startIndex to: startIndex + count - 1 with: cache startingAt: readPosition + 1.	readPosition := readPosition + count.	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body><body package="Xtreams-Core">readPosition	^readPosition</body><body package="Xtreams-Core">readPosition: aPosition	readPosition := (aPosition max: 0) min: dataLength</body><body package="Xtreams-Core">readSkip: anInteger	| old delta |	old := readPosition.	self readPosition: old + anInteger.	delta := readPosition - old.	^delta</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>accessing - writing</category><body package="Xtreams-Core">insert: aStreamable	^aStreamable streamingInsertInto: self</body><body package="Xtreams-Core">insert: anInteger from: aStreamable	^aStreamable streamingInsert: anInteger into: self</body><body package="Xtreams-Core">insert: anInteger from: aSequenceableCollection at: startIndex	dataLength + anInteger &lt;= cache size ifFalse: [self growBy: anInteger].	cache replaceFrom: writePosition + anInteger + 1 to: dataLength + anInteger with: cache startingAt: writePosition + 1.	cache replaceFrom: writePosition + 1 to: writePosition + anInteger with: aSequenceableCollection startingAt: startIndex.	writePosition := writePosition + anInteger.	dataLength := dataLength + anInteger.	^anInteger</body><body package="Xtreams-Core">put: anObject	writePosition &lt; cache size ifFalse: [self growBy: 1].	cache at: writePosition + 1 put: anObject.	writePosition := writePosition + 1.	writePosition &gt; dataLength ifTrue: [dataLength := writePosition].	^anObject</body><body package="Xtreams-Core">write: aStreamable	^aStreamable streamingWriteInto: self</body><body package="Xtreams-Core">write: anInteger from: aStreamable	^aStreamable streamingWrite: anInteger into: self</body><body package="Xtreams-Core">write: anInteger from: aSequenceableCollection at: startIndex	writePosition + anInteger &lt;= cache size ifFalse: [self growBy: anInteger].	self privateWrite: anInteger from: aSequenceableCollection at: startIndex.	^anInteger</body><body package="Xtreams-Core">writePosition	^writePosition</body><body package="Xtreams-Core">writePosition: aPosition	^writePosition := (aPosition max: 0) min: dataLength</body><body package="Xtreams-Core">writeSkip: anInteger	| old delta |	old := writePosition.	self writePosition: old + anInteger.	delta := writePosition - old.	^delta</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>initialize-release</category><body package="Xtreams-Core">close	dataLength := writePosition</body><body package="Xtreams-Core">contentsSpecies	^cache species</body><body package="Xtreams-Core">on: aSequenceableCollection	cache := aSequenceableCollection.	dataLength := 0.	readPosition := 0.	writePosition := 0</body><body package="Xtreams-Core">recycle	| saved |	saved := cache.	cache := nil.	saved == nil ifFalse: [ saved recycle ]</body></methods><methods><class-id>Xtreams.Buffer</class-id> <category>compressing</category><body package="Xtreams-Core">clear	"Reset the buffer to initial state trimming the cache to zero size."	self clearCache; reset</body><body package="Xtreams-Core">reset	"Reset the buffer to initial state leaving the cache at its current size. Usefult when using the buffer as a fixed size buffer."	readPosition := writePosition := dataLength := 0</body><body package="Xtreams-Core">trim	"Reset the buffer to initial state preserving any unread content."	cache := cache copyFrom: readPosition + 1 to: writePosition.	readPosition := 0.	dataLength := writePosition := cache size</body></methods><methods><class-id>Xtreams.Buffer class</class-id> <category>instance creation</category><body package="Xtreams-Core">new: anInteger class: aClass	^self on: (aClass newRecycled: anInteger)</body><body package="Xtreams-Core">on: aSequenceableCollection	^self new on: aSequenceableCollection</body></methods><methods><class-id>Xtreams.RingBuffer</class-id> <category>compressing</category><body package="Xtreams-Core">clear	super clear.	dataPosition := 0</body><body package="Xtreams-Core">reset	super reset.	dataPosition := 0</body><body package="Xtreams-Core">trim	| read write |	read := (dataPosition + readPosition) \\ cache size.	write := (dataPosition + writePosition) \\ cache size.	read &lt;= write		ifTrue: [cache := cache copyFrom: read + 1 to: write + 1]		ifFalse:			[ | replacement readSize |			readSize := cache size - read.			replacement := cache copyEmpty: write + readSize.			replacement replaceFrom: 1 to: readSize with: cache startingAt: read + 1.			replacement replaceFrom: readSize + 1 to: replacement size with: cache startingAt: write + 1.			cache := replacement].	dataPosition := readPosition := 0.	dataLength := writePosition := cache size</body></methods><methods><class-id>Xtreams.RingBuffer</class-id> <category>private</category><body package="Xtreams-Core">clearCache</body><body package="Xtreams-Core">growBy: anInteger	self shouldNotImplement</body><body package="Xtreams-Core">privateWrapDataPosition: anInteger"	inflatedLength &lt;= cache size --- do nothing	inflatedLength &gt;   cache size --- move dataPosition and readPosition"	| inflatedLength overflow |	inflatedLength := writePosition + anInteger.	inflatedLength &lt;= cache size ifTrue: [^self].	overflow := inflatedLength - cache size.	readPosition := (readPosition - overflow) max: 0.	dataPosition := (dataPosition + overflow) \\ cache size</body><body package="Xtreams-Core">privateWrite: anInteger from: aSequenceableCollection at: startIndex	| write tail |	anInteger &gt; 0 ifFalse: [^self].	" Ensure we're only doing with anInteger &lt;= cache size "	anInteger &gt; cache size ifTrue: [self error: 'invalid privateWrite. Use the #write: protocol instead.'].	write := (dataPosition + writePosition) \\ cache size.	tail := (cache size - write) min: anInteger.	cache replaceFrom: write + 1 to: write + tail with: aSequenceableCollection startingAt: startIndex.	cache replaceFrom: 1 to: anInteger - tail with: aSequenceableCollection startingAt: startIndex + tail.	self privateWrapDataPosition: anInteger.	writePosition := (writePosition + anInteger) min: cache size.	writePosition &gt; dataLength ifTrue: [dataLength := writePosition]</body><body package="Xtreams-Core">streamingInsert: anInteger into: aWriteStream	| read amount tail head |	amount := (dataLength - readPosition) min: anInteger.	read := (dataPosition + readPosition) \\ cache size.	tail := cache size - read min: amount.	head := amount - tail.	aWriteStream insert: tail from: cache at: read + 1.	head &lt;= 0 ifTrue: [^self readSkip: tail].	aWriteStream insert: head from: cache at: 1.	self readSkip: tail + head</body><body package="Xtreams-Core">streamingInsertInto: aWriteStream	| count |	count := dataLength - readPosition.	self streamingInsert: count into: aWriteStream.	^count</body><body package="Xtreams-Core">streamingWrite: total from: source	| write tail |	total &gt; cache size ifTrue: [ | count |		readPosition := 0.		dataLength := writePosition := cache size.		count := total.		[ count &gt; 0 ] whileTrue: [			count := count - (source read: (count min: cache size) into: cache at: 1) ].		dataPosition := total \\ cache size.		^total ].	write := (dataPosition + writePosition) \\ cache size.	tail := (cache size - write) min: total.	source read: tail into: cache at: write + 1.	source read: total - tail into: cache at: 1.		self privateWrapDataPosition: total.	writePosition := (writePosition + total) min: cache size.	writePosition &gt; dataLength ifTrue: [dataLength := writePosition]</body><body package="Xtreams-Core">streamingWrite: anInteger into: aWriteStream	| read amount tail head |	amount := (dataLength - readPosition) min: anInteger.	read := (dataPosition + readPosition) \\ cache size.	tail := cache size - read min: amount.	head := amount - tail.	aWriteStream write: tail from: cache at: read + 1.	head &lt;= 0 ifTrue: [self readSkip: tail. ^anInteger].	aWriteStream write: head from: cache at: 1.	self readSkip: tail + head.	^anInteger</body><body package="Xtreams-Core">streamingWriteInto: aWriteStream	| count |	count := dataLength - readPosition.	self streamingWrite: count into: aWriteStream.	^count</body></methods><methods><class-id>Xtreams.RingBuffer</class-id> <category>accessing</category><body package="Xtreams-Core">contentsFuture	| buffer read tail |	cache isEmpty ifTrue: [^self contentsSpecies new].	read := (dataPosition + readPosition) \\ cache size.	tail := (cache size - read) min: self readSize.	buffer := self contentsSpecies withSize: self readSize.	buffer replaceFrom: 1 to: tail with: cache startingAt: read + 1.	buffer replaceFrom: tail + 1 to: self readSize - tail with: cache startingAt: 1.	^buffer</body><body package="Xtreams-Core">contentsPast	| buffer tail |	cache isEmpty ifTrue: [^self contentsSpecies new].	tail := (cache size - dataPosition) min: self writePosition.	buffer := self contentsSpecies withSize: self writePosition.	buffer replaceFrom: 1 to: tail with: cache startingAt: dataPosition + 1.	buffer replaceFrom: tail + 1 to: buffer size with: cache startingAt: 1.	^buffer</body></methods><methods><class-id>Xtreams.RingBuffer</class-id> <category>accessing - writing</category><body package="Xtreams-Core">insert: anInteger from: aSequenceableCollection at: startIndex	| tail write temp length position |	length := dataLength - writePosition.	write := (dataPosition + writePosition + 1) \\ cache size.	tail := (cache size - write) min: length.	temp := self contentsSpecies newRecycled: (length max: DefaultBufferSize).	temp replaceFrom: 1 to: tail with: cache startingAt: write.	temp replaceFrom: tail + 1 to: length with: cache startingAt: 1.	dataLength := dataLength - length.	self write: anInteger from: aSequenceableCollection at: startIndex.	position := self writePosition.	self write: length from: temp.	self writePosition: position. 	temp recycle.	^anInteger</body><body package="Xtreams-Core">put: anObject	| write |	write := (dataPosition + writePosition) \\ cache size.	cache at: write + 1 put: anObject.	self privateWrapDataPosition: 1.	writePosition := (writePosition + 1) min: cache size.	writePosition &gt; dataLength ifTrue: [dataLength := writePosition].	^anObject</body><body package="Xtreams-Core">write: anInteger from: aSequenceableCollection at: startIndex	anInteger &lt; cache size ifTrue:  [self privateWrite: anInteger from: aSequenceableCollection at: startIndex. ^anInteger].	" Do the quick store, since we're a ring "	dataPosition := readPosition := 0.	dataLength := writePosition := cache size.	cache replaceFrom: 1 to: cache size with: aSequenceableCollection startingAt: startIndex + anInteger - cache size.	^anInteger</body></methods><methods><class-id>Xtreams.RingBuffer</class-id> <category>initialize-release</category><body package="Xtreams-Core">on: aSequenceableCollection	super on: aSequenceableCollection.	dataPosition := 0</body></methods><methods><class-id>Xtreams.RingBuffer</class-id> <category>testing</category><body package="Xtreams-Core">hasFixedWriteSpace	^true</body><body package="Xtreams-Core">hasSpaceToWrite	^self writeSize isZero not</body></methods><methods><class-id>Xtreams.RingBuffer</class-id> <category>accessing - reading</category><body package="Xtreams-Core">get	| read |	dataLength = readPosition ifTrue: [Incomplete zero raise].	read := (dataPosition + readPosition) \\ cache size.	readPosition := readPosition + 1.	^cache at: read + 1</body><body package="Xtreams-Core">read: anInteger into: aSequenceableCollection at: startIndex	| count read tail |	count := anInteger min: (dataLength - readPosition).	read := (dataPosition + readPosition) \\ cache size.	tail := (cache size - read) min: count.	aSequenceableCollection replaceFrom: startIndex to: startIndex + tail - 1 with: cache startingAt: read + 1.	aSequenceableCollection replaceFrom: startIndex + tail to: startIndex + count - 1 with: cache startingAt: 1.	readPosition := readPosition + count.	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.ElasticBuffer</class-id> <category>private</category><body package="Xtreams-Core">clearCache	cache := cache copyEmpty: 0</body><body package="Xtreams-Core">growBy: anInteger	| split replacement growth |	split := dataPosition + writePosition.	cache size isZero ifFalse: [split := split \\ cache size].	split isZero ifTrue: [split := cache size].	growth := cache size + anInteger + anInteger.	replacement := cache copyEmpty: cache size + growth.	replacement replaceFrom: 1 to: split with: cache startingAt: 1.	replacement replaceFrom: split + growth + 1 to: replacement size with: cache startingAt: split + 1.	cache := replacement.	split &lt;= dataPosition ifTrue: [dataPosition := dataPosition + growth]</body><body package="Xtreams-Core">streamingWrite: anInteger from: aReadStream	"Implementing this method would allow the buffer to be treated like a stream sometimes. Currently this is not implemented, make a buffer stream on your buffer instead."	self error: 'not yet implemented'</body></methods><methods><class-id>Xtreams.ElasticBuffer</class-id> <category>testing</category><body package="Xtreams-Core">hasFixedWriteSpace	^false</body><body package="Xtreams-Core">hasSpaceToWrite	^true</body></methods><methods><class-id>Xtreams.ElasticBuffer</class-id> <category>accessing - writing</category><body package="Xtreams-Core">put: anObject	self writeSize &lt; 1 ifTrue: [self growBy: 1].	^super put: anObject</body><body package="Xtreams-Core">write: anInteger from: aSequenceableCollection at: startIndex	anInteger &lt;= self writeSize ifFalse: [self growBy: anInteger - self writeSize].	self privateWrite: anInteger from: aSequenceableCollection at: startIndex.	^anInteger</body></methods><methods><class-id>Xtreams.PositionWriteStream</class-id> <category>transforming</category><body package="Xtreams-Core">positioning	^self</body></methods><methods><class-id>Xtreams.PositionWriteStream</class-id> <category>testing</category><body package="Xtreams-Core">isPositionable	^true</body></methods><methods><class-id>Xtreams.PositionWriteStream</class-id> <category>accessing</category><body package="Xtreams-Core">insert: anInteger from: aSequenceableCollection at: startIndex	^buffer insert: anInteger from: aSequenceableCollection at: startIndex</body><body package="Xtreams-Core">write: anInteger from: aSequenceableCollection at: startIndex	| toFlush bufferFlush |	(buffer hasFixedWriteSpace not or: [buffer writeSize &gt;= anInteger ]) ifTrue: [		buffer write: anInteger from: aSequenceableCollection at: startIndex.		^anInteger ].	toFlush := buffer readSize + anInteger - buffer cacheSize.	bufferFlush := toFlush min: buffer readSize.	destination write: bufferFlush from: buffer.	(toFlush &gt; bufferFlush) ifTrue: [		toFlush := toFlush - bufferFlush.		destination write: toFlush from: aSequenceableCollection at: startIndex ].	buffer write: anInteger - toFlush from: aSequenceableCollection at: startIndex + toFlush.	^anInteger</body></methods><methods><class-id>Xtreams.PositionWriteStream</class-id> <category>seeking</category><body package="Xtreams-Core">++ anInteger	| skipped |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	skipped := buffer writeSkip: anInteger.	skipped = anInteger ifTrue: [^anInteger].	[destination ++ (anInteger - skipped)] on: Incomplete do: [:incomplete |		(Incomplete count: incomplete count + skipped) raise].	^anInteger</body><body package="Xtreams-Core">-- anInteger	| skipped |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	skipped := (buffer writeSkip: anInteger negated) negated.	skipped = anInteger ifTrue: [^anInteger].	(Incomplete count: skipped) raise</body><body package="Xtreams-Core">available	^buffer writeSize</body><body package="Xtreams-Core">length	^buffer activeSize</body><body package="Xtreams-Core">position	^buffer writePosition</body><body package="Xtreams-Core">position: aPosition	| startPosition delta |	aPosition &lt; 0 ifTrue: [Incomplete zero raise].	startPosition := buffer writePosition.	delta := aPosition - startPosition.	^[	self ++ delta. aPosition	] on: Incomplete do: [ :ex |		(Incomplete count: startPosition + ex count) raise ]</body></methods><methods><class-id>Xtreams.PositionWriteStream</class-id> <category>printing</category><body package="Xtreams-Core">streamingPrintOn: aStream	super streamingPrintOn: aStream.	aStream		write: ' buffered: ';		print: buffer writeSize.	buffer writeSize isZero ifTrue: [^self].	aStream		cr; tab;		print: buffer contentsPast</body></methods><methods><class-id>Xtreams.PositionWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Core">buffer	^buffer</body><body package="Xtreams-Core">buffer: aBuffer	buffer ifNotNil: [ buffer recycle ].	buffer := aBuffer</body><body package="Xtreams-Core">close	buffer isNil ifTrue: [^self].	super close.	buffer recycle.	buffer := nil</body><body package="Xtreams-Core">contentsSpecies	^destination contentsSpecies</body><body package="Xtreams-Core">flush	buffer ifNil: [^self].	destination write: buffer; flush.	buffer clear</body></methods><methods><class-id>Xtreams.PositionWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Core">on: aDestination	^self on: aDestination buffer: (Buffer new: DefaultBufferSize class: aDestination contentsSpecies)</body><body package="Xtreams-Core">on: aDestination buffer: aBuffer	^(super on: aDestination)		buffer: aBuffer;		yourself</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="Xtreams-Core">streamingInsert: anInteger into: aWriteStream	anInteger timesRepeat: [self streamingInsertInto: aWriteStream]</body><body package="Xtreams-Core">streamingInsertInto: aWriteStream	aWriteStream insert: (aWriteStream contentsSpecies with: self)</body><body package="Xtreams-Core">streamingPrintOn: aWriteStream	aWriteStream write: self printString</body><body package="Xtreams-Core">streamingWrite: anInteger into: aWriteStream	anInteger timesRepeat: [self streamingWriteInto: aWriteStream].	^anInteger</body><body package="Xtreams-Core">streamingWriteInto: aWriteStream	aWriteStream put: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private</category><body package="Xtreams-Core">streamingInsert: anInteger into: aWriteStream	^aWriteStream insert: anInteger from: self at: 1</body><body package="Xtreams-Core">streamingInsertInto: aWriteStream	aWriteStream insert: self size from: self at: 1.	^self size</body><body package="Xtreams-Core">streamingWrite: anInteger into: aWriteStream	^aWriteStream write: anInteger from: self at: 1</body><body package="Xtreams-Core">streamingWriteInto: aWriteStream	^aWriteStream write: self size from: self at: 1</body></methods><methods><class-id>Core.UninterpretedBytes</class-id> <category>private</category><body package="Xtreams-Core">streamingInsert: anInteger into: aWriteStream	^aWriteStream insert: anInteger from: self at: 1</body><body package="Xtreams-Core">streamingInsertInto: aWriteStream	aWriteStream insert: self size from: self at: 1.	^self size</body><body package="Xtreams-Core">streamingWrite: anInteger into: aWriteStream	^aWriteStream write: anInteger from: self at: 1</body><body package="Xtreams-Core">streamingWriteInto: aWriteStream	aWriteStream write: self size from: self at: 1.	^self size</body></methods><initialize><class-id>Xtreams.WriteStream</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>